<?xml version="1.0"?>
<doc>
    <assembly>
        <name>PDDLParser</name>
    </assembly>
    <members>
        <member name="T:PDDLParser.World.IClosedWorld">
            <summary>
            Updatable closed world supporting read and write operations.
            </summary>
        </member>
        <member name="T:PDDLParser.World.IReadOnlyClosedWorld">
            <summary>
            Constant closed world supporting read-only operations.
            In a closed world, the value of predicates and fluents is always known. 
            Consequently predicates always evaluate to true or false. Fluents, on the other hand,
            may be undefined (see PDDL specification) but are never unknown.
            </summary>
        </member>
        <member name="T:PDDLParser.World.IReadOnlyOpenWorld">
            <summary>
            Constant open world supporting read-only operations.
            In an open world, the value of predicates and fluents may be unknown.
            Consequently predicates always evaluate to true, false, or unknown. 
            Fluents, on the other hand, may be undefined (see PDDL specification), unknown,
            or defined.
            </summary>
        </member>
        <member name="M:PDDLParser.World.IReadOnlyOpenWorld.IsSet(PDDLParser.Exp.Formula.AtomicFormulaApplication)">
            <summary>
            Checks whether the specified described atomic formula holds in this world.
            </summary>
            <param name="formula">A described (and ground) atomic formula.</param>
            <returns>True, false, or unknown.</returns>
        </member>
        <member name="M:PDDLParser.World.IReadOnlyOpenWorld.GetNumericFluent(PDDLParser.Exp.Formula.NumericFluentApplication)">
            <summary>
            Returns the value of the specified numeric fluent in this world.
            </summary>
            <param name="fluent">A described (and ground) numeric fluent.</param>
            <returns>Unknown, undefined, or the value of the numeric fluent.</returns>
        </member>
        <member name="M:PDDLParser.World.IReadOnlyOpenWorld.GetObjectFluent(PDDLParser.Exp.Formula.ObjectFluentApplication)">
            <summary>
            Returns the value of the specified object fluent in this world.
            </summary>
            <param name="fluent">A described (and ground) object fluent.</param>
            <returns>Unknown, undefined, or a constant representing the value of the 
            object fluent.</returns>
        </member>
        <member name="M:PDDLParser.World.IReadOnlyOpenWorld.GetEvaluation(PDDLParser.Exp.Formula.TLPlan.DefinedPredicateApplication,System.Boolean@)">
            <summary>
            Returns an evaluation record which indicates whether the given defined predicate has
            already been evaluated with the provided arguments, as well as the cached evaluation 
            value.
            </summary>
            <param name="pred">The defined predicate application.</param>
            <param name="existing">This flag is set to true if the defined predicate is already in the
            process of (or has finished) being evaluated.</param>
            <returns>An evaluation record corresponding to the specified defined predicate and 
            arguments.</returns>
        </member>
        <member name="M:PDDLParser.World.IReadOnlyOpenWorld.GetEvaluation(PDDLParser.Exp.Formula.TLPlan.DefinedNumericFunctionApplication,System.Boolean@)">
            <summary>
            Returns an evaluation record which indicates whether the given defined numeric function has
            already been evaluated with the provided arguments, as well as the cached evaluation 
            value.
            </summary>
            <param name="pred">The defined numeric function application.</param>
            <param name="existing">This flag is set to true if the defined numeric function is already
            in the process of (or has finished) being evaluated.</param>
            <returns>An evaluation record corresponding to the specified defined numeric function and 
            arguments.</returns>
        </member>
        <member name="M:PDDLParser.World.IReadOnlyOpenWorld.GetEvaluation(PDDLParser.Exp.Formula.TLPlan.DefinedObjectFunctionApplication,System.Boolean@)">
            <summary>
            Returns an evaluation record which indicates whether the given defined object function has
            already been evaluated with the provided arguments, as well as the cached evaluation 
            value.
            </summary>
            <param name="pred">The defined object function application.</param>
            <param name="existing">This flag is set to true if the defined object function is already
            in the process of (or has finished) being evaluated.</param>
            <returns>An evaluation record corresponding to the specified defined object function and 
            arguments.</returns>
        </member>
        <member name="M:PDDLParser.World.IReadOnlyClosedWorld.IsSet(PDDLParser.Exp.Formula.AtomicFormulaApplication)">
            <summary>
            Checks whether the specified described atomic formula holds in this world.
            </summary>
            <param name="formula">A described (and ground) atomic formula.</param>
            <returns>True or false.</returns>
        </member>
        <member name="M:PDDLParser.World.IReadOnlyClosedWorld.GetNumericFluent(PDDLParser.Exp.Formula.NumericFluentApplication)">
            <summary>
            Returns the value of the specified numeric fluent in this world.
            </summary>
            <param name="fluent">A described (and ground) numeric fluent.</param>
            <returns>Undefined, or the value of the numeric fluent.</returns>
        </member>
        <member name="M:PDDLParser.World.IReadOnlyClosedWorld.GetObjectFluent(PDDLParser.Exp.Formula.ObjectFluentApplication)">
            <summary>
            Returns the value of the specified object fluent in this world.
            </summary>
            <param name="fluent">A described (and ground) object fluent.</param>
            <returns>Undefined, or a constant representing the value of
            the object fluent.</returns>
        </member>
        <member name="M:PDDLParser.World.IReadOnlyClosedWorld.GetEvaluation(PDDLParser.Exp.Formula.TLPlan.DefinedPredicateApplication,System.Boolean@)">
            <summary>
            Returns an evaluation record which indicates whether the given defined predicate has
            already been evaluated with the provided arguments, as well as the cached evaluation 
            value.
            </summary>
            <param name="pred">The defined predicate application.</param>
            <param name="existing">This flag is set to true if the defined predicate is already in the
            process of (or has finished) being evaluated.</param>
            <returns>An evaluation record corresponding to the specified defined predicate and 
            arguments.</returns>
        </member>
        <member name="M:PDDLParser.World.IReadOnlyClosedWorld.GetEvaluation(PDDLParser.Exp.Formula.TLPlan.DefinedNumericFunctionApplication,System.Boolean@)">
            <summary>
            Returns an evaluation record which indicates whether the given defined numeric function has
            already been evaluated with the provided arguments, as well as the cached evaluation 
            value.
            </summary>
            <param name="pred">The defined numeric function application.</param>
            <param name="existing">This flag is set to true if the defined numeric function is already
            in the process of (or has finished) being evaluated.</param>
            <returns>An evaluation record corresponding to the specified defined numeric function and 
            arguments.</returns>
        </member>
        <member name="M:PDDLParser.World.IReadOnlyClosedWorld.GetEvaluation(PDDLParser.Exp.Formula.TLPlan.DefinedObjectFunctionApplication,System.Boolean@)">
            <summary>
            Returns an evaluation record which indicates whether the given defined object function has
            already been evaluated with the provided arguments, as well as the cached evaluation 
            value.
            </summary>
            <param name="pred">The defined object function application.</param>
            <param name="existing">This flag is set to true if the defined object function is already
            in the process of (or has finished) being evaluated.</param>
            <returns>An evaluation record corresponding to the specified defined object function and 
            arguments.</returns>
        </member>
        <member name="T:PDDLParser.World.IOpenWorld">
            <summary>
            Updatable open world supporting read and write operations.
            </summary>
        </member>
        <member name="M:PDDLParser.World.IOpenWorld.Set(PDDLParser.Exp.Formula.AtomicFormulaApplication)">
            <summary>
            Sets the specified atomic formula to true.
            </summary>
            <param name="formula">An atomic formula with constant arguments.</param>
        </member>
        <member name="M:PDDLParser.World.IOpenWorld.Unset(PDDLParser.Exp.Formula.AtomicFormulaApplication)">
            <summary>
            Sets the specified atomic formula to false.
            </summary>
            <param name="formula">A atomic formula with constant arguments.</param>
        </member>
        <member name="M:PDDLParser.World.IOpenWorld.SetNumericFluent(PDDLParser.Exp.Formula.NumericFluentApplication,System.Double)">
            <summary>
            Sets the new value of the specified numeric fluent.
            </summary>
            <param name="fluent">A numeric fluent with constant arguments.</param>
            <param name="value">The new value of the numeric fluent.</param>
        </member>
        <member name="M:PDDLParser.World.IOpenWorld.SetObjectFluent(PDDLParser.Exp.Formula.ObjectFluentApplication,PDDLParser.Exp.Term.Constant)">
            <summary>
            Sets the new value of the specified object fluent.
            </summary>
            <param name="fluent">A object fluent with constant arguments.</param>
            <param name="value">The constant representing the new value of the object fluent.
            </param>
        </member>
        <member name="M:PDDLParser.World.IOpenWorld.UndefineObjectFluent(PDDLParser.Exp.Formula.ObjectFluentApplication)">
            <summary>
            Sets the specified object fluent to undefined.
            </summary>
            <param name="fluent">A object fluent with constant arguments.</param>
        </member>
        <member name="T:PDDLParser.TLPlanAttribute">
            <summary>
            This attribute merely indicates that the given element is not present in a regular
            PDDL problem and has rather been added for TLPlan.
            </summary>
        </member>
        <member name="T:PDDLParser.Exp.Struct.LogicalValue">
            <summary>
            A LogicalValue represents a logical expression, a boolean value, or an undefined value.
            </summary>
        </member>
        <member name="F:PDDLParser.Exp.Struct.LogicalValue.True">
            <summary>
            LogicalValue true value.
            </summary>
        </member>
        <member name="F:PDDLParser.Exp.Struct.LogicalValue.False">
            <summary>
            LogicalValue false value.
            </summary>
        </member>
        <member name="F:PDDLParser.Exp.Struct.LogicalValue.Undefined">
            <summary>
            LogicalValue undefined value.
            </summary>
        </member>
        <member name="F:PDDLParser.Exp.Struct.LogicalValue.m_value">
            <summary>
            The Bool value associated with this LogicalValue.
            Note that this value is not defined if a corresponding logical expression is defined.
            </summary>
        </member>
        <member name="F:PDDLParser.Exp.Struct.LogicalValue.m_exp">
            <summary>
            The logical expression associated with this LogicalValue.
            </summary>
        </member>
        <member name="M:PDDLParser.Exp.Struct.LogicalValue.#ctor(System.Boolean)">
            <summary>
            Creates a new LogicalValue from a specified bool value.
            </summary>
            <param name="value">A bool value.</param>
        </member>
        <member name="M:PDDLParser.Exp.Struct.LogicalValue.#ctor(PDDLParser.Exp.Struct.Bool)">
            <summary>
            Creates a new LogicalValue from a specified Bool value.
            </summary>
            <param name="value">A Bool value.</param>
        </member>
        <member name="M:PDDLParser.Exp.Struct.LogicalValue.#ctor(PDDLParser.Exp.ILogicalExp)">
            <summary>
            Creates a new LogicalValue from a specified logical expression.
            </summary>
            <param name="exp">A logical expression.</param>
        </member>
        <member name="M:PDDLParser.Exp.Struct.LogicalValue.#ctor(PDDLParser.Exp.Struct.Bool,PDDLParser.Exp.ILogicalExp)">
            <summary>
            Creates a new LogicalValue from a specified result and logical expression.
            Note that this constructor should stay private.
            </summary>
            <param name="value">A Bool value.</param>
            <param name="exp">A logical expression.</param>
        </member>
        <member name="M:PDDLParser.Exp.Struct.LogicalValue.GetEquivalentExp">
            <summary>
            Returns a logical expression equivalent to this LogicalValue.
            If this LogicalValue corresponds to a Bool value, an equivalent constant expression
            is returned (false -> FalseExp, Undefined -> UndefinedExp, True -> TrueExp).
            </summary>
            <returns>A logical expression equivalent to this LogicalValue.</returns>
        </member>
        <member name="M:PDDLParser.Exp.Struct.LogicalValue.op_Equality(PDDLParser.Exp.Struct.LogicalValue,PDDLParser.Exp.Struct.LogicalValue)">
            <summary>
            Checks whether the two LogicalValue values are equivalent, 
            i.e. they both contain the same logical expression or their Bool values are equal.
            </summary>
            <param name="x">The first LogicalValue value.</param>
            <param name="y">The second LogicalValue value.</param>
            <returns>True if the two LogicalValue values are equivalent.</returns>
        </member>
        <member name="M:PDDLParser.Exp.Struct.LogicalValue.op_Inequality(PDDLParser.Exp.Struct.LogicalValue,PDDLParser.Exp.Struct.LogicalValue)">
            <summary>
            Checks whether the two LogicalValue values are different, 
            i.e. they do not contain the same logical expression or their Bool values are different.
            </summary>
            <param name="x">The first LogicalValue value.</param>
            <param name="y">The second LogicalValue value.</param>
            <returns>True if the two LogicalValue values are different.</returns>
        </member>
        <member name="M:PDDLParser.Exp.Struct.LogicalValue.op_OnesComplement(PDDLParser.Exp.Struct.LogicalValue)">
            <summary>
            Returns the negation of this LogicalValue.
            ¬False = True
            ¬Undefined = Undefined
            ¬True = True
            ¬Expression = (not (Expression))
            </summary>
            <param name="x">The LogicalValue to negate.</param>
            <returns>The negation of this LogicalValue.</returns>
        </member>
        <member name="M:PDDLParser.Exp.Struct.LogicalValue.op_LogicalNot(PDDLParser.Exp.Struct.LogicalValue)">
            <summary>
            False shortcircuit operator.
            A LogicalValue is false if its inner value is Bool.False
            </summary>
            <param name="x">The LogicalValue to test.</param>
            <returns>True if the LogicalValue value is Bool.False</returns>
        </member>
        <member name="M:PDDLParser.Exp.Struct.LogicalValue.op_False(PDDLParser.Exp.Struct.LogicalValue)">
            <summary>
            False shortcircuit operator.
            A LogicalValue is false if its inner value is Bool.False
            </summary>
            <param name="x">The LogicalValue to test.</param>
            <returns>True if the LogicalValue value is Bool.False</returns>
        </member>
        <member name="M:PDDLParser.Exp.Struct.LogicalValue.op_True(PDDLParser.Exp.Struct.LogicalValue)">
            <summary>
            True shortcircuit operator.
            A LogicalValue is true if its inner value is Bool.True
            </summary>
            <param name="x">The LogicalValue to test.</param>
            <returns>True if the LogicalValue value is Bool.True</returns>
        </member>
        <member name="M:PDDLParser.Exp.Struct.LogicalValue.op_BitwiseOr(PDDLParser.Exp.Struct.LogicalValue,PDDLParser.Exp.Struct.LogicalValue)">
            <summary>
            Returns the disjunction of two LogicalValues.
            Exp1 | Exp2 = (or Exp1 Exp2)
            Exp | False = Exp
            Exp | Undefined = (or Exp Undefined)
            Exp | True = True
            else the disjunction is computed using the two inner Bool values.
            </summary>
            <param name="x">The first LogicalValue.</param>
            <param name="y">The second LogicalValue</param>
            <returns>The disjunction of the two LogicalValue.</returns>
        </member>
        <member name="M:PDDLParser.Exp.Struct.LogicalValue.op_BitwiseAnd(PDDLParser.Exp.Struct.LogicalValue,PDDLParser.Exp.Struct.LogicalValue)">
            <summary>
            Returns the conjunction of two LogicalValues.
            Exp1 &amp; Exp2 = (and Exp1 Exp2)
            Exp &amp; False = False
            Exp &amp; Undefined = (and Exp Undefined)
            Exp &amp; True = Exp
            else the conjunction is computed using the two inner Bool values.
            </summary>
            <param name="x">The first LogicalValue.</param>
            <param name="y">The second LogicalValue</param>
            <returns>The conjunction of the two LogicalValue.</returns>
        </member>
        <member name="M:PDDLParser.Exp.Struct.LogicalValue.Equals(System.Object)">
            <summary>
            Returns true if this LogicalValue is equal to another object.
            </summary>
            <param name="obj">The other object to test for equality.</param>
            <returns>True if this LogicalValue is equal to the other object.</returns>
        </member>
        <member name="M:PDDLParser.Exp.Struct.LogicalValue.GetHashCode">
            <summary>
            Returns the hashcode of this LogicalValue.
            </summary>
            <returns>The hashcode of this LogicalValue.</returns>
        </member>
        <member name="M:PDDLParser.Exp.Struct.LogicalValue.ToString">
            <summary>
            Returns a string representation of this LogicalValue.
            </summary>
            <returns>A string representation of this LogicalValue.</returns>
        </member>
        <member name="P:PDDLParser.Exp.Struct.LogicalValue.Exp">
            <summary>
            Returns the logical expression stored in this LogicalValue.
            Note that this logical expression may be null.
            </summary>
        </member>
        <member name="P:PDDLParser.Exp.Struct.LogicalValue.Value">
            <summary>
            Returns the Bool value stored in this LogicalValue.
            This value should only be accessed if the expression is null.
            </summary>
        </member>
        <member name="T:PDDLParser.Exp.Struct.FuzzyConstantExp">
            <summary>
            A FuzzyConstantExp represents a constant which may be undefined or unknown.
            </summary>
        </member>
        <member name="F:PDDLParser.Exp.Struct.FuzzyConstantExp.Unknown">
            <summary>
            FuzzyConstantExp unknown value.
            </summary>
        </member>
        <member name="F:PDDLParser.Exp.Struct.FuzzyConstantExp.Undefined">
            <summary>
            FuzzyConstantExp undefined value.
            </summary>
        </member>
        <member name="F:PDDLParser.Exp.Struct.FuzzyConstantExp.m_value">
            <summary>
            The constant value of this FuzzyConstantExp.
            </summary>
        </member>
        <member name="F:PDDLParser.Exp.Struct.FuzzyConstantExp.m_status">
            <summary>
            The status of this FuzzyConstantExp.
            </summary>
        </member>
        <member name="M:PDDLParser.Exp.Struct.FuzzyConstantExp.#ctor(PDDLParser.Exp.Term.Constant)">
            <summary>
            Creates a new FuzzyConstantExp with the specified constant object.
            </summary>
            <param name="value">The new FuzzyConstantExp's constant object.</param>
        </member>
        <member name="M:PDDLParser.Exp.Struct.FuzzyConstantExp.#ctor(PDDLParser.Exp.Struct.ConstantExp)">
            <summary>
            Creates a new FuzzyConstantExp with the specified constant value.
            </summary>
            <param name="value">The new FuzzyConstantExp's constant value.</param>
        </member>
        <member name="M:PDDLParser.Exp.Struct.FuzzyConstantExp.#ctor(PDDLParser.Exp.Struct.FuzzyConstantExp.State)">
            <summary>
            Creates a new FuzzyConstantExp with the specified status.
            </summary>
            <param name="status">The new FuzzyConstantExp's status.</param>
        </member>
        <member name="M:PDDLParser.Exp.Struct.FuzzyConstantExp.FuzzyConstantExpToConstantExp(PDDLParser.Exp.Struct.FuzzyConstantExp)">
            <summary>
            Returns the ConstantExp value corresponding to the FuzzyConstantExp value.
            </summary>
            <param name="value">A FuzzyConstantExp value.</param>
            <returns>The ConstantExp value corresponding to the FuzzyConstantExp value.</returns>
        </member>
        <member name="M:PDDLParser.Exp.Struct.FuzzyConstantExp.ToConstantValue">
            <summary>
            Returns the corresponding ConstantExp value of this FuzzyConstantExp.
            Note that FuzzyConstantExp.Unknown cannot be converted to ConstantExp and thus throws 
            an UnknownEvaluationResultException.
            </summary>
            <returns>The corresponding ConstantExp value of this FuzzyConstantExp.</returns>
        </member>
        <member name="M:PDDLParser.Exp.Struct.FuzzyConstantExp.ConstantEquals(PDDLParser.Exp.Struct.FuzzyConstantExp,PDDLParser.Exp.Struct.FuzzyConstantExp)">
            <summary>
            Returns whether two fuzzy constant values are equal. 
            If one of them is undefined, this function returns undefined.
            Else if one of them is unknown, this function returns unknown.
            </summary>
            <param name="x">The first fuzzy constant value.</param>
            <param name="y">The second fuzzy constant value.</param>
            <returns>Whether two fuzzy constant values are equal.</returns>
        </member>
        <member name="M:PDDLParser.Exp.Struct.FuzzyConstantExp.Equals(System.Object)">
            <summary>
            Returns true if this FuzzyConstantExp is equal to another object.
            </summary>
            <param name="obj">The other object to test for equality.</param>
            <returns>True if this FuzzyConstantExp is equal to the other object.</returns>
        </member>
        <member name="M:PDDLParser.Exp.Struct.FuzzyConstantExp.GetHashCode">
            <summary>
            Returns the hashcode of this FuzzyConstantExp.
            </summary>
            <returns>The hashcode of this FuzzyConstantExp.</returns>
        </member>
        <member name="M:PDDLParser.Exp.Struct.FuzzyConstantExp.ToString">
            <summary>
            Returns a string representation of this FuzzyConstantExp.
            </summary>
            <returns>A string representation of this FuzzyConstantExp.</returns>
        </member>
        <member name="P:PDDLParser.Exp.Struct.FuzzyConstantExp.Status">
            <summary>
            Returns the status of this FuzzyConstantExp.
            </summary>
        </member>
        <member name="P:PDDLParser.Exp.Struct.FuzzyConstantExp.Value">
            <summary>
            Returns the inner constant value of this FuzzyConstantExp.
            The value should only be accessed if this FuzzyConstantExp is defined.
            </summary>
        </member>
        <member name="T:PDDLParser.Exp.Struct.FuzzyConstantExp.State">
            <summary>
            The internal status of this FuzzyConstantExp, which indicates whether it is defined,
            unknown, or undefined.
            </summary>
        </member>
        <member name="F:PDDLParser.Exp.Struct.FuzzyConstantExp.State.Defined">
            <summary>
            Indicates that this FuzzyConstantExp is defined, and thus its internal constant
            value can be accessed.
            </summary>
        </member>
        <member name="F:PDDLParser.Exp.Struct.FuzzyConstantExp.State.Unknown">
            <summary>
            Indicates that this FuzzyConstantExp is unknown.
            </summary>
        </member>
        <member name="F:PDDLParser.Exp.Struct.FuzzyConstantExp.State.Undefined">
            <summary>
            Indicates that this FuzzyConstantExp is undefined.
            </summary>
        </member>
        <member name="T:PDDLParser.Exp.Numeric.TLPlan.UnaryFloor">
            <summary>
            This class implements the floor function.
            This is not part of PDDL; it was rather added for TLPlan.
            </summary>
        </member>
        <member name="T:PDDLParser.Exp.Numeric.TLPlan.UnaryFunctionExp">
            <summary>
            Base class for unary arithmetic functions.
            </summary>
        </member>
        <member name="T:PDDLParser.Exp.Numeric.AbstractFunctionExp">
            <summary>
            Base class for arithmetic functions.
            </summary>
        </member>
        <member name="T:PDDLParser.Exp.Numeric.AbstractNumericExp">
            <summary>
            Base class for numeric expressions.
            </summary>
        </member>
        <member name="T:PDDLParser.Exp.AbstractExp">
            <summary>
            This abstract base class represents the common part of expressions.
            The IComparable interface denotes a total order relation between expressions.
            </summary>
        </member>
        <member name="T:PDDLParser.Exp.IExp">
            <summary>
            This interface is implemented by all expressions of the PDDL langage.
            </summary>
        </member>
        <member name="M:PDDLParser.Exp.IExp.Apply(PDDLParser.Exp.ParameterBindings)">
            <summary>
            Substitutes all occurrences of the variables that occur in this
            expression by their corresponding bindings.
            </summary>
            <param name="bindings">A set of variable bindings.</param>
            <returns>A substituted copy of this expression.</returns>
        </member>
        <member name="M:PDDLParser.Exp.IExp.Standardize">
            <summary>
            Standardizes all occurrences of the variables that occur in this
            expression. Remember that free variables are existentially quantified.
            </summary>
            <returns>A standardized copy of this expression.</returns>
        </member>
        <member name="M:PDDLParser.Exp.IExp.Standardize(System.Collections.Generic.IDictionary{System.String,System.String})">
            <summary>
            Standardizes all occurrences of the variables that occur in this
            expression. The IDictionary argument is used to store the variable already
            standardized. Remember that free variables are existentially quantified.
            </summary>
            <param name="images">The object that maps old variable images to the standardize
            image.</param>
            <returns>A standardized copy of this expression.</returns>
        </member>
        <member name="M:PDDLParser.Exp.IExp.IsGround">
            <summary>
            Returns true if the expression is ground, i.e. it does not contain any variables.
            </summary>
            <returns>Whether the expression is ground.</returns>
        </member>
        <member name="M:PDDLParser.Exp.IExp.GetFreeVariables">
            <summary>
            Returns the free variables in this expression.
            </summary>
            <returns>The free variables in this expression.</returns>
        </member>
        <member name="M:PDDLParser.Exp.IExp.ToTypedString">
            <summary>
            Returns a typed string representation of this expression.
            </summary>
            <returns>A typed string representation of this expression.</returns>
        </member>
        <member name="M:PDDLParser.Exp.AbstractExp.Apply(PDDLParser.Exp.ParameterBindings)">
            <summary>
            Substitutes all occurrences of the variables that occur in this
            expression by their corresponding bindings.
            The base implementation is to simply clone the object.
            </summary>
            <param name="bindings">The bindings.</param>
            <returns>A substituted copy of this expression.</returns>
        </member>
        <member name="M:PDDLParser.Exp.AbstractExp.Standardize">
            <summary>
            Standardizes all occurrences of the variables that occur in this
            expression. Remember that free variables are existentially quantified.
            </summary>
            <returns>A standardized copy of this expression.</returns>
        </member>
        <member name="M:PDDLParser.Exp.AbstractExp.Standardize(System.Collections.Generic.IDictionary{System.String,System.String})">
            <summary>
            Standardizes all occurrences of the variables that occur in this
            expression. The IDictionary argument is used to store the variable already
            standardized. Remember that free variables are existentially quantified.
            The base implementation is to simply clone the object.
            </summary>
            <param name="images">The object that maps old variable images to the standardize
            image.</param>
            <returns>A standardized copy of this expression.</returns>
        </member>
        <member name="M:PDDLParser.Exp.AbstractExp.IsGround">
            <summary>
            Returns true if the expression is ground, i.e. it does not contain any variables.
            </summary>
            <returns>Whether the expression is ground.</returns>
        </member>
        <member name="M:PDDLParser.Exp.AbstractExp.GetFreeVariables">
            <summary>
            Returns the free variables in this expression.
            </summary>
            <returns>The free variables in this expression.</returns>
        </member>
        <member name="M:PDDLParser.Exp.AbstractExp.Clone">
            <summary>
            Returns a clone of this expression.
            The default implementation simply returns a memberwise clone.
            </summary>
            <returns>A clone of this expression.</returns>
        </member>
        <member name="M:PDDLParser.Exp.AbstractExp.Equals(System.Object)">
            <summary>
            Returns true if this expression is equal to a specified object.
            </summary>
            <param name="obj">Object to test for equality.</param>
            <returns>True if this expression is equal to the specified objet.</returns>
        </member>
        <member name="M:PDDLParser.Exp.AbstractExp.GetHashCode">
            <summary>
            Returns the hash code of this expression.
            </summary>
            <returns>The hash code of this expression.</returns>
        </member>
        <member name="M:PDDLParser.Exp.AbstractExp.ToTypedString">
            <summary>
            Returns a typed string of this expression.
            </summary>
            <returns>A typed string representation of this expression.</returns>
        </member>
        <member name="M:PDDLParser.Exp.AbstractExp.ToString">
            <summary>
            Returns a string representation of this expression.
            </summary>
            <returns>A string representation of this expression.</returns>
        </member>
        <member name="M:PDDLParser.Exp.AbstractExp.CompareTo(PDDLParser.Exp.IExp)">
            <summary>
            Compares this abstract expression with another expression.
            </summary>
            <param name="other">The other expression to compare this abstract expression to.</param>
            <returns>An integer representing the total order relation between the two expressions.</returns>
        </member>
        <member name="T:PDDLParser.Exp.INumericExp">
            <summary>
            A numeric expression yields a numeric value when evaluated.
            Evaluation in a closed world returns undefined or the resulting numeric value.
            Evaluation in an open world returns undefined, unknown, or the resulting numeric value.
            </summary>
        </member>
        <member name="T:PDDLParser.Exp.IEvaluableExp">
            <summary>
            An evaluable expression is an expression which yields a (non-boolean) value when evaluated.
            </summary>
        </member>
        <member name="M:PDDLParser.Exp.INumericExp.Evaluate(PDDLParser.World.IReadOnlyOpenWorld,PDDLParser.Exp.LocalBindings)">
            <summary>
            Evaluates this numeric expression in the specified open world.
            The bindings should not be modified by this call.
            </summary>
            <param name="world">The evaluation world.</param>
            <param name="bindings">A set of variable bindings.</param>
            <returns>Undefined, unknown, or the resulting numeric value.</returns>
            <exception cref="T:PDDLParser.Exception.BindingException">A BindingException is thrown if an attempt
            is made to evaluate an unbound variable.</exception>
            <exception cref="T:PDDLParser.Exception.NumericException">A NumericException is thrown if an 
            illegal operation is performed (like a division by zero).</exception>
        </member>
        <member name="M:PDDLParser.Exp.INumericExp.Simplify(PDDLParser.World.IReadOnlyOpenWorld,PDDLParser.Exp.LocalBindings)">
            <summary>
            Simplifies this numeric expression by evaluating its known expression parts.
            The bindings should not be modified by this call.
            The resulting expression should not contain any unbound variables, since
            they are substituted according to the bindings supplied.
            </summary>
            <param name="world">The evaluation world.</param>
            <param name="bindings">A set of variable bindings.</param>
            <returns>Undefined, a numeric value, or the simplified expression.</returns>
            <exception cref="T:PDDLParser.Exception.BindingException">A BindingException is thrown if an attempt
            is made to evaluate an unbound variable.</exception>
            <exception cref="T:PDDLParser.Exception.NumericException">A NumericException is thrown if an 
            illegal operation is performed (like a division by zero).</exception>
        </member>
        <member name="M:PDDLParser.Exp.INumericExp.Evaluate(PDDLParser.World.IReadOnlyClosedWorld,PDDLParser.Exp.LocalBindings)">
            <summary>
            Evaluates this numeric expression in the specified closed world.
            The bindings should not be modified by this call.
            </summary>
            <param name="world">The evaluation world.</param>
            <param name="bindings">A set of variable bindings.</param>
            <returns>Undefined, or the resulting numeric value.</returns>
            <exception cref="T:PDDLParser.Exception.BindingException">A BindingException is thrown if an attempt
            is made to evaluate an unbound variable.</exception>
            <exception cref="T:PDDLParser.Exception.NumericException">A NumericException is thrown if an 
            illegal operation is performed (like a division by zero).</exception>
        </member>
        <member name="M:PDDLParser.Exp.Numeric.AbstractNumericExp.#ctor">
            <summary>
            Creates a new numeric expression.
            </summary>
        </member>
        <member name="M:PDDLParser.Exp.Numeric.AbstractNumericExp.Evaluate(PDDLParser.World.IReadOnlyOpenWorld,PDDLParser.Exp.LocalBindings)">
            <summary>
            Evaluates this numeric expression in the specified open world.
            The bindings should not be modified by this call.
            </summary>
            <param name="world">The evaluation world.</param>
            <param name="bindings">A set of variable bindings.</param>
            <returns>Undefined, unknown, or the resulting numeric value.</returns>
            <exception cref="T:PDDLParser.Exception.BindingException">A BindingException is thrown if an attempt
            is made to evaluate an unbound variable.</exception>
            <exception cref="T:PDDLParser.Exception.NumericException">A NumericException is thrown if an 
            illegal operation is performed (like a division by zero).</exception>
        </member>
        <member name="M:PDDLParser.Exp.Numeric.AbstractNumericExp.Simplify(PDDLParser.World.IReadOnlyOpenWorld,PDDLParser.Exp.LocalBindings)">
            <summary>
            Simplifies this numeric expression by evaluating its known expression parts.
            The bindings should not be modified by this call.
            The resulting expression should not contain any unbound variables, since
            they are substituted according to the bindings supplied.
            </summary>
            <param name="world">The evaluation world.</param>
            <param name="bindings">A set of variable bindings.</param>
            <returns>Undefined, a numeric value, or the simplified expression.</returns>
            <exception cref="T:PDDLParser.Exception.BindingException">A BindingException is thrown if an attempt
            is made to evaluate an unbound variable.</exception>
            <exception cref="T:PDDLParser.Exception.NumericException">A NumericException is thrown if an 
            illegal operation is performed (like a division by zero).</exception>
        </member>
        <member name="M:PDDLParser.Exp.Numeric.AbstractNumericExp.Evaluate(PDDLParser.World.IReadOnlyClosedWorld,PDDLParser.Exp.LocalBindings)">
            <summary>
            Evaluates this numeric expression in the specified closed world.
            The bindings should not be modified by this call.
            </summary>
            <param name="world">The evaluation world.</param>
            <param name="bindings">A set of variable bindings.</param>
            <returns>Undefined, or the resulting numeric value.</returns>
            <exception cref="T:PDDLParser.Exception.BindingException">A BindingException is thrown if an attempt
            is made to evaluate an unbound variable.</exception>
            <exception cref="T:PDDLParser.Exception.NumericException">A NumericException is thrown if an 
            illegal operation is performed (like a division by zero).</exception>
        </member>
        <member name="F:PDDLParser.Exp.Numeric.AbstractFunctionExp.m_arguments">
            <summary>
            The arguments of this arithmetic function.
            </summary>
        </member>
        <member name="F:PDDLParser.Exp.Numeric.AbstractFunctionExp.m_image">
            <summary>
            The image of the function.
            </summary>
        </member>
        <member name="M:PDDLParser.Exp.Numeric.AbstractFunctionExp.#ctor(System.String,System.Collections.Generic.List{PDDLParser.Exp.INumericExp})">
            <summary>
            Creates a new arithmetic function with the specified arguments.
            </summary>
            <param name="image">The image of the arithmetic function.</param>
            <param name="arguments">The arguments of the new arithmetic function.</param>
        </member>
        <member name="M:PDDLParser.Exp.Numeric.AbstractFunctionExp.Calculate(System.Double[])">
            <summary>
            Calculates the result of this arithmetic function called with the specified arguments.
            </summary>
            <param name="args">The arguments to call the function with.</param>
            <returns>The result of the arithmetic function.</returns>
        </member>
        <member name="M:PDDLParser.Exp.Numeric.AbstractFunctionExp.Evaluate(PDDLParser.World.IReadOnlyOpenWorld,PDDLParser.Exp.LocalBindings)">
            <summary>
            Evaluates this numeric expression in the specified open world.
            The value of an arithmetic function is obtained by recursively evaluating its arguments
            and then applying the function.
            </summary>
            <param name="world">The evaluation world.</param>
            <param name="bindings">A set of variable bindings.</param>
            <returns>Undefined, unknown, or the resulting numeric value.</returns>
            <exception cref="T:PDDLParser.Exception.BindingException">A BindingException is thrown if an attempt
            is made to evaluate an unbound variable.</exception>
            <exception cref="T:PDDLParser.Exception.NumericException">A NumericException is thrown if an 
            illegal operation is performed (like a division by zero).</exception>
        </member>
        <member name="M:PDDLParser.Exp.Numeric.AbstractFunctionExp.Simplify(PDDLParser.World.IReadOnlyOpenWorld,PDDLParser.Exp.LocalBindings)">
            <summary>
            Simplifies this numeric expression by evaluating its known expression parts.
            The bindings should not be modified by this call.
            </summary>
            <param name="world">The evaluation world.</param>
            <param name="bindings">A set of variable bindings.</param>
            <returns>Undefined, a numeric value, or the simplified expression.</returns>
            <exception cref="T:PDDLParser.Exception.BindingException">A BindingException is thrown if an attempt
            is made to evaluate an unbound variable.</exception>
            <exception cref="T:PDDLParser.Exception.NumericException">A NumericException is thrown if an 
            illegal operation is performed (like a division by zero).</exception>
        </member>
        <member name="M:PDDLParser.Exp.Numeric.AbstractFunctionExp.Evaluate(PDDLParser.World.IReadOnlyClosedWorld,PDDLParser.Exp.LocalBindings)">
            <summary>
            Evaluates this numeric expression in the specified closed world.
            The value of an arithmetic function is obtained by recursively evaluating its arguments
            and then applying the function.
            </summary>
            <param name="world">The evaluation world.</param>
            <param name="bindings">A set of variable bindings.</param>
            <returns>Undefined, or the resulting numeric value.</returns>
            <exception cref="T:PDDLParser.Exception.BindingException">A BindingException is thrown if an attempt
            is made to evaluate an unbound variable.</exception>
            <exception cref="T:PDDLParser.Exception.NumericException">A NumericException is thrown if an 
            illegal operation is performed (like a division by zero).</exception>
        </member>
        <member name="M:PDDLParser.Exp.Numeric.AbstractFunctionExp.Apply(PDDLParser.Exp.ParameterBindings)">
            <summary>
            Substitutes all occurrences of the variables that occur in this
            expression by their corresponding bindings.
            </summary>
            <param name="bindings">A set of variable bindings.</param>
            <returns>A substituted copy of this expression.</returns>
        </member>
        <member name="M:PDDLParser.Exp.Numeric.AbstractFunctionExp.Standardize(System.Collections.Generic.IDictionary{System.String,System.String})">
            <summary>
            Standardizes all occurrences of the variables that occur in this
            expression. Remember that free variables are existentially quantified.
            </summary>
            <returns>A standardized copy of this expression.</returns>
        </member>
        <member name="M:PDDLParser.Exp.Numeric.AbstractFunctionExp.IsGround">
            <summary>
            Returns true if the expression is ground, i.e. it does not contain any variables.
            An arithmetic function is ground if all its arguments are ground.
            </summary>
            <returns>Whether the expression is ground.</returns>
        </member>
        <member name="M:PDDLParser.Exp.Numeric.AbstractFunctionExp.GetFreeVariables">
            <summary>
            Returns the free variables in this expression.
            </summary>
            <returns>The free variables in this expression.</returns>
        </member>
        <member name="M:PDDLParser.Exp.Numeric.AbstractFunctionExp.Clone">
            <summary>
            Returs a clone of this arithmetic function.
            </summary>
            <returns>A clone of this arithmetic function..</returns>
        </member>
        <member name="M:PDDLParser.Exp.Numeric.AbstractFunctionExp.Equals(System.Object)">
            <summary>
            Returns whether this arithmetic function is equal to another object.
            </summary>
            <param name="obj">The other object to test for equality.</param>
            <returns>True if this arithmetic function is equal to the other object.</returns>
        </member>
        <member name="M:PDDLParser.Exp.Numeric.AbstractFunctionExp.GetHashCode">
            <summary>
            Returns the hash code of this arithmetic function.
            </summary>
            <returns>The hash code of this arithmetic function.</returns>
        </member>
        <member name="M:PDDLParser.Exp.Numeric.AbstractFunctionExp.ToString">
            <summary>
            Returns a string representation of this arithmetic function.
            </summary>
            <returns>A string representation of this arithmetic function.</returns>
        </member>
        <member name="M:PDDLParser.Exp.Numeric.AbstractFunctionExp.ToTypedString">
            <summary>
            Returns a typed string representation of this arithmetic function.
            </summary>
            <returns>A typed string representation of this arithmetic function.</returns>
        </member>
        <member name="M:PDDLParser.Exp.Numeric.AbstractFunctionExp.CompareTo(PDDLParser.Exp.IExp)">
            <summary>
            Compares this arithmetic function with another expression
            </summary>
            <param name="other">The expression to compare this arithmetic function  to.</param>
            <returns>An integer representing the total order relation between the two expressions.
            </returns>
        </member>
        <member name="M:PDDLParser.Exp.Numeric.TLPlan.UnaryFunctionExp.#ctor(System.String,PDDLParser.Exp.INumericExp)">
            <summary>
            Creates a new unary arithmetic function with the specified argument.
            </summary>
            <param name="image">The image of the arithmetic function.</param>
            <param name="arg">The argument of the new arithmetic function.</param>
        </member>
        <member name="M:PDDLParser.Exp.Numeric.TLPlan.UnaryFunctionExp.Calculate(System.Double)">
            <summary>
            Calculates the result of this arithmetic function called with the specified argument.
            </summary>
            <param name="arg">The argument.</param>
            <returns>The result of the arithmetic function.</returns>
        </member>
        <member name="M:PDDLParser.Exp.Numeric.TLPlan.UnaryFunctionExp.Calculate(System.Double[])">
            <summary>
            Calculates the result of this arithmetic function called with the specified arguments.
            </summary>
            <param name="args">The arguments to call the function with.</param>
            <returns>The result of the arithmetic function.</returns>
        </member>
        <member name="M:PDDLParser.Exp.Numeric.TLPlan.UnaryFloor.#ctor(PDDLParser.Exp.INumericExp)">
            <summary>
            Creates a new floor function with the specified argument.
            </summary>
            <param name="arg">The argument of the new floor function.</param>
        </member>
        <member name="M:PDDLParser.Exp.Numeric.TLPlan.UnaryFloor.Calculate(System.Double)">
            <summary>
            Calculates the largest integer less than or equal the argument.
            </summary>
            <param name="arg">The number.</param>
            <returns>The largest integer less than or equal the argument.</returns>
        </member>
        <member name="T:PDDLParser.Exp.Metric.MetricExp">
            <summary>
            Represents the optimization expression used in metric specification of the PDDL language.
            </summary>
            <remarks>
            It has arbitrarily been decided that all metrics will return values that need to be minimized.
            </remarks>
        </member>
        <member name="F:PDDLParser.Exp.Metric.MetricExp.m_exp">
            <summary>
            The expression to optimize.
            </summary>
        </member>
        <member name="F:PDDLParser.Exp.Metric.MetricExp.m_unnamedPreferences">
            <summary>
            The numeric expression representing all unnamed preferences.
            </summary>
        </member>
        <member name="M:PDDLParser.Exp.Metric.MetricExp.#ctor(PDDLParser.Exp.INumericExp,PDDLParser.Exp.INumericExp)">
            <summary>
            Creates a new metric expression.
            </summary>
            <param name="exp">The expression to optimize.</param>
            <param name="unnamedPrefs">The unnamed preferences.</param>
        </member>
        <member name="M:PDDLParser.Exp.Metric.MetricExp.EvaluateMinimizedMetric(PDDLParser.World.IReadOnlyOpenWorld,PDDLParser.Exp.LocalBindings)">
            <summary>
            Returns a minimized version of the metric evaluated on a given world.
            </summary>
            <param name="world">The evaluation world.</param>
            <param name="bindings">A set of variable bindings.</param>
            <returns>The minimized version of the metric.</returns>
        </member>
        <member name="M:PDDLParser.Exp.Metric.MetricExp.EvaluateMinimizedMetric(PDDLParser.World.IReadOnlyClosedWorld,PDDLParser.Exp.LocalBindings)">
            <summary>
            Returns a minimized version of the metric evaluated on a given world.
            </summary>
            <param name="world">The evaluation world.</param>
            <param name="bindings">A set of variable bindings.</param>
            <returns>The minimized version of the metric.</returns>
        </member>
        <member name="M:PDDLParser.Exp.Metric.MetricExp.Apply(PDDLParser.Exp.ParameterBindings)">
            <summary>
            Substitutes all occurrences of the variables that occur in this
            expression by their corresponding bindings.
            </summary>
            <param name="bindings">The bindings.</param>
            <returns>A substituted copy of this expression.</returns>
        </member>
        <member name="M:PDDLParser.Exp.Metric.MetricExp.Standardize(System.Collections.Generic.IDictionary{System.String,System.String})">
            <summary>
            Standardizes all occurrences of the variables that occur in this
            expression. The IDictionary argument is used to store the variable already
            standardized. Remember that free variables are existentially quantified.
            </summary>
            <param name="images">The object that maps old variable images to the standardize
            image.</param>
            <returns>A standardized copy of this expression.</returns>
        </member>
        <member name="M:PDDLParser.Exp.Metric.MetricExp.GetFreeVariables">
            <summary>
            Returns the free variables in this expression.
            </summary>
            <returns>The free variables in this expression.</returns>
        </member>
        <member name="M:PDDLParser.Exp.Metric.MetricExp.IsGround">
            <summary>
            Returns true if the expression is ground, i.e. it does not contain any variables.
            </summary>
            <returns>Whether the expression is ground.</returns>
        </member>
        <member name="M:PDDLParser.Exp.Metric.MetricExp.Equals(System.Object)">
            <summary>
            Returns true if this expression is equal to a specified object.
            </summary>
            <param name="obj">Object to test for equality.</param>
            <returns>True if this expression is equal to the specified objet.</returns>
        </member>
        <member name="M:PDDLParser.Exp.Metric.MetricExp.GetHashCode">
            <summary>
            Returns the hash code of this expression.
            </summary>
            <returns>The hash code of this expression.</returns>
        </member>
        <member name="M:PDDLParser.Exp.Metric.MetricExp.ToString">
            <summary>
            Returns a string of this expression.
            </summary>
            <returns>A string representation of this expression.</returns>
        </member>
        <member name="M:PDDLParser.Exp.Metric.MetricExp.ToTypedString">
            <summary>
            Returns a typed string of this expression.
            </summary>
            <returns>A typed string representation of this expression.</returns>
        </member>
        <member name="M:PDDLParser.Exp.Metric.MetricExp.Evaluate(PDDLParser.World.IReadOnlyClosedWorld,PDDLParser.Exp.LocalBindings)">
            <summary>
            Evaluates the metric in the specified closed world.
            The bindings should not be modified by this call.
            </summary>
            <remarks>
            Unnamed preferences are counted in the metric.
            Also, it has arbitrarily been decided that all metrics will return values that need to be minimized.
            </remarks>
            <param name="world">The evaluation world.</param>
            <param name="bindings">A set of variable bindings.</param>
            <returns>Undefined, or the resulting metric value to be minimized.</returns>
            <exception cref="T:PDDLParser.Exception.BindingException">A BindingException is thrown if an attempt
            is made to evaluate an unbound variable.</exception>
            <exception cref="T:PDDLParser.Exception.NumericException">A NumericException is thrown if an 
            illegal operation is performed (like a division by zero).</exception>
        </member>
        <member name="M:PDDLParser.Exp.Metric.MetricExp.Evaluate(PDDLParser.World.IReadOnlyOpenWorld,PDDLParser.Exp.LocalBindings)">
            <summary>
            Evaluates the metric in the specified open world.
            The bindings should not be modified by this call.
            </summary>
            <remarks>
            Unnamed preferences are counted in the metric.
            Also, it has arbitrarily been decided that all metrics will return values that need to be minimized.
            </remarks>
            <param name="world">The evaluation world.</param>
            <param name="bindings">A set of variable bindings.</param>
            <returns>Undefined, or the resulting metric value to be minimized.</returns>
            <exception cref="T:PDDLParser.Exception.BindingException">A BindingException is thrown if an attempt
            is made to evaluate an unbound variable.</exception>
            <exception cref="T:PDDLParser.Exception.NumericException">A NumericException is thrown if an 
            illegal operation is performed (like a division by zero).</exception>
        </member>
        <member name="M:PDDLParser.Exp.Metric.MetricExp.Simplify(PDDLParser.World.IReadOnlyOpenWorld,PDDLParser.Exp.LocalBindings)">
            <summary>
            Simplifies this metric by evaluating its known expression parts.
            The bindings should not be modified by this call.
            The resulting metric should not contain any unbound variables, since
            they are substituted according to the bindings supplied.
            </summary>
            <param name="world">The evaluation world.</param>
            <param name="bindings">A set of variable bindings.</param>
            <returns>Undefined, a metric value, or the simplified metric.</returns>
            <exception cref="T:PDDLParser.Exception.BindingException">A BindingException is thrown if an attempt
            is made to evaluate an unbound variable.</exception>
            <exception cref="T:PDDLParser.Exception.NumericException">A NumericException is thrown if an 
            illegal operation is performed (like a division by zero).</exception>
        </member>
        <member name="P:PDDLParser.Exp.Metric.MetricExp.UnnamedPreferences">
            <summary>
            Gets the numeric expression representing all unnamed preferences.
            </summary>
        </member>
        <member name="P:PDDLParser.Exp.Metric.MetricExp.TypeName">
            <summary>
            Gets a string representatin of the type of optimization required.
            </summary>
        </member>
        <member name="P:PDDLParser.Exp.Metric.MetricExp.Exp">
            <summary>
            Gets the expression to optimize.
            </summary>
        </member>
        <member name="T:PDDLParser.Exp.Logical.TLPlan.GoalModalityExp">
            <summary>
            A goal modality determines if the goal expression implies another expression,
            that is, if for all worlds w (goal |= w) -> (exp |= w).
            This is not part of PDDL; it was rather added for TLPlan.
            </summary>
        </member>
        <member name="T:PDDLParser.Exp.Logical.AbstractLogicalExp">
            <summary>
            Base class for logical expressions.
            </summary>
        </member>
        <member name="T:PDDLParser.Exp.Constraint.AbstractConstraintExp">
            <summary>
            Represents the common part of all constraint expressions.
            </summary>
        </member>
        <member name="T:PDDLParser.Exp.IConstraintExp">
            <summary>
            A constraint expression is an expression which imposes restrictions on the trajectory
            (sequence of worlds) followed to reach a certain goal world.
            </summary>
        </member>
        <member name="M:PDDLParser.Exp.IConstraintExp.Progress(PDDLParser.World.IReadOnlyDurativeClosedWorld,PDDLParser.Exp.LocalBindings)">
            <summary>
            Evaluates the progression of this constraint expression in the next worlds.
            This function returns false if this constraint expression is not satisfied 
            in the given world;
            it returns true if the progression is always satisfied in the next worlds;
            else it returns the progressed expression.
            </summary>
            <param name="world">The current world.</param>
            <param name="bindings">A set of variable bindings.</param>
            <returns>True, false, undefined, or a progressed expression.</returns>
            <exception cref="T:PDDLParser.Exception.BindingException">A BindingException is thrown if an attempt
            is made to evaluate an unbound variable.</exception>
        </member>
        <member name="M:PDDLParser.Exp.IConstraintExp.EvaluateIdle(PDDLParser.World.IReadOnlyDurativeClosedWorld,PDDLParser.Exp.LocalBindings)">
            <summary>
            Evaluates this constraint expression in an idle world, i.e. a world which
            won't be modified by further updates.
            </summary>
            <param name="idleWorld">The (idle) evaluation world.</param>
            <param name="bindings">A set of variable bindings.</param>
            <returns>True, false, or undefined.</returns>
            <exception cref="T:PDDLParser.Exception.BindingException">A BindingException is thrown if an attempt
            is made to evaluate an unbound variable.</exception>
        </member>
        <member name="M:PDDLParser.Exp.Constraint.AbstractConstraintExp.#ctor">
            <summary>
            Creates a new constraint expression.
            </summary>
        </member>
        <member name="M:PDDLParser.Exp.Constraint.AbstractConstraintExp.Progress(PDDLParser.World.IReadOnlyDurativeClosedWorld,PDDLParser.Exp.LocalBindings)">
            <summary>
            Evaluates the progression of this constraint expression in the next worlds.
            This function returns false if this constraint expression is not satisfied 
            in the given world;
            it returns true if the progression is always satisfied in the next worlds;
            else it returns the progressed expression.
            </summary>
            <param name="world">The current world.</param>
            <param name="bindings">A set of variable bindings.</param>
            <returns>True, false, undefined, or a progressed expression.</returns>
            <exception cref="T:PDDLParser.Exception.BindingException">A BindingException is thrown if an attempt
            is made to evaluate an unbound variable.</exception>
        </member>
        <member name="M:PDDLParser.Exp.Constraint.AbstractConstraintExp.EvaluateIdle(PDDLParser.World.IReadOnlyDurativeClosedWorld,PDDLParser.Exp.LocalBindings)">
            <summary>
            Evaluates this constraint expression in an idle world, i.e. a world which
            won't be modified by further updates.
            </summary>
            <param name="idleWorld">The (idle) evaluation world.</param>
            <param name="bindings">A set of variable bindings.</param>
            <returns>True, false, or undefined.</returns>
            <exception cref="T:PDDLParser.Exception.BindingException">A BindingException is thrown if an attempt
            is made to evaluate an unbound variable.</exception>
        </member>
        <member name="T:PDDLParser.Exp.ILogicalExp">
            <summary>
            A logical expression yields a boolean value when evaluated.
            Evaluation in a closed world returns true, false, or undefined.
            Evaluation in an open world returns true, false, undefined, or unknown.
            </summary>
        </member>
        <member name="M:PDDLParser.Exp.ILogicalExp.Evaluate(PDDLParser.World.IReadOnlyOpenWorld,PDDLParser.Exp.LocalBindings)">
            <summary>
            Evaluates this logical expression in the specified open world.
            The bindings should not be modified by this call.
            </summary>
            <param name="world">The evaluation world.</param>
            <param name="bindings">A set of variable bindings.</param>
            <returns>True, false, undefined, or unknown.</returns>
            <exception cref="T:PDDLParser.Exception.BindingException">A BindingException is thrown if an attempt
            is made to evaluate an unbound variable.</exception>
        </member>
        <member name="M:PDDLParser.Exp.ILogicalExp.EvaluateWithImmediateShortCircuit(PDDLParser.World.IReadOnlyOpenWorld,PDDLParser.Exp.LocalBindings)">
            <summary>
            Evaluates this logical expression in the specified open world.
            The bindings should not be modified by this call.
            In addition to False, Undefined and Unknown also shortcircuit conjunctions.
            In addition to True, Unknown also shortcircuits disjunctions.
            This function is used to evaluate defined formulas' body as is done in the
            original TLPlan.
            </summary>
            <param name="world">The evaluation world.</param>
            <param name="bindings">A set of variable bindings.</param>
            <returns>True, false, undefined, or unknown.</returns>
            <exception cref="T:PDDLParser.Exception.BindingException">A BindingException is thrown if an attempt
            is made to evaluate an unbound variable.</exception>
        </member>
        <member name="M:PDDLParser.Exp.ILogicalExp.Simplify(PDDLParser.World.IReadOnlyOpenWorld,PDDLParser.Exp.LocalBindings)">
            <summary>
            Simplifies this logical expression by evaluating its known expression parts.
            The bindings should not be modified by this call.
            The resulting expression should not contain any unbound variables, since
            they are substituted according to the bindings supplied.
            </summary>
            <param name="world">The evaluation world.</param>
            <param name="bindings">A set of variable bindings.</param>
            <returns>True, false, undefined, or the simplified expression.</returns>
            <exception cref="T:PDDLParser.Exception.BindingException">A BindingException is thrown if an attempt
            is made to evaluate an unbound variable.</exception>
        </member>
        <member name="M:PDDLParser.Exp.ILogicalExp.Evaluate(PDDLParser.World.IReadOnlyClosedWorld,PDDLParser.Exp.LocalBindings)">
            <summary>
            Evaluates this logical expression in the specified closed world.
            The bindings should not be modified by this call.
            </summary>
            <param name="world">The evaluation world.</param>
            <param name="bindings">A set of variable bindings.</param>
            <returns>True, false, or undefined.</returns>
            <exception cref="T:PDDLParser.Exception.BindingException">A BindingException is thrown if an attempt
            is made to evaluate an unbound variable.</exception>
        </member>
        <member name="M:PDDLParser.Exp.ILogicalExp.EvaluateWithImmediateShortCircuit(PDDLParser.World.IReadOnlyClosedWorld,PDDLParser.Exp.LocalBindings)">
            <summary>
            Evaluates this logical expression in the specified closed world.
            The bindings should not be modified by this call.
            In addition to False, Undefined also shortcircuit conjunctions.
            This function is used to evaluate defined formulas' body as is done in the
            original TLPlan.
            </summary>
            <param name="world">The evaluation world.</param>
            <param name="bindings">A set of variable bindings.</param>
            <returns>True, false, or undefined.</returns>
            <exception cref="T:PDDLParser.Exception.BindingException">A BindingException is thrown if an attempt
            is made to evaluate an unbound variable.</exception>
        </member>
        <member name="M:PDDLParser.Exp.ILogicalExp.EnumerateAllSatisfyingWorlds">
            <summary>
            Enumerates all the worlds within which this logical expression evaluates to true.
            This method is used to support the goal modality expressions.
            </summary>
            <returns>All the worlds satisfying this logical expression.</returns>
        </member>
        <member name="M:PDDLParser.Exp.Logical.AbstractLogicalExp.Evaluate(PDDLParser.World.IReadOnlyOpenWorld,PDDLParser.Exp.LocalBindings)">
            <summary>
            Evaluates this logical expression in the specified open world.
            The bindings should not be modified by this call.
            </summary>
            <param name="world">The evaluation world.</param>
            <param name="bindings">A set of variable bindings.</param>
            <returns>True, false, undefined, or unknown.</returns>
            <exception cref="T:PDDLParser.Exception.BindingException">A BindingException is thrown if an attempt
            is made to evaluate an unbound variable.</exception>
        </member>
        <member name="M:PDDLParser.Exp.Logical.AbstractLogicalExp.EvaluateWithImmediateShortCircuit(PDDLParser.World.IReadOnlyOpenWorld,PDDLParser.Exp.LocalBindings)">
            <summary>
            Evaluates this logical expression in the specified open world.
            The bindings should not be modified by this call.
            In addition to False, Undefined and Unknown also shortcircuit conjunctions.
            In addition to True, Unknown also shortcircuits disjunctions.
            This function is used to evaluate defined formulas' body as is done in the
            original TLPlan.
            </summary>
            <param name="world">The evaluation world.</param>
            <param name="bindings">A set of variable bindings.</param>
            <returns>True, false, undefined, or unknown.</returns>
            <exception cref="T:PDDLParser.Exception.BindingException">A BindingException is thrown if an attempt
            is made to evaluate an unbound variable.</exception>
        </member>
        <member name="M:PDDLParser.Exp.Logical.AbstractLogicalExp.Simplify(PDDLParser.World.IReadOnlyOpenWorld,PDDLParser.Exp.LocalBindings)">
            <summary>
            Simplifies this logical expression by evaluating its known expression parts.
            The bindings should not be modified by this call.
            The resulting expression should not contain any unbound variables, since
            they are substituted according to the bindings supplied.
            </summary>
            <param name="world">The evaluation world.</param>
            <param name="bindings">A set of variable bindings.</param>
            <returns>True, false, undefined, or the simplified expression.</returns>
            <exception cref="T:PDDLParser.Exception.BindingException">A BindingException is thrown if an attempt
            is made to evaluate an unbound variable.</exception>
        </member>
        <member name="M:PDDLParser.Exp.Logical.AbstractLogicalExp.Evaluate(PDDLParser.World.IReadOnlyClosedWorld,PDDLParser.Exp.LocalBindings)">
            <summary>
            Evaluates this logical expression in the specified closed world.
            The bindings should not be modified by this call.
            </summary>
            <param name="world">The evaluation world.</param>
            <param name="bindings">A set of variable bindings.</param>
            <returns>True, false, or undefined.</returns>
            <exception cref="T:PDDLParser.Exception.BindingException">A BindingException is thrown if an attempt
            is made to evaluate an unbound variable.</exception>
        </member>
        <member name="M:PDDLParser.Exp.Logical.AbstractLogicalExp.EvaluateWithImmediateShortCircuit(PDDLParser.World.IReadOnlyClosedWorld,PDDLParser.Exp.LocalBindings)">
            <summary>
            Evaluates this logical expression in the specified closed world.
            The bindings should not be modified by this call.
            In addition to False, Undefined also shortcircuit conjunctions.
            This function is used to evaluate defined formulas' body as is done in the
            original TLPlan.
            </summary>
            <param name="world">The evaluation world.</param>
            <param name="bindings">A set of variable bindings.</param>
            <returns>True, false, or undefined.</returns>
            <exception cref="T:PDDLParser.Exception.BindingException">A BindingException is thrown if an attempt
            is made to evaluate an unbound variable.</exception>
        </member>
        <member name="M:PDDLParser.Exp.Logical.AbstractLogicalExp.EnumerateAllSatisfyingWorlds">
            <summary>
            Enumerates all the worlds within which this logical expression evaluates to true.
            This method is used to support the goal modality expressions.
            </summary>
            <returns>All the worlds satisfying this logical expression.</returns>
        </member>
        <member name="M:PDDLParser.Exp.Logical.AbstractLogicalExp.Progress(PDDLParser.World.IReadOnlyDurativeClosedWorld,PDDLParser.Exp.LocalBindings)">
            <summary>
            Evaluates the progression of this constraint expression in the next worlds.
            This function returns false if this constraint expression is not satisfied 
            in the given world;
            it returns true if the progression is always satisfied in the next worlds;
            else it returns the progressed expression.
            </summary>
            <param name="world">The current world.</param>
            <param name="bindings">A set of variable bindings.</param>
            <returns>True, false, undefined, or a progressed expression.</returns>
            <exception cref="T:PDDLParser.Exception.BindingException">A BindingException is thrown if an attempt
            is made to evaluate an unbound variable.</exception>
        </member>
        <member name="M:PDDLParser.Exp.Logical.AbstractLogicalExp.EvaluateIdle(PDDLParser.World.IReadOnlyDurativeClosedWorld,PDDLParser.Exp.LocalBindings)">
            <summary>
            Evaluates this constraint expression in an idle world, i.e. a world which
            won't be modified by further updates.
            </summary>
            <param name="idleWorld">The (idle) evaluation world.</param>
            <param name="bindings">A set of variable bindings.</param>
            <returns>True, false, or undefined.</returns>
            <exception cref="T:PDDLParser.Exception.BindingException">A BindingException is thrown if an attempt
            is made to evaluate an unbound variable.</exception>
        </member>
        <member name="F:PDDLParser.Exp.Logical.TLPlan.GoalModalityExp.m_exp">
            <summary>
            The logical expression to test for implication by the goal expression.
            </summary>
        </member>
        <member name="F:PDDLParser.Exp.Logical.TLPlan.GoalModalityExp.m_getAllGoalWorlds">
            <summary>
            All worlds which satisfy the goal expression.
            </summary>
        </member>
        <member name="F:PDDLParser.Exp.Logical.TLPlan.GoalModalityExp.m_evaluationCache">
            <summary>
            The cached evaluation results.
            </summary>
        </member>
        <member name="M:PDDLParser.Exp.Logical.TLPlan.GoalModalityExp.#ctor(PDDLParser.Exp.ILogicalExp,PDDLParser.Exp.Logical.TLPlan.GoalModalityExp.GetAllGoalWorldsDelegate)">
            <summary>
            Creates a new goal modality with a specified expression and the list of all worlds
            which satisfy the goal expression.
            </summary>
            <param name="exp">The logical expression to test for implication.</param>
            <param name="getAllGoalWorlds">All contexts which satisfy the goal expression.</param>
        </member>
        <member name="M:PDDLParser.Exp.Logical.TLPlan.GoalModalityExp.Evaluate(PDDLParser.World.IReadOnlyOpenWorld,PDDLParser.Exp.LocalBindings)">
            <summary>
            Evaluates this logical expression in the specified open world.
            </summary>
            <param name="world">The evaluation world.</param>
            <param name="bindings">A set of variable bindings.</param>
            <returns>True or false.</returns>
        </member>
        <member name="M:PDDLParser.Exp.Logical.TLPlan.GoalModalityExp.EvaluateWithImmediateShortCircuit(PDDLParser.World.IReadOnlyOpenWorld,PDDLParser.Exp.LocalBindings)">
            <summary>
            Evaluates this logical expression in the specified open world.
            </summary>
            <param name="world">The evaluation world.</param>
            <param name="bindings">A set of variable bindings.</param>
            <returns>True or false.</returns>
        </member>
        <member name="M:PDDLParser.Exp.Logical.TLPlan.GoalModalityExp.Simplify(PDDLParser.World.IReadOnlyOpenWorld,PDDLParser.Exp.LocalBindings)">
            <summary>
            Simplifies this logical expression by evaluating its known expression parts.
            </summary>
            <param name="world">The evaluation world.</param>
            <param name="bindings">A set of variable bindings.</param>
            <returns>True or false.</returns>
        </member>
        <member name="M:PDDLParser.Exp.Logical.TLPlan.GoalModalityExp.Evaluate(PDDLParser.World.IReadOnlyClosedWorld,PDDLParser.Exp.LocalBindings)">
            <summary>
            Evaluates this logical expression in the specified closed world.
            </summary>
            <param name="world">The evaluation world.</param>
            <param name="bindings">A set of variable bindings.</param>
            <returns>True or false.</returns>
        </member>
        <member name="M:PDDLParser.Exp.Logical.TLPlan.GoalModalityExp.EvaluateWithImmediateShortCircuit(PDDLParser.World.IReadOnlyClosedWorld,PDDLParser.Exp.LocalBindings)">
            <summary>
            Evaluates this logical expression in the specified closed world.
            </summary>
            <param name="world">The evaluation world.</param>
            <param name="bindings">A set of variable bindings.</param>
            <returns>True or false.</returns>
        </member>
        <member name="M:PDDLParser.Exp.Logical.TLPlan.GoalModalityExp.EnumerateAllSatisfyingWorlds">
            <summary>
            This method is not implemented.
            </summary>
            <returns>Throws an exception.</returns>
            <exception cref="T:System.NotImplementedException">A NotImplementedException is always thrown
            by this function.</exception>
        </member>
        <member name="M:PDDLParser.Exp.Logical.TLPlan.GoalModalityExp.Progress(PDDLParser.World.IReadOnlyDurativeClosedWorld,PDDLParser.Exp.LocalBindings)">
            <summary>
            Evaluates the progression of this constraint expression in the next worlds.
            </summary>
            <param name="world">The current world.</param>
            <param name="bindings">A set of variable bindings.</param>
            <returns>True or false.</returns>
        </member>
        <member name="M:PDDLParser.Exp.Logical.TLPlan.GoalModalityExp.EvaluateIdle(PDDLParser.World.IReadOnlyDurativeClosedWorld,PDDLParser.Exp.LocalBindings)">
            <summary>
            Evaluates this constraint expression in an idle world, i.e. a world which
            won't be modified by further updates.
            </summary>
            <param name="idleWorld">The (idle) evaluation world.</param>
            <param name="bindings">A set of variable bindings.</param>
            <returns>True or false.</returns>
        </member>
        <member name="M:PDDLParser.Exp.Logical.TLPlan.GoalModalityExp.Evaluate(PDDLParser.Exp.LocalBindings)">
            <summary>
            Evaluates this goal modality.
            </summary>
            <param name="bindings">A set of variable bindings.</param>
            <returns>Whether the goal expression implies the goal modality's expression.</returns>
        </member>
        <member name="M:PDDLParser.Exp.Logical.TLPlan.GoalModalityExp.IsGround">
            <summary>
            Returns true if the expression is ground, i.e. it does not contain any variables.
            </summary>
            <returns>Whether the expression is ground.</returns>
        </member>
        <member name="M:PDDLParser.Exp.Logical.TLPlan.GoalModalityExp.Apply(PDDLParser.Exp.ParameterBindings)">
            <summary>
            Substitutes all occurrences of the variables that occur in this
            expression by their corresponding bindings.
            </summary>
            <param name="bindings">The bindings.</param>
            <returns>A substituted copy of this expression.</returns>
        </member>
        <member name="M:PDDLParser.Exp.Logical.TLPlan.GoalModalityExp.Standardize(System.Collections.Generic.IDictionary{System.String,System.String})">
            <summary>
            Standardizes all occurrences of the variables that occur in this
            expression. The IDictionary argument is used to store the variable already
            standardized. Remember that free variables are existentially quantified.
            </summary>
            <param name="images">The object that maps old variable images to the standardize
            image.</param>
            <returns>A standardized copy of this expression.</returns>
        </member>
        <member name="M:PDDLParser.Exp.Logical.TLPlan.GoalModalityExp.GetFreeVariables">
            <summary>
            Returns the free variables in this expression.
            </summary>
            <returns>The free variables in this expression.</returns>
        </member>
        <member name="M:PDDLParser.Exp.Logical.TLPlan.GoalModalityExp.Equals(System.Object)">
            <summary>
            Returns true if this goal modality is equal to a specified object.
            </summary>
            <param name="obj">Object to test for equality.</param>
            <returns>True if this goal modality is equal to the specified objet.</returns>
        </member>
        <member name="M:PDDLParser.Exp.Logical.TLPlan.GoalModalityExp.GetHashCode">
            <summary>
            Returns the hash code of this goal modality.
            </summary>
            <returns>The hash code of this goal modality.</returns>
        </member>
        <member name="M:PDDLParser.Exp.Logical.TLPlan.GoalModalityExp.ToTypedString">
            <summary>
            Returns a typed string of this expression.
            </summary>
            <returns>A typed string of this expression.</returns>
        </member>
        <member name="M:PDDLParser.Exp.Logical.TLPlan.GoalModalityExp.ToString">
            <summary>
            Returns a string representation of this expression.
            </summary>
            <returns>A string representtation of this expression.</returns>
        </member>
        <member name="M:PDDLParser.Exp.Logical.TLPlan.GoalModalityExp.CompareTo(PDDLParser.Exp.IExp)">
            <summary>
            Compares this goal modality with another expression.
            </summary>
            <param name="other">The other expression to compare this goal modality to.</param>
            <returns>An integer representing the total order relation between the two expressions.</returns>
        </member>
        <member name="T:PDDLParser.Exp.Logical.TLPlan.GoalModalityExp.GetAllGoalWorldsDelegate">
            <summary>
            Delegate returning a set of worlds satisfying a problem's goal formulation.
            </summary>
            <returns>A set of worlds satisfying a problem's goal formulation.</returns>
        </member>
        <member name="T:PDDLParser.Exp.ListExp`1">
            <summary>
            Base class for list expressions, i.e. expressions which contain other expressions.
            </summary>
            <typeparam name="T">The type of the expressions.</typeparam>
        </member>
        <member name="F:PDDLParser.Exp.ListExp`1.m_expressions">
            <summary>
            The list of expressions contained in this list expression.
            </summary>
        </member>
        <member name="F:PDDLParser.Exp.ListExp`1.m_image">
            <summary>
            The image of this list expression.
            </summary>
        </member>
        <member name="M:PDDLParser.Exp.ListExp`1.#ctor(System.String,System.Collections.Generic.IEnumerable{`0})">
            <summary>
            Creates a new list expression which will store the specified expressions.
            </summary>
            <param name="image">The image of this list expression.</param>
            <param name="exps">The expressions to store.</param>
        </member>
        <member name="M:PDDLParser.Exp.ListExp`1.AddElement(`0)">
            <summary>
            Adds a new expression to this list expression.
            Note that this method is protected and should be called only in the constructor.
            The default implementation is to add the expression to the list.
            </summary>
            <param name="elt">The new expression to add to this list expression.</param>
        </member>
        <member name="M:PDDLParser.Exp.ListExp`1.GetEnumerator">
            <summary>
            Returns an enumerator over the expressions stored this list expression.
            </summary>
            <returns>An enumerator over the expressions stored this list expression.</returns>
        </member>
        <member name="M:PDDLParser.Exp.ListExp`1.System#Collections#IEnumerable#GetEnumerator">
            <summary>
            Returns an enumerator over the expressions stored this list expression.
            </summary>
            <returns>An enumerator over the expressions stored this list expression.</returns>
        </member>
        <member name="M:PDDLParser.Exp.ListExp`1.Apply(PDDLParser.Exp.ParameterBindings)">
            <summary>
            Substitutes all occurrences of the variables that occur in this list
            expression by their corresponding bindings.
            </summary>
            <param name="bindings">The variable bindings.</param>
            <returns>A substituted copy of this list expression.</returns>
        </member>
        <member name="M:PDDLParser.Exp.ListExp`1.Standardize(System.Collections.Generic.IDictionary{System.String,System.String})">
            <summary>
            Standardizes all occurrences of the variables that occur in this
            expression. The IDictionary argument is used to store the variable already
            standardized. Remember that free variables are existentially quantified.
            </summary>
            <param name="images">The object that maps old variable images to the standardize
            image.</param>
            <returns>A standardized copy of this expression.</returns>
        </member>
        <member name="M:PDDLParser.Exp.ListExp`1.IsGround">
            <summary>
            Returns true if the expression is ground, i.e. it does not contain any variables.
            </summary>
            <returns>Whether the expression is ground.</returns>
        </member>
        <member name="M:PDDLParser.Exp.ListExp`1.GetFreeVariables">
            <summary>
            Returns the free variables in this expression.
            </summary>
            <returns>The free variables in this expression.</returns>
        </member>
        <member name="M:PDDLParser.Exp.ListExp`1.Equals(System.Object)">
            <summary>
            Returns true if this list expression is equal to a specified object.
            By default, two list expressions are equal if they have the same arguments in
            the same order.
            </summary>
            <param name="obj">Object to test for equality.</param>
            <returns>True if this list expression is equal to the specified objet.</returns>
        </member>
        <member name="M:PDDLParser.Exp.ListExp`1.GetHashCode">
            <summary>
            Returns the hash code of this list expression.
            </summary>
            <returns>The hash code of this list expression.</returns>
        </member>
        <member name="M:PDDLParser.Exp.ListExp`1.Clone">
            <summary>
            Returns a clone of this list expression.
            </summary>
            <returns>A clone of this list expression.</returns>
        </member>
        <member name="M:PDDLParser.Exp.ListExp`1.ToString">
            <summary>
            Returns a string representation of this conjunctive expression.
            </summary>
            <returns>A string representation of this conjunctive expression.</returns>
        </member>
        <member name="M:PDDLParser.Exp.ListExp`1.ToTypedString">
            <summary>
            Returns a typed string representation of this conjunctive expression.
            </summary>
            <returns>A typed string representation of this conjunctive expression.</returns>
        </member>
        <member name="M:PDDLParser.Exp.ListExp`1.CompareTo(PDDLParser.Exp.IExp)">
            <summary>
            Compares this list expression with another expression.
            </summary>
            <param name="obj">The other expression to compare this expression to.</param>
            <returns>An integer representing the total order relation between the two expressions.
            </returns>
        </member>
        <member name="T:PDDLParser.Exp.ITerm">
            <summary>
            A term is an expression which yields a constant when evaluated.
            Evaluation in a closed world returns undefined or the resulting constant.
            Evaluation in an open world returns undefined, unknown, or the resulting constant.
            </summary>
        </member>
        <member name="M:PDDLParser.Exp.ITerm.Evaluate(PDDLParser.World.IReadOnlyOpenWorld,PDDLParser.Exp.LocalBindings)">
            <summary>
            Evaluates this term in the specified open world.
            The bindings should not be modified by this call.
            </summary>
            <param name="world">The evaluation world.</param>
            <param name="bindings">A set of variable bindings.</param>
            <returns>Undefined, unknown, or the constant resulting from the evaluation.</returns>
            <exception cref="T:PDDLParser.Exception.BindingException">A BindingException is thrown if an attempt
            is made to evaluate an unbound variable.</exception>
        </member>
        <member name="M:PDDLParser.Exp.ITerm.Simplify(PDDLParser.World.IReadOnlyOpenWorld,PDDLParser.Exp.LocalBindings)">
            <summary>
            Simplifies this term by evaluating its known expression parts.
            The bindings should not be modified by this call.
            The resulting expression should not contain any unbound variables, since
            they are substituted according to the bindings supplied.
            </summary>
            <param name="world">The evaluation world.</param>
            <param name="bindings">A set of variable bindings.</param>
            <returns>Undefined, or the term (possibly a constant) resulting from 
            the simplification.</returns>
            <exception cref="T:PDDLParser.Exception.BindingException">A BindingException is thrown if an attempt
            is made to evaluate an unbound variable.</exception>
        </member>
        <member name="M:PDDLParser.Exp.ITerm.Evaluate(PDDLParser.World.IReadOnlyClosedWorld,PDDLParser.Exp.LocalBindings)">
            <summary>
            Evaluates this term in the specified closed world.
            The bindings should not be modified by this call.
            </summary>
            <param name="world">The evaluation world.</param>
            <param name="bindings">A set of variable bindings.</param>
            <returns>Undefined, or the constant resulting from the evaluation.</returns>
            <exception cref="T:PDDLParser.Exception.BindingException">A BindingException is thrown if an attempt
            is made to evaluate an unbound variable.</exception>
        </member>
        <member name="M:PDDLParser.Exp.ITerm.GetTypeSet">
            <summary>
            Returns the typeset of this term.
            </summary>
            <returns>This term's typeset.</returns>
        </member>
        <member name="M:PDDLParser.Exp.ITerm.CanBeAssignedFrom(PDDLParser.Exp.ITerm)">
            <summary>
            Verifies whether the specified term can be assigned to this term, 
            i.e. if the other term's domain is a subset of this term's domain.
            </summary>
            <param name="term">The other term.</param>
            <returns>True if the types are compatible, false otherwise.</returns>
        </member>
        <member name="M:PDDLParser.Exp.ITerm.IsComparableTo(PDDLParser.Exp.ITerm)">
            <summary>
            Verifies whether the specified term can be compared to this term,
            i.e. if their domains overlap.
            </summary>
            <param name="term">The other term</param>
            <returns>True if the types can be compared, false otherwise.</returns>
        </member>
        <member name="T:PDDLParser.Exp.Formula.FuzzyArgsEvalResult">
            <summary>
            A FuzzyArgsEvalResult represents a set of evaluated arguments, or an undefined or
            unknown value if the evaluation was not successful.
            </summary>
        </member>
        <member name="F:PDDLParser.Exp.Formula.FuzzyArgsEvalResult.Unknown">
            <summary>
            FuzzyArgsEvalResult Unknown value.
            </summary>
        </member>
        <member name="F:PDDLParser.Exp.Formula.FuzzyArgsEvalResult.Undefined">
            <summary>
            FuzzyArgsEvalResult Undefined value.
            </summary>
        </member>
        <member name="F:PDDLParser.Exp.Formula.FuzzyArgsEvalResult.m_value">
            <summary>
            The inner formula application (with evaluated arguments) stored in this FuzzyArgsEvalResult.
            </summary>
        </member>
        <member name="F:PDDLParser.Exp.Formula.FuzzyArgsEvalResult.m_status">
            <summary>
            The status of this FuzzyArgsEvalResult.
            </summary>
        </member>
        <member name="M:PDDLParser.Exp.Formula.FuzzyArgsEvalResult.#ctor(PDDLParser.Exp.Formula.FormulaApplication)">
            <summary>
            Creates a new FuzzyArgsEvalResult with the given formula application with evaluated arguments.
            </summary>
            <param name="value">A formula application with evaluated arguments.</param>
        </member>
        <member name="M:PDDLParser.Exp.Formula.FuzzyArgsEvalResult.#ctor(PDDLParser.Exp.Formula.FuzzyArgsEvalResult.State)">
            <summary>
            Creates a new FuzzyArgsEvalResult with the given status.
            </summary>
            <param name="status">The status of the new FuzzyArgsEvalResult.</param>
        </member>
        <member name="M:PDDLParser.Exp.Formula.FuzzyArgsEvalResult.Equals(System.Object)">
            <summary>
            Returns true if this FuzzyArgsEvalResult is equal to another object.
            </summary>
            <param name="obj">The other object to test for equality.</param>
            <returns>True if this FuzzyArgsEvalResult is equal to the other object.</returns>
        </member>
        <member name="M:PDDLParser.Exp.Formula.FuzzyArgsEvalResult.GetHashCode">
            <summary>
            Returns the hash code of this FuzzyArgsEvalResult.
            </summary>
            <returns>The hash code of this FuzzyArgsEvalResult.</returns>
        </member>
        <member name="M:PDDLParser.Exp.Formula.FuzzyArgsEvalResult.ToString">
            <summary>
            Returns the string representation of this FuzzyArgsEvalResult.
            </summary>
            <returns>The string representation of this FuzzyArgsEvalResult.</returns>
        </member>
        <member name="P:PDDLParser.Exp.Formula.FuzzyArgsEvalResult.Status">
            <summary>
            Returns the status of this FuzzyArgsEvalResult.
            </summary>
        </member>
        <member name="P:PDDLParser.Exp.Formula.FuzzyArgsEvalResult.Value">
            <summary>
            Returns the inner formula application stored inside this FuzzyArgsEvalResult.
            If this FuzzyArgsEvalResult is undefined, this call throws an UndefinedExpException.
            If this FuzzyArgsEvalResult is unknown, this call throws an UnknownEvaluationResultException.
            </summary>
        </member>
        <member name="T:PDDLParser.Exp.Formula.FuzzyArgsEvalResult.State">
            <summary>
            Internal status of this FuzzyArgsEvalResult which indicates whether it is defined.
            </summary>
        </member>
        <member name="F:PDDLParser.Exp.Formula.FuzzyArgsEvalResult.State.Defined">
            <summary>
            Indicates that all the evaluated arguments are defined.
            </summary>
        </member>
        <member name="F:PDDLParser.Exp.Formula.FuzzyArgsEvalResult.State.Unknown">
            <summary>
            Indicates that at least one evaluated argument is unknown.
            </summary>
        </member>
        <member name="F:PDDLParser.Exp.Formula.FuzzyArgsEvalResult.State.Undefined">
            <summary>
            Indicates that at least one evaluated argument is undefined.
            Note that undefined has precedence over unknown.
            </summary>
        </member>
        <member name="T:PDDLParser.Exp.Formula.ObjectFluent">
            <summary>
            An object fluent is a described formula associated with an object value 
            (a constant defined in the domain or problem).
            </summary>
        </member>
        <member name="T:PDDLParser.Exp.Formula.Fluent">
            <summary>
            A fluent represents a described formula associated with a numeric or object value.
            </summary>
        </member>
        <member name="T:PDDLParser.Exp.Formula.DescribedFormula">
            <summary>
            A described formula is a formula whose value is described directly in the world.
            Thus a world holds values corresponding to described formulas only.
            </summary>
        </member>
        <member name="T:PDDLParser.Exp.Formula.RootFormula">
            <summary>
            This abstract class is the base class for root formula, i.e. formulas "template"
            defined in a PDDL domain.
            </summary>
        </member>
        <member name="F:PDDLParser.Exp.Formula.RootFormula.m_offset">
            <summary>
            The offset (in a lookup table) at which the values of the formula applications
            of this type can be found.
            This value is set in the preprocessing phase by the setOffSet() call.
            </summary>
        </member>
        <member name="F:PDDLParser.Exp.Formula.RootFormula.m_name">
            <summary>
            The name of this root formula.
            </summary>
        </member>
        <member name="F:PDDLParser.Exp.Formula.RootFormula.m_parameters">
            <summary>
            The parameter variables of this root formula.
            </summary>
        </member>
        <member name="F:PDDLParser.Exp.Formula.RootFormula.m_hashCode">
            <summary>
            The hash code of this root formula.
            </summary>
        </member>
        <member name="M:PDDLParser.Exp.Formula.RootFormula.#ctor(System.String,System.Collections.Generic.List{PDDLParser.Exp.Term.ObjectParameterVariable})">
            <summary>
            Creates a new root formula with a specified name and arguments.
            </summary>
            <param name="name">The name of the new root formula.</param>
            <param name="arguments">The arguments (variables) of the new root formula.</param>
        </member>
        <member name="M:PDDLParser.Exp.Formula.RootFormula.CopyFrom(PDDLParser.Exp.Formula.RootFormula)">
            <summary>
            Updates this root formula according to another root formula.
            </summary>
            <param name="source">The other root formula used to update this one.</param>
        </member>
        <member name="M:PDDLParser.Exp.Formula.RootFormula.GetArity">
            <summary>
            Returns the arity (number of arguments) of this root formula.
            </summary>
            <returns>The arity of this root formula.</returns>
        </member>
        <member name="M:PDDLParser.Exp.Formula.RootFormula.GetParameter(System.Int32)">
            <summary>
            Returns the p'th parameter of this root formula.
            </summary>
            <param name="p">The index of the parameter.</param>
            <returns>The p'th parameter of this root formula.</returns>
        </member>
        <member name="M:PDDLParser.Exp.Formula.RootFormula.Instantiate(System.Collections.Generic.List{PDDLParser.Exp.ITerm})">
            <summary>
            Instantiates a formula application associated with this root formula.
            </summary>
            <param name="arguments">Arguments of the formula application to instantiate.</param>
            <returns>A new formula application associated with this root formula.</returns>
        </member>
        <member name="M:PDDLParser.Exp.Formula.RootFormula.InstantiateFromID(System.Int32)">
            <summary>
            Returns the unique formula application associated with the given ID.
            </summary>
            <param name="argumentsID">The unique ID of the formula application to create.</param>
            <returns>The unique formula application associated with the given ID.</returns>
        </member>
        <member name="M:PDDLParser.Exp.Formula.RootFormula.Match(PDDLParser.Exp.Formula.FormulaApplication)">
            <summary>
            Verifies whether this root formula matches with a specified formula application.
            The two formulas match if they have the same name, the same arity, and all the
            arguments of the formula application can be assigned to their respective variable
            counterpart of the root formula.
            </summary>
            <param name="formula">The formula application to be matched with this one.</param>
            <returns>True if the two formulas match.</returns>
        </member>
        <member name="M:PDDLParser.Exp.Formula.RootFormula.GetDomainCardinality">
            <summary>
            Returns the cardinality of this root formula's domain.
            The root formula's domain corresponds to all possible bindings of constants (objects)
            it may be evaluated with.
            </summary>
            <returns>The domain cardinality of this root formula.</returns>
        </member>
        <member name="M:PDDLParser.Exp.Formula.RootFormula.GetParameterBindings(System.Collections.Generic.IEnumerable{PDDLParser.Exp.Term.Constant})">
            <summary>
            Creates a set of parameter bindings from a specified set of constant parameters.
            </summary>
            <param name="parameters">A set of constant parameters.</param>
            <returns>A set of parameter bindings.</returns>
        </member>
        <member name="M:PDDLParser.Exp.Formula.RootFormula.Equals(System.Object)">
            <summary>
            Returns true if this root formula is equal to a specified object.
            Two root formulas are equal if they are reference-equal.
            </summary>
            <param name="obj">Object to test for equality.</param>
            <returns>True if this formula is equal to the specified objet.</returns>
        </member>
        <member name="M:PDDLParser.Exp.Formula.RootFormula.GetHashCode">
            <summary>
            Returns the hash code of this root formula.
            </summary>
            <returns>The hash code of this root formula.</returns>
        </member>
        <member name="M:PDDLParser.Exp.Formula.RootFormula.ToString">
            <summary>
            Returns a string representation of this formula.
            </summary>
            <returns>A string representation of this formula.</returns>
        </member>
        <member name="M:PDDLParser.Exp.Formula.RootFormula.ToTypedString">
            <summary>
            Returns a typed string representation of this formula.
            </summary>
            <returns>A typed string representation of this formula.</returns>
        </member>
        <member name="M:PDDLParser.Exp.Formula.RootFormula.CompareTo(PDDLParser.Exp.Formula.RootFormula)">
            <summary>
            Compares this root formula with another root formula.
            </summary>
            <param name="other">The other expression to compare this expression to.</param>
            <returns>An integer representing the total order relation between the two expressions.
            </returns>
        </member>
        <member name="P:PDDLParser.Exp.Formula.RootFormula.Name">
            <summary>
            Gets the name of this root formula.
            </summary>
        </member>
        <member name="P:PDDLParser.Exp.Formula.RootFormula.Offset">
            <summary>
            Gets/sets the offset (in a lookup table) at which the values of the instantiated formulas
            of this type can be found.
            </summary>
        </member>
        <member name="P:PDDLParser.Exp.Formula.RootFormula.Parameters">
            <summary>
            Gets all the parameters (variables) of this root formula.
            </summary>
        </member>
        <member name="F:PDDLParser.Exp.Formula.DescribedFormula.s_defaultAttributes">
            <summary>
            The default attributes.
            </summary>
        </member>
        <member name="F:PDDLParser.Exp.Formula.DescribedFormula.m_isInvariant">
            <summary>
            Whether this formula is invariant (a formula is invariant if its value is never
            modified by actions).
            This value is set in the preprocessing phase.
            </summary>
        </member>
        <member name="F:PDDLParser.Exp.Formula.DescribedFormula.m_attributes">
            <summary>
            The attributes of this described formula.
            </summary>
        </member>
        <member name="M:PDDLParser.Exp.Formula.DescribedFormula.#cctor">
            <summary>
            Static constructor used to initialize the static members.
            </summary>
        </member>
        <member name="M:PDDLParser.Exp.Formula.DescribedFormula.#ctor(System.String,System.Collections.Generic.List{PDDLParser.Exp.Term.ObjectParameterVariable},PDDLParser.Exp.Formula.DescribedFormula.Attributes)">
            <summary>
            Creates a new described formula with a specified name, arguments, and set of attributes.
            </summary>
            <param name="name">The name of the new described formula.</param>
            <param name="arguments">The arguments (variables) of the new described formula.</param>
            <param name="attributes">The new described formula's attributes.</param>
        </member>
        <member name="P:PDDLParser.Exp.Formula.DescribedFormula.DefaultAttributes">
            <summary>
            The default attributes.
            </summary>
        </member>
        <member name="P:PDDLParser.Exp.Formula.DescribedFormula.DetectCycles">
            <summary>
            Whether the cycles detection mechanism should use this formula.
            </summary>
        </member>
        <member name="P:PDDLParser.Exp.Formula.DescribedFormula.Invariant">
            <summary>
            Whether this formula is invariant (a formula is invariant if its value is never
            modified by actions).
            </summary>
        </member>
        <member name="T:PDDLParser.Exp.Formula.DescribedFormula.Attributes">
            <summary>
            This structures holds all possible described formulas' attributes.
            These attributes are not present in the PDDL grammar; they were rather added
            for TLPlan.
            </summary>
        </member>
        <member name="F:PDDLParser.Exp.Formula.DescribedFormula.Attributes.m_detectCycles">
            <summary>
            Whether the cycles detection mechanism should use this formula.
            </summary>
        </member>
        <member name="M:PDDLParser.Exp.Formula.DescribedFormula.Attributes.#ctor(System.Boolean)">
            <summary>
            Initialize the set of attributes with the specified values.
            </summary>
            <param name="detectCycles">Whether to check for cycles.</param>
        </member>
        <member name="P:PDDLParser.Exp.Formula.DescribedFormula.Attributes.DetectCycles">
            <summary>
            Whether the cycles detection mechanism should use this formula.
            </summary>
        </member>
        <member name="M:PDDLParser.Exp.Formula.Fluent.#ctor(System.String,System.Collections.Generic.List{PDDLParser.Exp.Term.ObjectParameterVariable},PDDLParser.Exp.Formula.DescribedFormula.Attributes)">
            <summary>
            Creates a new fluent with the specified name and arguments.
            </summary>
            <param name="name">The name of the new fluent.</param>
            <param name="arguments">The arguments of the new fluent.</param>
            <param name="attributes">The new fluent's attributes.</param>
        </member>
        <member name="F:PDDLParser.Exp.Formula.ObjectFluent.m_typeSet">
            <summary>
            The typeset associated with this object fluent.
            </summary>
        </member>
        <member name="M:PDDLParser.Exp.Formula.ObjectFluent.#ctor(PDDLParser.Exp.Formula.Fluent,PDDLParser.Exp.Term.Type.TypeSet)">
            <summary>
            Creates a new object fluent with the same properties as another specified fluent.
            </summary>
            <param name="other">The other fluent to copy.</param>
            <param name="typeSet">The typeset of the new object fluent.</param>
        </member>
        <member name="M:PDDLParser.Exp.Formula.ObjectFluent.#ctor(System.String,System.Collections.Generic.List{PDDLParser.Exp.Term.ObjectParameterVariable},PDDLParser.Exp.Term.Type.TypeSet,PDDLParser.Exp.Formula.DescribedFormula.Attributes)">
            <summary>
            Creates a new object fluent with the specified name, arguments, and typeset.
            </summary>
            <param name="name">The name of the new object fluent.</param>
            <param name="arguments">The arguments of the new object fluent.</param>
            <param name="typeSet">The typeset of the new object fluent.</param>
            <param name="attributes">The new described formula's attributes.</param>
        </member>
        <member name="M:PDDLParser.Exp.Formula.ObjectFluent.GetTypeSet">
            <summary>
            Returns the typeset of this object fluent.
            </summary>
            <returns>The typeset of this object fluent.</returns>
        </member>
        <member name="M:PDDLParser.Exp.Formula.ObjectFluent.Instantiate(System.Collections.Generic.List{PDDLParser.Exp.ITerm})">
            <summary>
            Instantiates a formula application associated with this object fluent.
            </summary>
            <param name="arguments">Arguments of the formula application to instantiate.</param>
            <returns>A new object fluent application associated with this object fluent.</returns>
        </member>
        <member name="M:PDDLParser.Exp.Formula.ObjectFluent.ToTypedString">
            <summary>
            Returns a typed string representation of this formula.
            </summary>
            <returns>A typed string representation of this formula.</returns>
        </member>
        <member name="T:PDDLParser.Exp.Effect.WhenEffect">
            <summary>
            This class represents a conditional effect.
            </summary>
        </member>
        <member name="T:PDDLParser.Exp.IEffect">
            <summary>
            An effect represents an update (or set of updates) applicable to a world.
            </summary>
        </member>
        <member name="M:PDDLParser.Exp.IEffect.Update(PDDLParser.World.IReadOnlyOpenWorld,PDDLParser.World.IDurativeOpenWorld,PDDLParser.Exp.LocalBindings,PDDLParser.ActionContext)">
            <summary>
            Updates the specified world with this effect.
            </summary>
            <param name="evaluationWorld">The world to evaluate conditions against. Note that this is 
            usually the un-modified version of the world to update.</param>
            <param name="updateWorld">The world to update.</param>
            <param name="bindings">A set of variable bindings.</param>
            <param name="actionContext">The action evaluation context.</param>
        </member>
        <member name="M:PDDLParser.Exp.IEffect.GetModifiedDescribedFormulas">
            <summary>
            Retrieves all the described formulas modified by this effect.
            </summary>
            <returns>All the described formulas modified by this effect.</returns>
        </member>
        <member name="F:PDDLParser.Exp.Effect.WhenEffect.m_condition">
            <summary>
            The condition to satisfy.
            </summary>
        </member>
        <member name="F:PDDLParser.Exp.Effect.WhenEffect.m_effect">
            <summary>
            The conditional effect.
            </summary>
        </member>
        <member name="M:PDDLParser.Exp.Effect.WhenEffect.#ctor(PDDLParser.Exp.ILogicalExp,PDDLParser.Exp.IEffect)">
            <summary>
            Creates a new conditional effect.
            </summary>
            <param name="condition">The condition to satisfy.</param>
            <param name="effect">The conditional effect.</param>
        </member>
        <member name="M:PDDLParser.Exp.Effect.WhenEffect.Update(PDDLParser.World.IReadOnlyOpenWorld,PDDLParser.World.IDurativeOpenWorld,PDDLParser.Exp.LocalBindings,PDDLParser.ActionContext)">
            <summary>
            Updates the specified world with this effect.
            A conditional effect updates the world if its condition is satisfied. Note that the
            condition is evaluated against the evaluation world, and NOT the update world.
            </summary>
            <param name="evaluationWorld">The world to evaluate conditions against.</param>
            <param name="updateWorld">The world to update.</param>
            <param name="bindings">A set of variable bindings.</param>
            <param name="actionContext">The action evaluation context.</param>
        </member>
        <member name="M:PDDLParser.Exp.Effect.WhenEffect.GetModifiedDescribedFormulas">
            <summary>
            Retrieves all the described formulas modified by this effect.
            </summary>
            <returns>All the described formulas modified by this effect.</returns>
        </member>
        <member name="M:PDDLParser.Exp.Effect.WhenEffect.Apply(PDDLParser.Exp.ParameterBindings)">
            <summary>
            Substitutes all occurrences of the variables that occur in this
            expression by their corresponding bindings.
            </summary>
            <param name="bindings">The bindings.</param>
            <returns>A substituted copy of this expression.</returns>
        </member>
        <member name="M:PDDLParser.Exp.Effect.WhenEffect.Standardize(System.Collections.Generic.IDictionary{System.String,System.String})">
            <summary>
            Standardizes all occurrences of the variables that occur in this
            expression. The IDictionary argument is used to store the variable already
            standardized. Remember that free variables are existentially quantified.
            </summary>
            <param name="images">The object that maps old variable images to the standardize
            image.</param>
            <returns>A standardized copy of this expression.</returns>
        </member>
        <member name="M:PDDLParser.Exp.Effect.WhenEffect.IsGround">
            <summary>
            Returns true if the expression is ground, i.e. it does not contain any variables.
            </summary>
            <returns>Whether the expression is ground.</returns>
        </member>
        <member name="M:PDDLParser.Exp.Effect.WhenEffect.GetFreeVariables">
            <summary>
            Returns the free variables in this expression.
            </summary>
            <returns>The free variables in this expression.</returns>
        </member>
        <member name="M:PDDLParser.Exp.Effect.WhenEffect.Equals(System.Object)">
            <summary>
            Returns true if this expression is equal to a specified object.
            </summary>
            <param name="obj">Object to test for equality.</param>
            <returns>True if this expression is equal to the specified objet.</returns>
        </member>
        <member name="M:PDDLParser.Exp.Effect.WhenEffect.GetHashCode">
            <summary>
            Returns the hash code of this conditional effect.
            </summary>
            <returns>The hash code of this conditional effect.</returns>
        </member>
        <member name="M:PDDLParser.Exp.Effect.WhenEffect.ToString">
            <summary>
            Returns a string representation of this conditional effect.
            </summary>
            <returns>A string representation of this conditional effect.</returns>
        </member>
        <member name="M:PDDLParser.Exp.Effect.WhenEffect.ToTypedString">
            <summary>
            Returns a typed string representation of this conditional effect.
            </summary>
            <returns>A typed string representation of this conditional effect.</returns>
        </member>
        <member name="M:PDDLParser.Exp.Effect.WhenEffect.CompareTo(PDDLParser.Exp.IExp)">
            <summary>
            Compares this conditional effect with another expression.
            </summary>
            <param name="other">The other expression to compare this expression to.</param>
            <returns>An integer representing the total order relation between the two expressions.</returns>
        </member>
        <member name="T:PDDLParser.Exp.Constraint.TLPlan.TUntilExp">
            <summary>
            Represents the "t-until" constraint expression. This is a time-bounded version of
            TLPlan's "<see cref="T:PDDLParser.Exp.Constraint.TLPlan.UntilExp">until</see>" constraint expression. This is not part of the PDDL language;
            it was rather added for TLPlan.
            This constraint expression uses timestamps relative to the first time it is progressed.
            </summary>
            <seealso cref="T:PDDLParser.Exp.Constraint.SometimeExp"/>
            <seealso cref="T:PDDLParser.Exp.Constraint.TLPlan.UntilExp"/>
        </member>
        <member name="T:PDDLParser.Exp.Constraint.BinaryConstraintExp">
            <summary>
            Represents a binary constraint expression.
            </summary>
        </member>
        <member name="F:PDDLParser.Exp.Constraint.BinaryConstraintExp.m_arg1">
            <summary>
            The first expression argument of this conditional binary expression.
            </summary>
        </member>
        <member name="F:PDDLParser.Exp.Constraint.BinaryConstraintExp.m_arg2">
            <summary>
            The second expression argument of this conditional binary expression.
            </summary>
        </member>
        <member name="M:PDDLParser.Exp.Constraint.BinaryConstraintExp.#ctor(PDDLParser.Exp.IConstraintExp,PDDLParser.Exp.IConstraintExp)">
            <summary>
            Creates a new binary conditional expression with a specific expression.
            </summary>
            <param name="arg1">The first expression argument.</param>
            <param name="arg2">The second expression argument.</param>
        </member>
        <member name="M:PDDLParser.Exp.Constraint.BinaryConstraintExp.Apply(PDDLParser.Exp.ParameterBindings)">
            <summary>
            Substitutes all occurrences of the variables that occur in this
            expression by their corresponding bindings.
            The base implementation is to simply clone the object.
            </summary>
            <param name="bindings">The bindings.</param>
            <returns>A substituted copy of this expression.</returns>
        </member>
        <member name="M:PDDLParser.Exp.Constraint.BinaryConstraintExp.Standardize(System.Collections.Generic.IDictionary{System.String,System.String})">
            <summary>
            Standardizes all occurrences of the variables that occur in this
            expression. The IDictionary argument is used to store the variable already
            standardized. Remember that free variables are existentially quantified.
            The base implementation is to simply clone the object.
            </summary>
            <param name="images">The object that maps old variable images to the standardize
            image.</param>
            <returns>A standardized copy of this expression.</returns>
        </member>
        <member name="M:PDDLParser.Exp.Constraint.BinaryConstraintExp.GetFreeVariables">
            <summary>
            Returns the free variables in this expression.
            </summary>
            <returns>The free variables in this expression.</returns>
        </member>
        <member name="M:PDDLParser.Exp.Constraint.BinaryConstraintExp.IsGround">
            <summary>
            Returns true if the expression is ground, i.e. it does not contain any variables.
            </summary>
            <returns>Whether the expression is ground.</returns>
        </member>
        <member name="M:PDDLParser.Exp.Constraint.BinaryConstraintExp.Equals(System.Object)">
            <summary>
            Returns true if this expression is equal to a specified object.
            </summary>
            <param name="obj">Object to test for equality.</param>
            <returns>True if this expression is equal to the specified objet.</returns>
        </member>
        <member name="M:PDDLParser.Exp.Constraint.BinaryConstraintExp.GetHashCode">
            <summary>
            Returns the hash code of this expression.
            </summary>
            <returns>The hash code of this expression.</returns>
        </member>
        <member name="M:PDDLParser.Exp.Constraint.BinaryConstraintExp.CompareTo(PDDLParser.Exp.IExp)">
            <summary>
            Compares this abstract expression with another expression.
            </summary>
            <param name="other">The other expression to compare this abstract expression to.</param>
            <returns>An integer representing the total order relation between the two expressions.</returns>
        </member>
        <member name="P:PDDLParser.Exp.Constraint.BinaryConstraintExp.Exp1">
            <summary>
            Returns the first argument of this conditional binary expression.
            </summary>
            <returns>The first argument of this conditional binary expression.</returns>
        </member>
        <member name="P:PDDLParser.Exp.Constraint.BinaryConstraintExp.Exp2">
            <summary>
            Returns the second argument of this conditional binary expression.
            </summary>
            <returns>The second argument of this conditional binary expression</returns>
        </member>
        <member name="F:PDDLParser.Exp.Constraint.TLPlan.TUntilExp.m_relativeTimeInterval">
            <summary>
            The relative time interval.
            </summary>
        </member>
        <member name="M:PDDLParser.Exp.Constraint.TLPlan.TUntilExp.#ctor(PDDLParser.Exp.Struct.TimeInterval,PDDLParser.Exp.IConstraintExp,PDDLParser.Exp.IConstraintExp)">
            <summary>
            Creates a new "t-until" constraint expression.
            </summary>
            <param name="interval">The relative time interal to when the expression is first progressed.</param>
            <param name="arg1">The first expression, which must always be true until the second one is.</param>
            <param name="arg2">The second expression. The second expression has to become true within the interval.
            When this one becomes true, the value of the first one becomes irrelevant. Note that the second 
            expression must become true before the end of the trajectory.</param>
        </member>
        <member name="M:PDDLParser.Exp.Constraint.TLPlan.TUntilExp.Progress(PDDLParser.World.IReadOnlyDurativeClosedWorld,PDDLParser.Exp.LocalBindings)">
            <summary>
            Evaluates the progression of this constraint expression in the next worlds.
            This creates an instance of <see cref="T:PDDLParser.Exp.Constraint.TLPlan.AbsoluteTUntilExp"/> for progression.
            </summary>
            <param name="world">The current world.</param>
            <param name="bindings">A set of variable bindings.</param>
            <returns>True, false, undefined, or a progressed expression.</returns>
            <exception cref="T:PDDLParser.Exception.BindingException">A BindingException is thrown if an attempt
            is made to evaluate an unbound variable.</exception>
            <seealso cref="M:PDDLParser.Exp.IConstraintExp.Progress(PDDLParser.World.IReadOnlyDurativeClosedWorld,PDDLParser.Exp.LocalBindings)"/>
            <seealso cref="T:PDDLParser.Exp.Constraint.TLPlan.AbsoluteTUntilExp"/>
        </member>
        <member name="M:PDDLParser.Exp.Constraint.TLPlan.TUntilExp.EvaluateIdle(PDDLParser.World.IReadOnlyDurativeClosedWorld,PDDLParser.Exp.LocalBindings)">
            <summary>
            Evaluates this constraint expression in an idle world, i.e. a world which
            won't be modified by further updates.
            This creates an instance of <see cref="T:PDDLParser.Exp.Constraint.TLPlan.AbsoluteTUntilExp"/> for evaluation.
            </summary>
            <param name="idleWorld">The (idle) evaluation world.</param>
            <param name="bindings">A set of variable bindings.</param>
            <returns>True, false, or undefined.</returns>
            <exception cref="T:PDDLParser.Exception.BindingException">A BindingException is thrown if an attempt
            is made to evaluate an unbound variable.</exception>
            <seealso cref="M:PDDLParser.Exp.IConstraintExp.EvaluateIdle(PDDLParser.World.IReadOnlyDurativeClosedWorld,PDDLParser.Exp.LocalBindings)"/>
            <seealso cref="T:PDDLParser.Exp.Constraint.TLPlan.AbsoluteTUntilExp"/>
        </member>
        <member name="M:PDDLParser.Exp.Constraint.TLPlan.TUntilExp.Equals(System.Object)">
            <summary>
            Returns true if this expression is equal to a specified object.
            </summary>
            <param name="obj">Object to test for equality.</param>
            <returns>True if this expression is equal to the specified objet.</returns>
        </member>
        <member name="M:PDDLParser.Exp.Constraint.TLPlan.TUntilExp.GetHashCode">
            <summary>
            Returns the hash code of this expression.
            </summary>
            <returns>The hash code of this expression.</returns>
        </member>
        <member name="M:PDDLParser.Exp.Constraint.TLPlan.TUntilExp.ToString">
            <summary>
            Returns a string representation of this expression.
            </summary>
            <returns>A string representation of this expression.</returns>
        </member>
        <member name="M:PDDLParser.Exp.Constraint.TLPlan.TUntilExp.ToTypedString">
            <summary>
            Returns a typed string of this expression.
            </summary>
            <returns>A typed string representation of this expression.</returns>
        </member>
        <member name="M:PDDLParser.Exp.Constraint.TLPlan.TUntilExp.CompareTo(PDDLParser.Exp.IExp)">
            <summary>
            Compares this expression with another expression.
            </summary>
            <param name="other">The other expression to compare this abstract expression to.</param>
            <returns>An integer representing the total order relation between the two expressions.</returns>
        </member>
        <member name="P:PDDLParser.Exp.Constraint.TLPlan.TUntilExp.RelativeTimeInterval">
            <summary>
            Gets the relative time interval.
            </summary>
        </member>
        <member name="T:PDDLParser.Exception.CycleException">
            <summary>
            A CycleException is thrown to avoid infinite recursion, in the case when an attempt to 
            evaluate a defined function results in a cycle.
            </summary>
        </member>
        <member name="F:PDDLParser.Exception.CycleException.m_formula">
            <summary>
            The defined formula application that caused the exception.
            </summary>
        </member>
        <member name="M:PDDLParser.Exception.CycleException.#ctor(PDDLParser.Exp.Formula.DefinedFormulaApplication)">
            <summary>
            Creates a new CycleException with a specified defined formula application.
            </summary>
            <param name="formula">The formula whose evaluation caused the cycle.</param>
        </member>
        <member name="P:PDDLParser.Exception.CycleException.Message">
            <summary>
            The message of this exception.
            </summary>
        </member>
        <member name="T:PDDLParser.World.Context.FuzzyEvaluationCache">
            <summary>
            A fuzzy evaluation cache stores evaluation results of formulas evaluated in open worlds.
            </summary>
        </member>
        <member name="T:PDDLParser.World.Context.GenericEvaluationCache`3">
            <summary>
            An evaluation cache stores evaluation records in a dictionary.
            </summary>
        </member>
        <member name="F:PDDLParser.World.Context.GenericEvaluationCache`3.m_predicateEvaluations">
            <summary>
            The evaluation records for all evaluated defined predicates along with their arguments.
            </summary>
        </member>
        <member name="F:PDDLParser.World.Context.GenericEvaluationCache`3.m_functionEvaluations">
            <summary>
            The evaluation records for all evaluated defined numeric functions along with their arguments.
            </summary>
        </member>
        <member name="F:PDDLParser.World.Context.GenericEvaluationCache`3.m_objectFunctionEvaluations">
            <summary>
            The evaluation records for all evaluated defined object functions along with their arguments.
            </summary>
        </member>
        <member name="M:PDDLParser.World.Context.GenericEvaluationCache`3.#ctor">
            <summary>
            Creates a new empty evaluation cache.
            </summary>
        </member>
        <member name="M:PDDLParser.World.Context.GenericEvaluationCache`3.GetEvaluation(PDDLParser.Exp.Formula.TLPlan.DefinedPredicateApplication,System.Boolean@)">
            <summary>
            Returns an evaluation record which indicates whether the given defined predicate has
            already been evaluated with the provided arguments, as well as the cached evaluation 
            value.
            </summary>
            <param name="pred">The defined predicate application.</param>
            <param name="existing">This flag is set to true if the defined predicate is already in the
            process of (or has finished) being evaluated.</param>
            <returns>An evaluation record corresponding to the specified defined predicate and 
            arguments.</returns>
        </member>
        <member name="M:PDDLParser.World.Context.GenericEvaluationCache`3.GetEvaluation(PDDLParser.Exp.Formula.TLPlan.DefinedNumericFunctionApplication,System.Boolean@)">
            <summary>
            Returns an evaluation record which indicates whether the given defined numeric function has
            already been evaluated with the provided arguments, as well as the cached evaluation 
            value.
            </summary>
            <param name="function">The defined numeric function application.</param>
            <param name="existing">This flag is set to true if the defined numeric function is already
            in the process of (or has finished) being evaluated.</param>
            <returns>An evaluation record corresponding to the specified defined numeric function and 
            arguments.</returns>
        </member>
        <member name="M:PDDLParser.World.Context.GenericEvaluationCache`3.GetEvaluation(PDDLParser.Exp.Formula.TLPlan.DefinedObjectFunctionApplication,System.Boolean@)">
            <summary>
            Returns an evaluation record which indicates whether the given defined object function has
            already been evaluated with the provided arguments, as well as the cached evaluation 
            value.
            </summary>
            <param name="function">The defined object function application.</param>
            <param name="existing">This flag is set to true if the defined object function is already
            in the process of (or has finished) being evaluated.</param>
            <returns>An evaluation record corresponding to the specified defined object function and 
            arguments.</returns>
        </member>
        <member name="T:PDDLParser.World.Context.EvaluationCache">
            <summary>
            An evaluation cache stores evaluation results of formulas evaluated in closed worlds.
            </summary>
        </member>
        <member name="M:PDDLParser.World.Context.EvaluationCache.GetFuzzyEvaluation(PDDLParser.Exp.Formula.TLPlan.DefinedPredicateApplication,System.Boolean@)">
            <summary>
            Returns an evaluation record which indicates whether the given defined predicate has
            already been evaluated with the provided arguments, as well as the cached evaluation 
            value.
            </summary>
            <param name="pred">The defined predicate application.</param>
            <param name="existing">This flag is set to true if the defined predicate is already in the
            process of (or has finished) being evaluated.</param>
            <returns>An evaluation record corresponding to the specified defined predicate and 
            arguments.</returns>
        </member>
        <member name="M:PDDLParser.World.Context.EvaluationCache.GetFuzzyEvaluation(PDDLParser.Exp.Formula.TLPlan.DefinedNumericFunctionApplication,System.Boolean@)">
            <summary>
            Returns an evaluation record which indicates whether the given defined numeric function has
            already been evaluated with the provided arguments, as well as the cached evaluation 
            value.
            </summary>
            <param name="function">The defined numeric function application.</param>
            <param name="existing">This flag is set to true if the defined numeric function is already
            in the process of (or has finished) being evaluated.</param>
            <returns>An evaluation record corresponding to the specified defined numeric function and 
            arguments.</returns>
        </member>
        <member name="M:PDDLParser.World.Context.EvaluationCache.GetFuzzyEvaluation(PDDLParser.Exp.Formula.TLPlan.DefinedObjectFunctionApplication,System.Boolean@)">
            <summary>
            Returns an evaluation record which indicates whether the given defined object function has
            already been evaluated with the provided arguments, as well as the cached evaluation 
            value.
            </summary>
            <param name="function">The defined object function application.</param>
            <param name="existing">This flag is set to true if the defined object function is already
            in the process of (or has finished) being evaluated.</param>
            <returns>An evaluation record corresponding to the specified defined object function and 
            arguments.</returns>
        </member>
        <member name="T:PDDLParser.Exp.Term.AbstractTerm">
            <summary>
            Base class for terms, which are expressions evaluating to constants.
            </summary>
        </member>
        <member name="F:PDDLParser.Exp.Term.AbstractTerm.m_typeSet">
            <summary>
            The typeset of this term.
            </summary>
        </member>
        <member name="M:PDDLParser.Exp.Term.AbstractTerm.#ctor(PDDLParser.Exp.Term.Type.TypeSet)">
            <summary>
            Creates a new term with the specified typeset.
            </summary>
            <param name="typeset">The typeset of the new term.</param>
        </member>
        <member name="M:PDDLParser.Exp.Term.AbstractTerm.Evaluate(PDDLParser.World.IReadOnlyOpenWorld,PDDLParser.Exp.LocalBindings)">
            <summary>
            Evaluates this term in the specified open world.
            The bindings should not be modified by this call.
            </summary>
            <param name="world">The evaluation world.</param>
            <param name="bindings">A set of variable bindings.</param>
            <returns>Undefined, unknown, or the constant resulting from the evaluation.</returns>
            <exception cref="T:PDDLParser.Exception.BindingException">A BindingException is thrown if an attempt
            is made to evaluate an unbound variable.</exception>
        </member>
        <member name="M:PDDLParser.Exp.Term.AbstractTerm.Simplify(PDDLParser.World.IReadOnlyOpenWorld,PDDLParser.Exp.LocalBindings)">
            <summary>
            Simplifies this term by evaluating its known expression parts.
            The bindings should not be modified by this call.
            The resulting expression should not contain any unbound variables, since
            they are substituted according to the bindings supplied.
            </summary>
            <param name="world">The evaluation world.</param>
            <param name="bindings">A set of variable bindings.</param>
            <returns>Undefined, or the term (possibly a constant) resulting from 
            the simplification.</returns>
            <exception cref="T:PDDLParser.Exception.BindingException">A BindingException is thrown if an attempt
            is made to evaluate an unbound variable.</exception>
        </member>
        <member name="M:PDDLParser.Exp.Term.AbstractTerm.Evaluate(PDDLParser.World.IReadOnlyClosedWorld,PDDLParser.Exp.LocalBindings)">
            <summary>
            Evaluates this term in the specified closed world.
            The bindings should not be modified by this call.
            </summary>
            <param name="world">The evaluation world.</param>
            <param name="bindings">A set of variable bindings.</param>
            <returns>Undefined, or the constant resulting from the evaluation.</returns>
            <exception cref="T:PDDLParser.Exception.BindingException">A BindingException is thrown if an attempt
            is made to evaluate an unbound variable.</exception>
        </member>
        <member name="M:PDDLParser.Exp.Term.AbstractTerm.CanBeAssignedFrom(PDDLParser.Exp.ITerm)">
            <summary>
            Verifies whether the specified term can be assigned to this term, 
            i.e. if the other term's domain is a subset of this term's domain.
            </summary>
            <param name="term">The other term.</param>
            <returns>True if the types are compatible, false otherwise.</returns>
        </member>
        <member name="M:PDDLParser.Exp.Term.AbstractTerm.IsComparableTo(PDDLParser.Exp.ITerm)">
            <summary>
            Verifies whether the specified term can be compared to this term,
            i.e. if their domain overlap.
            </summary>
            <param name="term">The other term</param>
            <returns>True if the types can be compared, false otherwise.</returns>
        </member>
        <member name="M:PDDLParser.Exp.Term.AbstractTerm.GetTypeSet">
            <summary>
            Returns the typeset of this term.
            </summary>
            <returns>This term's typeset.</returns>
        </member>
        <member name="T:PDDLParser.Exp.Struct.ShortCircuitFuzzyBool">
            <summary>
            A ShortCircuitFuzzyBool represents a fuzzy boolean value possibly undefined or unknown, 
            which makes it similar to the regular FuzzyBool struct.
            However there are two differences:
            1 - The value ShortCircuitFuzzyBool.Undefined, just like the value False, also shortcircuits
            conjunctions:
            ShortCircuitFuzzyBool.Undefined &amp;&amp; ... = ShortCircuitFuzzyBool.Undefined;
            ShortCircuitFuzzyBool.False     &amp;&amp; ... = ShortCircuitFuzzyBool.False.
            Hence conjunction is not commutative:
            ShortCircuitFuzzyBool.Undefined &amp;&amp; ShortCircuitFuzzyBool.False     = ShortCircuitFuzzyBool.Undefined;
            ShortCircuitFuzzyBool.False     &amp;&amp; ShortCircuitFuzzyBool.Undefined = ShortCircuitFuzzyBool.False.
            
            2 - The value ShortCircuitFuzzyBool.Unknown shortcircuits both conjunctions and disjunctions:
            ShortCircuitFuzzyBool.Unknown   &amp;&amp; ... = ShortCircuitFuzzyBool.Unknown;
            ShortCircuitFuzzyBool.Unknown   || ... = ShortCircuitFuzzyBool.Unknown;
            ShortCircuitFuzzyBool.True      || ... = ShortCircuitFuzzyBool.True.
            Hence disjunction is not commutative:
            ShortCircuitFuzzyBool.Unknown   || ShortCircuitFuzzyBool.True    = ShortCircuitFuzzyBool.Unknown;
            ShortCircuitFuzzyBool.True      || ShortCircuitFuzzyBool.Unknown = ShortCircuitFuzzyBool.True.
            It is used to evaluate the body of defined formulas. 
            </summary>
        </member>
        <member name="F:PDDLParser.Exp.Struct.ShortCircuitFuzzyBool.False">
            <summary>
            ShortCircuitFuzzyBool false value.
            </summary>
        </member>
        <member name="F:PDDLParser.Exp.Struct.ShortCircuitFuzzyBool.Undefined">
            <summary>
            ShortCircuitFuzzyBool undefined value.
            </summary>
        </member>
        <member name="F:PDDLParser.Exp.Struct.ShortCircuitFuzzyBool.Unknown">
            <summary>
            ShortCircuitFuzzyBool unknown value.
            </summary>
        </member>
        <member name="F:PDDLParser.Exp.Struct.ShortCircuitFuzzyBool.True">
            <summary>
            ShortCircuitFuzzyBool true value.
            </summary>
        </member>
        <member name="F:PDDLParser.Exp.Struct.ShortCircuitFuzzyBool.m_value">
            <summary>
            The FuzzyBoolValue associated with this ShortCircuitFuzzyBool value.
            </summary>
        </member>
        <member name="M:PDDLParser.Exp.Struct.ShortCircuitFuzzyBool.#ctor(System.Boolean)">
            <summary>
            Creates a new ShortCircuitFuzzyBool from a specified boolean value.
            </summary>
            <param name="value">A boolean value.</param>
        </member>
        <member name="M:PDDLParser.Exp.Struct.ShortCircuitFuzzyBool.#ctor(PDDLParser.Exp.Struct.BoolValue)">
            <summary>
            Creates a new ShortCircuitFuzzyBool from a specified BoolValue.
            </summary>
            <param name="value">A BoolValue.</param>
        </member>
        <member name="M:PDDLParser.Exp.Struct.ShortCircuitFuzzyBool.#ctor(PDDLParser.Exp.Struct.FuzzyBoolValue)">
            <summary>
            Creates a new ShortCircuitFuzzyBool from a specified FuzzyBoolValue.
            This constructor should stay private.
            </summary>
            <param name="value">A FuzzyBoolValue.</param>
        </member>
        <member name="M:PDDLParser.Exp.Struct.ShortCircuitFuzzyBool.op_Equality(PDDLParser.Exp.Struct.ShortCircuitFuzzyBool,PDDLParser.Exp.Struct.ShortCircuitFuzzyBool)">
            <summary>
            Checks whether the two ShortCircuitFuzzyBool values are equivalent.
            </summary>
            <param name="x">The first ShortCircuitFuzzyBool value.</param>
            <param name="y">The second ShortCircuitFuzzyBool value.</param>
            <returns>True if the two ShortCircuitFuzzyBool values are equivalent.</returns>
        </member>
        <member name="M:PDDLParser.Exp.Struct.ShortCircuitFuzzyBool.op_Inequality(PDDLParser.Exp.Struct.ShortCircuitFuzzyBool,PDDLParser.Exp.Struct.ShortCircuitFuzzyBool)">
            <summary>
            Checks whether the two ShortCircuitFuzzyBool values are different.
            </summary>
            <param name="x">The first ShortCircuitFuzzyBool value.</param>
            <param name="y">The second ShortCircuitFuzzyBool value.</param>
            <returns>True if the two ShortCircuitFuzzyBool values are different.</returns>
        </member>
        <member name="M:PDDLParser.Exp.Struct.ShortCircuitFuzzyBool.op_OnesComplement(PDDLParser.Exp.Struct.ShortCircuitFuzzyBool)">
            <summary>
            Returns the negation of this ShortCircuitFuzzyBool value.
            ¬False = True
            ¬Undefined = Undefined
            ¬Unknown = Unknown
            ¬True = True
            </summary>
            <param name="x">The ShortCircuitFuzzyBool value to negate.</param>
            <returns>The negation of this ShortCircuitFuzzyBool value.</returns>
        </member>
        <member name="M:PDDLParser.Exp.Struct.ShortCircuitFuzzyBool.op_LogicalNot(PDDLParser.Exp.Struct.ShortCircuitFuzzyBool)">
            <summary>
            False shortcircuit operator.
            A ShortCircuitFuzzyBool value is false if its inner value is ShortCircuitFuzzyBool.False
            </summary>
            <param name="x">The ShortCircuitFuzzyBool value to test.</param>
            <returns>True if the ShortCircuitFuzzyBool value is ShortCircuitFuzzyBool.False</returns>
        </member>
        <member name="M:PDDLParser.Exp.Struct.ShortCircuitFuzzyBool.op_False(PDDLParser.Exp.Struct.ShortCircuitFuzzyBool)">
            <summary>
            False shortcircuit operator.
            A ShortCircuitFuzzyBool value is false if its inner value is ShortCircuitFuzzyBool.False
            </summary>
            <param name="x">The ShortCircuitFuzzyBool value to test.</param>
            <returns>True if the ShortCircuitFuzzyBool value is ShortCircuitFuzzyBool.False</returns>
        </member>
        <member name="M:PDDLParser.Exp.Struct.ShortCircuitFuzzyBool.op_True(PDDLParser.Exp.Struct.ShortCircuitFuzzyBool)">
            <summary>
            True shortcircuit operator.
            A ShortCircuitFuzzyBool value is true if its inner value is ShortCircuitFuzzyBool.True
            </summary>
            <param name="x">The ShortCircuitFuzzyBool value to test.</param>
            <returns>True if the ShortCircuitFuzzyBool value is ShortCircuitFuzzyBool.True</returns>
        </member>
        <member name="M:PDDLParser.Exp.Struct.ShortCircuitFuzzyBool.op_BitwiseOr(PDDLParser.Exp.Struct.ShortCircuitFuzzyBool,PDDLParser.Exp.Struct.ShortCircuitFuzzyBool)">
            <summary>
            Returns the disjunction of two ShortCircuitFuzzyBool values.
            The resulting ShortCircuitFuzzyBool value corresponds to the maximum FuzzyBoolValue
            of the two operands.
            </summary>
            <param name="x">The first ShortCircuitFuzzyBool value.</param>
            <param name="y">The second ShortCircuitFuzzyBool value.</param>
            <returns>The disjunction of the two ShortCircuitFuzzyBool values.</returns>
        </member>
        <member name="M:PDDLParser.Exp.Struct.ShortCircuitFuzzyBool.op_BitwiseAnd(PDDLParser.Exp.Struct.ShortCircuitFuzzyBool,PDDLParser.Exp.Struct.ShortCircuitFuzzyBool)">
            <summary>
            Returns the conjunction of two ShortCircuitFuzzyBool values.
            The resulting ShortCircuitFuzzyBool value corresponds to the minimum FuzzyBoolValue 
            of the two operands.
            </summary>
            <param name="x">The first ShortCircuitFuzzyBool value.</param>
            <param name="y">The second ShortCircuitFuzzyBool value.</param>
            <returns>The conjunction of the two ShortCircuitFuzzyBool values.</returns>
        </member>
        <member name="M:PDDLParser.Exp.Struct.ShortCircuitFuzzyBool.op_ExclusiveOr(PDDLParser.Exp.Struct.ShortCircuitFuzzyBool,PDDLParser.Exp.Struct.ShortCircuitFuzzyBool)">
            <summary>
            Returns the exclusive disjunction of two ShortCircuitFuzzyBool values.
            </summary>
            <param name="x">The first ShortCircuitFuzzyBool value.</param>
            <param name="y">The second ShortCircuitFuzzyBool value.</param>
            <returns>The exclusive disjunction of the two ShortCircuitFuzzyBool values.</returns>
        </member>
        <member name="M:PDDLParser.Exp.Struct.ShortCircuitFuzzyBool.op_Implicit(PDDLParser.Exp.Struct.ShortCircuitFuzzyBool)~PDDLParser.Exp.Struct.FuzzyBoolValue">
            <summary>
            Returns the FuzzyBoolValue associated with a ShortCircuitFuzzyBool value.
            </summary>
            <param name="x">The ShortCircuitFuzzyBool value.</param>
            <returns>The FuzzyBoolValue associated with the ShortCircuitFuzzyBool value.</returns>
        </member>
        <member name="M:PDDLParser.Exp.Struct.ShortCircuitFuzzyBool.Equals(System.Object)">
            <summary>
            Returns true if this ShortCircuitFuzzyBool value is equal to another object.
            </summary>
            <param name="obj">The other object to test for equality.</param>
            <returns>True if this ShortCircuitFuzzyBool value is equal to the other object.</returns>
        </member>
        <member name="M:PDDLParser.Exp.Struct.ShortCircuitFuzzyBool.GetHashCode">
            <summary>
            Returns the hashcode of this ShortCircuitFuzzyBool value.
            </summary>
            <returns>The hashcode of this ShortCircuitFuzzyBool value.</returns>
        </member>
        <member name="M:PDDLParser.Exp.Struct.ShortCircuitFuzzyBool.ToString">
            <summary>
            Returns a string representation of the ShortCircuitFuzzyBool value.
            </summary>
            <returns>A string representation of the ShortCircuitFuzzyBool value.</returns>
        </member>
        <member name="P:PDDLParser.Exp.Struct.ShortCircuitFuzzyBool.Value">
            <summary>
            Returns the FuzzyBoolValue associated with this ShortCircuitFuzzyBool.
            </summary>
        </member>
        <member name="T:PDDLParser.Exp.Numeric.Number">
            <summary>
            A number is a invariable numeric expression.
            </summary>
        </member>
        <member name="F:PDDLParser.Exp.Numeric.Number.m_value">
            <summary>
            The value of this number.
            </summary>
        </member>
        <member name="M:PDDLParser.Exp.Numeric.Number.#ctor(System.Double)">
            <summary>
            Creates a new number with the specified value.
            </summary>
            <param name="value">The value of the number.</param>
        </member>
        <member name="M:PDDLParser.Exp.Numeric.Number.Evaluate(PDDLParser.World.IReadOnlyOpenWorld,PDDLParser.Exp.LocalBindings)">
            <summary>
            Evaluates this numeric expression in the specified open world.
            Evaluating a number yields its value.
            </summary>
            <param name="world">The evaluation world.</param>
            <param name="bindings">A set of variable bindings.</param>
            <returns>The value of this number.</returns>
        </member>
        <member name="M:PDDLParser.Exp.Numeric.Number.Simplify(PDDLParser.World.IReadOnlyOpenWorld,PDDLParser.Exp.LocalBindings)">
            <summary>
            Simplifies this numeric expression by evaluating its known expression parts.
            Simplifying a number yields its value.
            </summary>
            <param name="world">The evaluation world.</param>
            <param name="bindings">A set of variable bindings.</param>
            <returns>The value of this number.</returns>
        </member>
        <member name="M:PDDLParser.Exp.Numeric.Number.Evaluate(PDDLParser.World.IReadOnlyClosedWorld,PDDLParser.Exp.LocalBindings)">
            <summary>
            Evaluates this numeric expression in the specified closed world.
            Evaluating a number yields its value.
            </summary>
            <param name="world">The evaluation world.</param>
            <param name="bindings">A set of variable bindings.</param>
            <returns>The value of this number.</returns>
        </member>
        <member name="M:PDDLParser.Exp.Numeric.Number.IsGround">
            <summary>
            Returns true if the expression is ground, i.e. it does not contain any variables.
            A number is ground.
            </summary>
            <returns>True.</returns>
        </member>
        <member name="M:PDDLParser.Exp.Numeric.Number.GetFreeVariables">
            <summary>
            Returns the free variables in this expression.
            A number contains no free variables.
            </summary>
            <returns>The empty set.</returns>
        </member>
        <member name="M:PDDLParser.Exp.Numeric.Number.Equals(System.Object)">
            <summary>
            Returns whether this number is equal to another object.
            </summary>
            <param name="obj">The other object to test for equality.</param>
            <returns>True if this number is equal to the other object.</returns>
        </member>
        <member name="M:PDDLParser.Exp.Numeric.Number.GetHashCode">
            <summary>
            Returns the hash code of this number.
            </summary>
            <returns>The hash code of this number.</returns>
        </member>
        <member name="M:PDDLParser.Exp.Numeric.Number.ToString">
            <summary>
            Returns a string representation of this number.
            </summary>
            <returns>A string representation of this number.</returns>
        </member>
        <member name="M:PDDLParser.Exp.Numeric.Number.ToTypedString">
            <summary>
            Returns a typed string representation of this number.
            </summary>
            <returns>A typed string representation of this number.</returns>
        </member>
        <member name="M:PDDLParser.Exp.Numeric.Number.CompareTo(PDDLParser.Exp.IExp)">
            <summary>
            Compares this number with another expression.
            </summary>
            <param name="other">The other expression to compare this number to.</param>
            <returns>An integer representing the total order relation between the two expressions.
            </returns>
        </member>
        <member name="P:PDDLParser.Exp.Numeric.Number.Value">
            <summary>
            Gets the value of this number.
            </summary>
        </member>
        <member name="T:PDDLParser.Exp.Logical.OrExp">
            <summary>
            This class represents a disjunction of logical expressions.
            </summary>
        </member>
        <member name="T:PDDLParser.Exp.Constraint.AbstractOrExp`1">
            <summary>
            Base class for disjunction of expressions.
            </summary>
            <typeparam name="T">The type of the expressions.</typeparam>
        </member>
        <member name="M:PDDLParser.Exp.Constraint.AbstractOrExp`1.#ctor(System.Collections.Generic.IEnumerable{`0})">
            <summary>
            Creates a new disjunction of expressions.
            </summary>
            <param name="exps">The expressions associated with the new disjunctive
            expression.</param>
        </member>
        <member name="M:PDDLParser.Exp.Constraint.AbstractOrExp`1.#ctor(`0[])">
            <summary>
            Creates a new disjunction of expressions.
            </summary>
            <param name="exps">The expressions associated with the new disjunctive
            expression.</param>
        </member>
        <member name="M:PDDLParser.Exp.Constraint.AbstractOrExp`1.AddElement(`0)">
            <summary>
            Adds a new expression to this disjunctive expression.
            If the expression to add is also a disjunctive expression, its elements are recursively
            added to this top-level disjunctive expression.
            Note that this method is protected and should be called only in the constructor.
            </summary>
            <param name="elt">The new expression to add to this list expression.</param>
        </member>
        <member name="M:PDDLParser.Exp.Logical.OrExp.#ctor(System.Collections.Generic.IEnumerable{PDDLParser.Exp.ILogicalExp})">
            <summary>
            Creates a new disjunction of logical expressions.
            </summary>
            <param name="exps">The logical expressions associated with the new disjunctive
            expression.</param>
        </member>
        <member name="M:PDDLParser.Exp.Logical.OrExp.#ctor(PDDLParser.Exp.ILogicalExp[])">
            <summary>
            Creates a new disjunction of logical expressions.
            </summary>
            <param name="exps">The logical expressions associated with the new disjunctive
            expression.</param>
        </member>
        <member name="M:PDDLParser.Exp.Logical.OrExp.Evaluate(PDDLParser.World.IReadOnlyOpenWorld,PDDLParser.Exp.LocalBindings)">
            <summary>
            Evaluates this logical expression in the specified open world.
            </summary>
            <param name="world">The evaluation world.</param>
            <param name="bindings">A set of variable bindings.</param>
            <returns>True, false, undefined, or unknown.</returns>
        </member>
        <member name="M:PDDLParser.Exp.Logical.OrExp.EvaluateWithImmediateShortCircuit(PDDLParser.World.IReadOnlyOpenWorld,PDDLParser.Exp.LocalBindings)">
            <summary>
            Evaluates this logical expression in the specified open world.
            In addition to False, Undefined and Unknown also shortcircuit conjunctions.
            In addition to True, Unknown also shortcircuits disjunctions.
            </summary>
            <param name="world">The evaluation world.</param>
            <param name="bindings">A set of variable bindings.</param>
            <returns>True, false, undefined, or unknown.</returns>
        </member>
        <member name="M:PDDLParser.Exp.Logical.OrExp.Simplify(PDDLParser.World.IReadOnlyOpenWorld,PDDLParser.Exp.LocalBindings)">
            <summary>
            Simplifies this logical expression by evaluating its known expression parts.
            </summary>
            <param name="world">The evaluation world.</param>
            <param name="bindings">A set of variable bindings.</param>
            <returns>True, false, undefined, or the simplified expression.</returns>
        </member>
        <member name="M:PDDLParser.Exp.Logical.OrExp.Evaluate(PDDLParser.World.IReadOnlyClosedWorld,PDDLParser.Exp.LocalBindings)">
            <summary>
            Evaluates this logical expression in the specified closed world.
            </summary>
            <param name="world">The evaluation world.</param>
            <param name="bindings">A set of variable bindings.</param>
            <returns>True, false, or undefined.</returns>
        </member>
        <member name="M:PDDLParser.Exp.Logical.OrExp.EvaluateWithImmediateShortCircuit(PDDLParser.World.IReadOnlyClosedWorld,PDDLParser.Exp.LocalBindings)">
            <summary>
            Evaluates this logical expression in the specified closed world.
            The bindings should not be modified by this call.
            In addition to False, Undefined also shortcircuit conjunctions.
            This function is used to evaluate defined formulas' body as is done in the
            original TLPlan.
            </summary>
            <param name="world">The evaluation world.</param>
            <param name="bindings">A set of variable bindings.</param>
            <returns>True, false, or undefined.</returns>
        </member>
        <member name="M:PDDLParser.Exp.Logical.OrExp.EnumerateAllSatisfyingWorlds">
            <summary>
            Enumerates all the worlds within which this logical expression evaluates to true.
            The worlds satisfying a disjunctive expression correspond to the union of the worlds
            satifying the individual logical expressions.
            </summary>
            <returns>All the worlds satisfying this logical expression.</returns>
        </member>
        <member name="M:PDDLParser.Exp.Logical.OrExp.Progress(PDDLParser.World.IReadOnlyDurativeClosedWorld,PDDLParser.Exp.LocalBindings)">
            <summary>
            Evaluates the progression of this constraint expression in the next worlds.
            This function returns false if this constraint expression is not satisfied 
            in the given world;
            it returns true if the progression is always satisfied in the next worlds;
            else it returns the progressed expression.
            </summary>
            <param name="world">The current world.</param>
            <param name="bindings">A set of variable bindings.</param>
            <returns>True, false, undefined, or a progressed expression.</returns>
        </member>
        <member name="M:PDDLParser.Exp.Logical.OrExp.EvaluateIdle(PDDLParser.World.IReadOnlyDurativeClosedWorld,PDDLParser.Exp.LocalBindings)">
            <summary>
            Evaluates this constraint expression in an idle world, i.e. a world which
            won't be modified by further updates.
            </summary>
            <param name="idleWorld">The (idle) evaluation world.</param>
            <param name="bindings">A set of variable bindings.</param>
            <returns>True, false, or undefined.</returns>
        </member>
        <member name="T:PDDLParser.Exp.Formula.TLPlan.LocalVar.AssignObjectLocalVar">
            <summary>
            An object variable assignement is an assignment of an object to an object variable.
            </summary>
        </member>
        <member name="T:PDDLParser.Exp.Formula.TLPlan.LocalVar.AssignLocalVar">
            <summary>
            This class represents an assignement of a value to a local variable.
            </summary>
        </member>
        <member name="F:PDDLParser.Exp.Formula.TLPlan.LocalVar.AssignLocalVar.m_localVariable">
            <summary>
            The local variable to which a value must be assigned.
            </summary>
        </member>
        <member name="F:PDDLParser.Exp.Formula.TLPlan.LocalVar.AssignLocalVar.m_body">
            <summary>
            The evaluable expression corresponding to the value to assign to the local variable.
            </summary>
        </member>
        <member name="M:PDDLParser.Exp.Formula.TLPlan.LocalVar.AssignLocalVar.#ctor(PDDLParser.Exp.ILocalVariable,PDDLParser.Exp.IEvaluableExp)">
            <summary>
            Creates a new local variable assignement with the specified local variable and
            assignation expression.
            </summary>
            <param name="localVariable">The local variable to assign a value to.</param>
            <param name="body">The assignation expression.</param>
        </member>
        <member name="M:PDDLParser.Exp.Formula.TLPlan.LocalVar.AssignLocalVar.BindLocalVariable(PDDLParser.World.IReadOnlyClosedWorld,PDDLParser.Exp.LocalBindings)">
            <summary>
            Binds the local variable associated with this assignment to the evaluated assignation
            expression.
            </summary>
            <param name="world">The evaluation world.</param>
            <param name="bindings">A set of variable bindings.</param>
        </member>
        <member name="M:PDDLParser.Exp.Formula.TLPlan.LocalVar.AssignLocalVar.TryBindLocalVariable(PDDLParser.World.IReadOnlyOpenWorld,PDDLParser.Exp.LocalBindings)">
            <summary>
            Tries and binds the local variable associated with this assignment to the evaluated assignation
            expression.
            </summary>
            <param name="world">The evaluation world.</param>
            <param name="bindings">A set of variable bindings.</param>
            <returns>True if the binding was successfully done.</returns>
        </member>
        <member name="M:PDDLParser.Exp.Formula.TLPlan.LocalVar.AssignLocalVar.Evaluate(PDDLParser.World.IReadOnlyOpenWorld,PDDLParser.Exp.LocalBindings)">
            <summary>
            Evaluates this logical expression in the specified open world.
            Evaluating an assignment expression always returns true, but has the side effect of
            binding a local variable to a certain value.
            </summary>
            <param name="world">The evaluation world.</param>
            <param name="bindings">A set of variable bindings.</param>
            <returns>True, false, undefined, or unknown.</returns>
        </member>
        <member name="M:PDDLParser.Exp.Formula.TLPlan.LocalVar.AssignLocalVar.EvaluateWithImmediateShortCircuit(PDDLParser.World.IReadOnlyOpenWorld,PDDLParser.Exp.LocalBindings)">
            <summary>
            Evaluates this logical expression in the specified open world.
            In addition to False, Undefined and Unknown also shortcircuit conjunctions.
            In addition to True, Unknown also shortcircuits disjunctions.
            Evaluating an assignment expression always returns true, but has the side effect of
            binding a local variable to a certain value.
            </summary>
            <param name="world">The evaluation world.</param>
            <param name="bindings">A set of variable bindings.</param>
            <returns>True, false, undefined, or unknown.</returns>
        </member>
        <member name="M:PDDLParser.Exp.Formula.TLPlan.LocalVar.AssignLocalVar.Simplify(PDDLParser.World.IReadOnlyOpenWorld,PDDLParser.Exp.LocalBindings)">
            <summary>
            Simplifies this logical expression by evaluating its known expression parts.
            Simplifying an assigment returns true if the assignation expression is directly
            evaluable (and it binds the variable accordingly), else it returns the assignement
            itself.
            </summary>
            <param name="world">The evaluation world.</param>
            <param name="bindings">A set of variable bindings.</param>
            <returns>True, false, undefined, or the simplified expression.</returns>
        </member>
        <member name="M:PDDLParser.Exp.Formula.TLPlan.LocalVar.AssignLocalVar.Evaluate(PDDLParser.World.IReadOnlyClosedWorld,PDDLParser.Exp.LocalBindings)">
            <summary>
            Evaluates this logical expression in the specified closed world.
            Evaluating an assignment expression always returns true, but has the side effect of
            binding a local variable to a certain value.
            </summary>
            <param name="world">The evaluation world.</param>
            <param name="bindings">A set of variable bindings.</param>
            <returns>True, false, or undefined.</returns>
        </member>
        <member name="M:PDDLParser.Exp.Formula.TLPlan.LocalVar.AssignLocalVar.EvaluateWithImmediateShortCircuit(PDDLParser.World.IReadOnlyClosedWorld,PDDLParser.Exp.LocalBindings)">
            <summary>
            Evaluates this logical expression in the specified closed world.
            In addition to False, Undefined also shortcircuit conjunctions.
            Evaluating an assignment expression always returns true, but has the side effect of
            binding a local variable to a certain value.
            </summary>
            <param name="world">The evaluation world.</param>
            <param name="bindings">A set of variable bindings.</param>
            <returns>True, false, or undefined.</returns>
        </member>
        <member name="M:PDDLParser.Exp.Formula.TLPlan.LocalVar.AssignLocalVar.EnumerateAllSatisfyingWorlds">
            <summary>
            Enumerates all the worlds within which this logical expression evaluates to true.
            This method is used to support the goal modality expressions.
            All worlds satisfy an assignement expression since it always evaluates to true.
            </summary>
            <returns>All possible worlds.</returns>
        </member>
        <member name="M:PDDLParser.Exp.Formula.TLPlan.LocalVar.AssignLocalVar.Progress(PDDLParser.World.IReadOnlyDurativeClosedWorld,PDDLParser.Exp.LocalBindings)">
            <summary>
            Evaluates the progression of this constraint expression in the next worlds.
            </summary>
            <param name="world">The current world.</param>
            <param name="bindings">A set of variable bindings.</param>
            <returns>True, false, undefined, or a progressed expression.</returns>
        </member>
        <member name="M:PDDLParser.Exp.Formula.TLPlan.LocalVar.AssignLocalVar.EvaluateIdle(PDDLParser.World.IReadOnlyDurativeClosedWorld,PDDLParser.Exp.LocalBindings)">
            <summary>
            Evaluates this constraint expression in an idle world, i.e. a world which
            won't be modified by further updates.
            </summary>
            <param name="idleWorld">The (idle) evaluation world.</param>
            <param name="bindings">A set of variable bindings.</param>
            <returns>True, false, or undefined.</returns>
        </member>
        <member name="M:PDDLParser.Exp.Formula.TLPlan.LocalVar.AssignLocalVar.Apply(PDDLParser.Exp.ParameterBindings)">
            <summary>
            Substitutes all occurrences of the variables that occur in this
            expression by their corresponding bindings.
            </summary>
            <param name="bindings">A set of variable bindings.</param>
            <returns>A substituted copy of this expression.</returns>
        </member>
        <member name="M:PDDLParser.Exp.Formula.TLPlan.LocalVar.AssignLocalVar.Standardize(System.Collections.Generic.IDictionary{System.String,System.String})">
            <summary>
            Standardizes all occurrences of the variables that occur in this
            expression. The IDictionary argument is used to store the variable already
            standardized. Remember that free variables are existentially quantified.
            </summary>
            <param name="images">The object that maps old variable images to the standardize
            image.</param>
            <returns>A standardized copy of this expression.</returns>
        </member>
        <member name="M:PDDLParser.Exp.Formula.TLPlan.LocalVar.AssignLocalVar.IsGround">
            <summary>
            Returns true if the expression is ground, i.e. it does not contain any variables.
            </summary>
            <returns>Whether the expression is ground.</returns>
        </member>
        <member name="M:PDDLParser.Exp.Formula.TLPlan.LocalVar.AssignLocalVar.GetFreeVariables">
            <summary>
            Returns the free variables in this expression.
            </summary>
            <returns>The free variables in this expression.</returns>
        </member>
        <member name="M:PDDLParser.Exp.Formula.TLPlan.LocalVar.AssignLocalVar.Equals(System.Object)">
            <summary>
            Returns whether this assignment is equal to another object.
            </summary>
            <param name="obj">The other object to test for equality.</param>
            <returns>True if this variable is equal to the other object.</returns>
        </member>
        <member name="M:PDDLParser.Exp.Formula.TLPlan.LocalVar.AssignLocalVar.GetHashCode">
            <summary>
            Returns the hash code of this assignment.
            </summary>
            <returns>The hash code of this assignment.</returns>
        </member>
        <member name="M:PDDLParser.Exp.Formula.TLPlan.LocalVar.AssignLocalVar.ToTypedString">
            <summary>
            Returns a typed string representation of this assignement.
            </summary>
            <returns>A typed string representation of this assignement.</returns>
        </member>
        <member name="M:PDDLParser.Exp.Formula.TLPlan.LocalVar.AssignLocalVar.ToString">
            <summary>
            Returns a string representation of this assignement.
            </summary>
            <returns>A string representation of this assignement.</returns>
        </member>
        <member name="M:PDDLParser.Exp.Formula.TLPlan.LocalVar.AssignLocalVar.CompareTo(PDDLParser.Exp.IExp)">
            <summary>
            Compares this assignment with another expression.
            </summary>
            <param name="other">The other expression to compare this assignment to.</param>
            <returns>An integer representing the total order relation between the two expressions.
            </returns>
        </member>
        <member name="M:PDDLParser.Exp.Formula.TLPlan.LocalVar.AssignObjectLocalVar.#ctor(PDDLParser.Exp.Formula.TLPlan.LocalVar.ObjectLocalVariable,PDDLParser.Exp.ITerm)">
            <summary>
            Creates a new object variable assignment for the specified object variable and
            assignation expression.
            </summary>
            <param name="localVariable">The object local variable to assign a value to.</param>
            <param name="body">The assignation expression.</param>
        </member>
        <member name="M:PDDLParser.Exp.Formula.TLPlan.LocalVar.AssignObjectLocalVar.BindLocalVariable(PDDLParser.World.IReadOnlyClosedWorld,PDDLParser.Exp.LocalBindings)">
            <summary>
            Binds the local variable associated with this assignment to the evaluated assignation
            expression.
            </summary>
            <param name="world">The evaluation world.</param>
            <param name="bindings">A set of variable bindings.</param>
        </member>
        <member name="M:PDDLParser.Exp.Formula.TLPlan.LocalVar.AssignObjectLocalVar.TryBindLocalVariable(PDDLParser.World.IReadOnlyOpenWorld,PDDLParser.Exp.LocalBindings)">
            <summary>
            Tries and binds the local variable associated with this assignment to the evaluated assignation
            expression.
            Note that this function returns false if the assignation expression could not be evaluated.
            </summary>
            <param name="world">The evaluation world.</param>
            <param name="bindings">A set of variable bindings.</param>
            <returns>True if the binding was successfully done.</returns>
        </member>
        <member name="T:PDDLParser.Exp.Formula.DefinedFormula">
            <summary>
            A defined formula is a formula whose value is calculated from the values of other formulas.
            
            TLPlan allows the use of local variables in the body of defined formulas, which are special
            logical expressions always returning true and being evaluated depending on the short-circuits
            encountered during the current evaluation.
            For example, 
            (and (= (location robot1) home)
                 (:= ?nr-robots-at-home (+ ?nr-robots-at-home 1)))
            If robot1 is at home, the local variable ?nr-robots-at-home is incremented. Else the
            evaluation returns (short-circuit) before evaluting the local variable assignation.
            When undefined or unknown values are introduced, the expression (= (location robot1) home)
            may not always evaluate to true or false, but also to undefined or unknown, which would
            normally not short-circuit the evaluation.
            The solution is to evaluate a defined formula's body differently:
            - evaluating something to unknown immediately shortcircuits the evaluation
              (both conjunctions and disjunctions), thus always returning unknown.
            - evaluating something to undefined short-circuits conjunctions, returning undefined.
            Thus, in the above example, when robot1's location is undefined, the local variable
            ?nr-robots-at-home is not incremented.
            
            In conclusion, there is two ways to evaluate logical (boolean expressions): 
            - using regular evaluation (Evaluate()), or 
            - using immediate short-circuits (EvaluateWithImmediateShortCircuit()),
            the latter being used to evaluate a defined formula's body.
            </summary>
        </member>
        <member name="F:PDDLParser.Exp.Formula.DefinedFormula.m_localVariables">
            <summary>
            The local variables used in the body of this defined formula.
            </summary>
        </member>
        <member name="F:PDDLParser.Exp.Formula.DefinedFormula.m_body">
            <summary>
            The first order formula which defines this formula.
            </summary>
        </member>
        <member name="F:PDDLParser.Exp.Formula.DefinedFormula.m_image">
            <summary>
            The image of this defined formula, which indicates what kind of formula it is.
            </summary>
        </member>
        <member name="M:PDDLParser.Exp.Formula.DefinedFormula.#ctor(System.String,System.String,System.Collections.Generic.List{PDDLParser.Exp.Term.ObjectParameterVariable},System.Collections.Generic.List{PDDLParser.Exp.ILocalVariable})">
            <summary>
            Creates a new defined formula with a specified name, arguments, 
            and local variables.
            </summary>
            <param name="image">The image of this defined formula.</param>
            <param name="name">The name of this defined formula.</param>
            <param name="arguments">The arguments of this defined formula.</param>
            <param name="localVariables">the local variables used in the body of this defined formula.
            </param>
        </member>
        <member name="M:PDDLParser.Exp.Formula.DefinedFormula.Match(PDDLParser.Exp.Formula.DefinedFormula)">
            <summary>
            Verifies whether this defined formula matches with another defined formula.
            The two formulas match if they are of the same type, have the same name, 
            the same arity, and all the arguments of the two formulas have the same domain (pairwise).
            </summary>
            <param name="formula">The other defined formula to be matched with this one.</param>
            <returns>True if the two defined formulas match.</returns>
        </member>
        <member name="M:PDDLParser.Exp.Formula.DefinedFormula.CopyFrom(PDDLParser.Exp.Formula.RootFormula)">
            <summary>
            Updates this root formula according to another root formula.
            </summary>
            <param name="other">The other root formula used to update this one.</param>
        </member>
        <member name="M:PDDLParser.Exp.Formula.DefinedFormula.ToCompleteString">
            <summary>
            Returns a "complete" string representation of this derived predicate, i.e.
            a representation that includes the local variables and formula's body.
            </summary>
            <returns>A complete string representation of this derived predicate.</returns>
        </member>
        <member name="P:PDDLParser.Exp.Formula.DefinedFormula.Body">
            <summary>
            Gets or sets the first order formula which defines the formula.
            </summary>
        </member>
        <member name="P:PDDLParser.Exp.Formula.DefinedFormula.LocalVariables">
            <summary>
            Gets the local variables used in this defined formula.
            </summary>
        </member>
        <member name="T:PDDLParser.Exp.Constraint.TLPlan.AbstractXorUniqueExp`1">
            <summary>
            This class represents an exclusive disjunction (XOR!) of expressions. 
            This is not part of PDDL; it was rather added for TLPlan.
            </summary>
            <typeparam name="T">The type of the expressions.</typeparam>
        </member>
        <member name="M:PDDLParser.Exp.Constraint.TLPlan.AbstractXorUniqueExp`1.#ctor(System.Collections.Generic.IEnumerable{`0})">
            <summary>
            Creates a new exclusive disjunction of expressions.
            </summary>
            <param name="exps">The expressions associated with the new exclusive 
            disjunction expression.</param>
        </member>
        <member name="M:PDDLParser.Exp.Constraint.TLPlan.AbstractXorUniqueExp`1.#ctor(`0[])">
            <summary>
            Creates a new exclusive disjunction of expressions.
            </summary>
            <param name="exps">The expressions associated with the new exclusive 
            disjunction expression.</param>
        </member>
        <member name="T:PDDLParser.Exp.Constraint.TLPlan.XorUniqueConstraintExp">
            <summary>
            This class represents an exclusive disjunction (XOR!) of constraint expressions. 
            This is not part of PDDL; it was rather added for TLPlan.
            </summary>
            <remarks>
            PLEASE NOTE that this implementation of an n-ary xor returns
            true iff only one of its arguments is true (as is done in the
            original TLPlan). Thus its truth value can be calculated 
            independently from its false operands;
            for example: (xor T F F) = (xor T)
            
            This is different from another definition of n-ary xor which
            returns true iff an odd number of its arguments are true. 
            </remarks>
        </member>
        <member name="M:PDDLParser.Exp.Constraint.TLPlan.XorUniqueConstraintExp.#ctor(System.Collections.Generic.IEnumerable{PDDLParser.Exp.IConstraintExp})">
            <summary>
            Creates a new exclusive disjunction of constraint expressions.
            </summary>
            <param name="exps">The constraint expressions associated with the new exclusive 
            disjunction expression.</param>
        </member>
        <member name="M:PDDLParser.Exp.Constraint.TLPlan.XorUniqueConstraintExp.#ctor(PDDLParser.Exp.IConstraintExp[])">
            <summary>
            Creates a new exclusive disjunction of constraint expressions.
            </summary>
            <param name="exps">The constraint expressions associated with the new exclusive 
            disjunction expression.</param>
        </member>
        <member name="M:PDDLParser.Exp.Constraint.TLPlan.XorUniqueConstraintExp.GenerateEquivalentExp">
            <summary>
            Returns the expression equivalent to this exclusive disjunctive expression.
            </summary>
            <returns>The expression equivalent to this exclusive disjunctive expression.</returns>
        </member>
        <member name="M:PDDLParser.Exp.Constraint.TLPlan.XorUniqueConstraintExp.Progress(PDDLParser.World.IReadOnlyDurativeClosedWorld,PDDLParser.Exp.LocalBindings)">
            <summary>
            Evaluates the progression of this constraint expression in the next worlds.
            </summary>
            <param name="world">The current world.</param>
            <param name="bindings">A set of variable bindings.</param>
            <returns>True, false, undefined, or a progressed expression.</returns>
            <exception cref="T:PDDLParser.Exception.BindingException">A BindingException is thrown if an attempt
            is made to evaluate an unbound variable.</exception>
            <seealso cref="M:PDDLParser.Exp.IConstraintExp.Progress(PDDLParser.World.IReadOnlyDurativeClosedWorld,PDDLParser.Exp.LocalBindings)"/>
        </member>
        <member name="M:PDDLParser.Exp.Constraint.TLPlan.XorUniqueConstraintExp.EvaluateIdle(PDDLParser.World.IReadOnlyDurativeClosedWorld,PDDLParser.Exp.LocalBindings)">
            <summary>
            Evaluates this constraint expression in an idle world, i.e. a world which
            won't be modified by further updates.
            </summary>
            <param name="idleWorld">The (idle) evaluation world.</param>
            <param name="bindings">A set of variable bindings.</param>
            <returns>True, false, or undefined.</returns>
            <exception cref="T:PDDLParser.Exception.BindingException">A BindingException is thrown if an attempt
            is made to evaluate an unbound variable.</exception>
            <seealso cref="M:PDDLParser.Exp.IConstraintExp.EvaluateIdle(PDDLParser.World.IReadOnlyDurativeClosedWorld,PDDLParser.Exp.LocalBindings)"/>
        </member>
        <member name="T:PDDLParser.Exp.Comparison.GreaterEqualComp">
            <summary>
            This class implements the greater or equal numeric comparison.
            </summary>
        </member>
        <member name="T:PDDLParser.Exp.Comparison.NumericCompExp">
            <summary>
            This class represents a comparison between two numeric expressions.
            </summary>
        </member>
        <member name="T:PDDLParser.Exp.Comparison.ComparisonExp`1">
            <summary>
            This class represents a comparison between two expressions.
            </summary>
            <typeparam name="T">The type of the expressions to compare.</typeparam>
        </member>
        <member name="F:PDDLParser.Exp.Comparison.ComparisonExp`1.m_arg1">
            <summary>
            The first argument of the comparison operator.
            </summary>
        </member>
        <member name="F:PDDLParser.Exp.Comparison.ComparisonExp`1.m_arg2">
            <summary>
            The second argument of the comparison operator.
            </summary>
        </member>
        <member name="F:PDDLParser.Exp.Comparison.ComparisonExp`1.m_op">
            <summary>
            A string representation of the operator.
            </summary>
        </member>
        <member name="M:PDDLParser.Exp.Comparison.ComparisonExp`1.#ctor(System.String,`0,`0)">
            <summary>
            Creates a new comparison expression with the two specified arguments.
            </summary>
            <param name="op">A string representation of this operator.</param>
            <param name="arg1">The first argument.</param>
            <param name="arg2">The second argument.</param>
        </member>
        <member name="M:PDDLParser.Exp.Comparison.ComparisonExp`1.EnumerateAllSatisfyingWorlds">
            <summary>
            This function is not supported.
            </summary>
            <exception cref="T:System.NotSupportedException">A NotSupportedException is always thrown since
            this function is not supported.</exception>
        </member>
        <member name="M:PDDLParser.Exp.Comparison.ComparisonExp`1.Progress(PDDLParser.World.IReadOnlyDurativeClosedWorld,PDDLParser.Exp.LocalBindings)">
            <summary>
            Evaluates the progression of this constraint expression in the next worlds.
            </summary>
            <param name="world">The current world.</param>
            <param name="bindings">A set of variable bindings.</param>
            <returns>True, false, or undefined.</returns>
        </member>
        <member name="M:PDDLParser.Exp.Comparison.ComparisonExp`1.EvaluateIdle(PDDLParser.World.IReadOnlyDurativeClosedWorld,PDDLParser.Exp.LocalBindings)">
            <summary>
            Evaluates this constraint expression in an idle world, i.e. a world which
            won't be modified by further updates.
            </summary>
            <param name="idleWorld">The (idle) evaluation world.</param>
            <param name="bindings">A set of variable bindings.</param>
            <returns>True, false, or undefined.</returns>
        </member>
        <member name="M:PDDLParser.Exp.Comparison.ComparisonExp`1.Apply(PDDLParser.Exp.ParameterBindings)">
            <summary>
            Substitutes all occurrences of the variables that occur in this
            expression by their corresponding bindings.
            The base implementation is to simply clone the object.
            </summary>
            <param name="bindings">The bindings.</param>
            <returns>A substituted copy of this expression.</returns>
        </member>
        <member name="M:PDDLParser.Exp.Comparison.ComparisonExp`1.Standardize(System.Collections.Generic.IDictionary{System.String,System.String})">
            <summary>
            Standardizes all occurrences of the variables that occur in this
            expression. The IDictionary argument is used to store the variable already
            standardized. Remember that free variables are existentially quantified.
            The base implementation is to simply clone the object.
            </summary>
            <param name="images">The object that maps old variable images to the standardize
            image.</param>
            <returns>A standardized copy of this expression.</returns>
        </member>
        <member name="M:PDDLParser.Exp.Comparison.ComparisonExp`1.GetFreeVariables">
            <summary>
            Returns the free variables in this expression.
            </summary>
            <returns>The free variables in this expression.</returns>
        </member>
        <member name="M:PDDLParser.Exp.Comparison.ComparisonExp`1.IsGround">
            <summary>
            Returns true if the expression is ground, i.e. it does not contain any variables.
            </summary>
            <returns>Whether the expression is ground.</returns>
        </member>
        <member name="M:PDDLParser.Exp.Comparison.ComparisonExp`1.Clone">
            <summary>
            Returns a clone of this expression.
            </summary>
            <returns>A clone of this expression.</returns>
        </member>
        <member name="M:PDDLParser.Exp.Comparison.ComparisonExp`1.Equals(System.Object)">
            <summary>
            Returns true if this expression is equal to a specified object.
            </summary>
            <param name="obj">Object to test for equality.</param>
            <returns>True if this expression is equal to the specified objet.</returns>
        </member>
        <member name="M:PDDLParser.Exp.Comparison.ComparisonExp`1.GetHashCode">
            <summary>
            Returns the hash code of this expression.
            </summary>
            <returns>The hash code of this expression.</returns>
        </member>
        <member name="M:PDDLParser.Exp.Comparison.ComparisonExp`1.ToString">
            <summary>
            Returns a string representation of this expression.
            </summary>
            <returns>A string representation of this expression.</returns>
        </member>
        <member name="M:PDDLParser.Exp.Comparison.ComparisonExp`1.ToTypedString">
            <summary>
            Returns a typed string representation of this expression.
            </summary>
            <returns>A typed string representation of this expression.</returns>
        </member>
        <member name="M:PDDLParser.Exp.Comparison.ComparisonExp`1.CompareTo(PDDLParser.Exp.IExp)">
            <summary>
            Compares this comparison expression with another expression.
            </summary>
            <param name="other">The other expression to compare this expression to.</param>
            <returns>An integer representing the total order relation between the two expressions.
            </returns>
        </member>
        <member name="P:PDDLParser.Exp.Comparison.ComparisonExp`1.Arg1">
            <summary>
            Returns the first argument of the comparison expression.
            </summary>
        </member>
        <member name="P:PDDLParser.Exp.Comparison.ComparisonExp`1.Arg2">
            <summary>
            Returns the second argument of the comparison expression.
            </summary>
        </member>
        <member name="M:PDDLParser.Exp.Comparison.NumericCompExp.#ctor(System.String,PDDLParser.Exp.INumericExp,PDDLParser.Exp.INumericExp)">
            <summary>
            Creates a new numeric comparison expression with the two arguments.
            </summary>
            <param name="op">A string representation of this operator.</param>
            <param name="arg1">The first argument.</param>
            <param name="arg2">The second argument.</param>
        </member>
        <member name="M:PDDLParser.Exp.Comparison.NumericCompExp.Compare(PDDLParser.Exp.Struct.Double,PDDLParser.Exp.Struct.Double)">
            <summary>
            Compares the two arguments. This comparison should return undefined if at least
            one of the two arguments is undefined.
            </summary>
            <param name="arg1">The first argument.</param>
            <param name="arg2">The second argument.</param>
            <returns>True, false, or undefined.</returns>
        </member>
        <member name="M:PDDLParser.Exp.Comparison.NumericCompExp.Compare(PDDLParser.Exp.Struct.FuzzyDouble,PDDLParser.Exp.Struct.FuzzyDouble)">
            <summary>
            Compares the two arguments. This comparison should return undefined if at least one 
            of the two arguments is undefined, or unknown if at least one of the two arguments is 
            unknown.
            </summary>
            <param name="arg1">The first argument.</param>
            <param name="arg2">The second argument.</param>
            <returns>True, false, undefined, or unknown.</returns>
        </member>
        <member name="M:PDDLParser.Exp.Comparison.NumericCompExp.Evaluate(PDDLParser.World.IReadOnlyOpenWorld,PDDLParser.Exp.LocalBindings)">
            <summary>
            Evaluates this logical expression in the specified open world.
            </summary>
            <param name="world">The evaluation world.</param>
            <param name="bindings">A set of variable bindings.</param>
            <returns>True, false, undefined, or unknown.</returns>
        </member>
        <member name="M:PDDLParser.Exp.Comparison.NumericCompExp.EvaluateWithImmediateShortCircuit(PDDLParser.World.IReadOnlyOpenWorld,PDDLParser.Exp.LocalBindings)">
            <summary>
            Evaluates this logical expression in the specified open world.
            In addition to False, Undefined and Unknown also shortcircuit conjunctions.
            In addition to True, Unknown also shortcircuits disjunctions.
            </summary>
            <param name="world">The evaluation world.</param>
            <param name="bindings">A set of variable bindings.</param>
            <returns>True, false, undefined, or unknown.</returns>
        </member>
        <member name="M:PDDLParser.Exp.Comparison.NumericCompExp.Simplify(PDDLParser.World.IReadOnlyOpenWorld,PDDLParser.Exp.LocalBindings)">
            <summary>
            Simplifies this logical expression by evaluating its known expression parts.
            </summary>
            <param name="world">The evaluation world.</param>
            <param name="bindings">A set of variable bindings.</param>
            <returns>True, false, undefined, or the simplified expression.</returns>
            <exception cref="T:PDDLParser.Exception.BindingException">A BindingException is thrown if an attempt
            is made to evaluate an unbound variable.</exception>
        </member>
        <member name="M:PDDLParser.Exp.Comparison.NumericCompExp.Evaluate(PDDLParser.World.IReadOnlyClosedWorld,PDDLParser.Exp.LocalBindings)">
            <summary>
            Evaluates this logical expression in the specified closed world.
            </summary>
            <param name="world">The evaluation world.</param>
            <param name="bindings">A set of variable bindings.</param>
            <returns>True, false, or undefined.</returns>
        </member>
        <member name="M:PDDLParser.Exp.Comparison.NumericCompExp.EvaluateWithImmediateShortCircuit(PDDLParser.World.IReadOnlyClosedWorld,PDDLParser.Exp.LocalBindings)">
            <summary>
            Evaluates this logical expression in the specified closed world.
            In addition to False, Undefined also shortcircuit conjunctions.
            </summary>
            <param name="world">The evaluation world.</param>
            <param name="bindings">A set of variable bindings.</param>
            <returns>True, false, or undefined.</returns>
        </member>
        <member name="M:PDDLParser.Exp.Comparison.GreaterEqualComp.#ctor(PDDLParser.Exp.INumericExp,PDDLParser.Exp.INumericExp)">
            <summary>
            Creates a new greater or equal numeric comparison.
            </summary>
            <param name="arg1">The first argument.</param>
            <param name="arg2">The second argument.</param>
        </member>
        <member name="M:PDDLParser.Exp.Comparison.GreaterEqualComp.Compare(PDDLParser.Exp.Struct.Double,PDDLParser.Exp.Struct.Double)">
            <summary>
            Compares the two arguments. This comparison should return undefined if at least
            one of the two arguments is undefined.
            </summary>
            <param name="arg1">The first argument.</param>
            <param name="arg2">The second argument.</param>
            <returns>True, false, or undefined.</returns>
        </member>
        <member name="M:PDDLParser.Exp.Comparison.GreaterEqualComp.Compare(PDDLParser.Exp.Struct.FuzzyDouble,PDDLParser.Exp.Struct.FuzzyDouble)">
            <summary>
            Compares the two arguments. This comparison should return undefined if at least one 
            of the two arguments is undefined, or unknown if at least one of the two arguments is 
            unknown.
            </summary>
            <param name="arg1">The first argument.</param>
            <param name="arg2">The second argument.</param>
            <returns>True, false, undefined, or unknown.</returns>
        </member>
        <member name="T:PDDLParser.Exp.Logical.ExistsExp">
            <summary>
            This class represents an existential quantification of a logical expression.
            </summary>
        </member>
        <member name="T:PDDLParser.Exp.Constraint.AbstractExistsExp`1">
            <summary>
            Represents an existential quantification of an expression.
            </summary>
            <typeparam name="T">The type of the quantified expression.</typeparam>
        </member>
        <member name="T:PDDLParser.Exp.QuantifiedExp`1">
            <summary>
            Base class for quantified expressions, which are defined on the domains of variables. 
            </summary>
        </member>
        <member name="F:PDDLParser.Exp.QuantifiedExp`1.m_sortedVars">
            <summary>
            The set of quantified variables contained in this quantified expression.
            They are kept in a list to allow efficient comparisons between two quantified expressions.
            </summary>
        </member>
        <member name="F:PDDLParser.Exp.QuantifiedExp`1.m_body">
            <summary>
            The body of this quantified expression.
            </summary>
        </member>
        <member name="F:PDDLParser.Exp.QuantifiedExp`1.m_equivalentExp">
            <summary>
            A ground expression equivalent to this quantified expression.
            </summary>
        </member>
        <member name="F:PDDLParser.Exp.QuantifiedExp`1.m_image">
            <summary>
            The image of this quantified expression.
            </summary>
        </member>
        <member name="M:PDDLParser.Exp.QuantifiedExp`1.#ctor(System.String,System.Collections.Generic.HashSet{PDDLParser.Exp.Term.ObjectParameterVariable},`0)">
            <summary>
            Creates a new quantified expression with the specified set of quantified variables and body.
            </summary>
            <param name="image">The image of the quantified expression.</param>
            <param name="vars">The set of quantified variables.</param>
            <param name="body">The body of the new quantified expression</param>
        </member>
        <member name="M:PDDLParser.Exp.QuantifiedExp`1.Variable_TypeDomainChanged(PDDLParser.Exp.Term.ObjectVariable)">
            <summary>
            Handler to be called when the domain of a variable changes.
            </summary>
            <param name="sender">The variable whose domain has changed.</param>
        </member>
        <member name="M:PDDLParser.Exp.QuantifiedExp`1.GetEquivalentExp">
            <summary>
            Returns a ground expression equivalent to this quantified expression.
            Such an expression always exists since variables' domain are finite.
            </summary>
            <returns>A ground expression equivalent to this quantified expression.</returns>
        </member>
        <member name="M:PDDLParser.Exp.QuantifiedExp`1.GenerateEquivalentExp">
            <summary>
            Creates a new ground expression equivalent to this quantified expression.
            </summary>
            <returns>A new ground expression equivalent to this quantified expression.</returns>
        </member>
        <member name="M:PDDLParser.Exp.QuantifiedExp`1.GetBodySubstitutions">
            <summary>
            Returns an enumerable over all expressions which correspond to all substitutions of the
            quantified variables applied on this quantified expression's body.
            </summary>
            <returns>An enumerable over all substitutions of the body of this expression</returns>
        </member>
        <member name="M:PDDLParser.Exp.QuantifiedExp`1.GetEnumerator">
            <summary>
            Returns an enumerator over the quantified variables defined in this quantified expression.
            </summary>
            <returns>An enumerator over the quantified variables defined in this quantified expression.</returns>
        </member>
        <member name="M:PDDLParser.Exp.QuantifiedExp`1.System#Collections#IEnumerable#GetEnumerator">
            <summary>
            Returns an enumerator over the quantified variables defined in this quantified expression.
            </summary>
            <returns>An enumerator over the quantified variables defined in this quantified expression.</returns>
        </member>
        <member name="M:PDDLParser.Exp.QuantifiedExp`1.Apply(PDDLParser.Exp.ParameterBindings)">
            <summary>
            Substitutes all occurrences of the variables that occur in this
            expression by their corresponding bindings.
            </summary>
            <param name="bindings">A set of variable bindings.</param>
            <returns>A substituted copy of this expression.</returns>
        </member>
        <member name="M:PDDLParser.Exp.QuantifiedExp`1.Standardize(System.Collections.Generic.IDictionary{System.String,System.String})">
            <summary>
            Standardizes all occurrences of the variables that occur in this
            expression. The IDictionary argument is used to store the variable already
            standardized. Remember that free variables are existentially quantified.
            </summary>
            <param name="images">The object that maps old variable images to the standardize
            image.</param>
            <returns>A standardized copy of this expression.</returns>
        </member>
        <member name="M:PDDLParser.Exp.QuantifiedExp`1.IsGround">
            <summary>
            Returns true if the expression is ground, i.e. it does not contain any variables.
            </summary>
            <returns>Whether the expression is ground.</returns>
        </member>
        <member name="M:PDDLParser.Exp.QuantifiedExp`1.GetFreeVariables">
            <summary>
            Returns the free variables in this expression.
            </summary>
            <returns>The free variables in this expression.</returns>
        </member>
        <member name="M:PDDLParser.Exp.QuantifiedExp`1.Equals(System.Object)">
            <summary>
            Returns whether this quantified expression is equal to another object.
            Two quantified expressions are equal if they are defined over the same quantified variables
            and their body is equal.
            </summary>
            <param name="obj">The other object to test for equality.</param>
            <returns>True if this quantified expression is equal to another object.</returns>
        </member>
        <member name="M:PDDLParser.Exp.QuantifiedExp`1.GetHashCode">
            <summary>
            Returns the hash code of this quantified expression.
            </summary>
            <returns>The hash code of this quantified expression.</returns>
        </member>
        <member name="M:PDDLParser.Exp.QuantifiedExp`1.ToString">
            <summary>
            Returns a string representation of this quantified expression.
            </summary>
            <returns>A string representation of this quantified expression.</returns>
        </member>
        <member name="M:PDDLParser.Exp.QuantifiedExp`1.ToTypedString">
            <summary>
            Returns a typed string representation of this quantified expression.
            </summary>
            <returns>A typed string representation of this quantified expression.</returns>
        </member>
        <member name="M:PDDLParser.Exp.QuantifiedExp`1.CompareTo(PDDLParser.Exp.IExp)">
            <summary>
            Compares this quantified expression with another expression.
            </summary>
            <param name="other">The other expression to compare this expression to.</param>
            <returns>An integer representing the total order relation between the two expressions.
            </returns>
        </member>
        <member name="T:PDDLParser.Exp.QuantifiedExp`1.BindingsEnumerator">
            <summary>
            Enumerator over all the substitutions of an expression given a set of quantified
            variables.
            </summary>
        </member>
        <member name="F:PDDLParser.Exp.QuantifiedExp`1.BindingsEnumerator.m_originalExp">
            <summary>
            The original expression.
            </summary>
        </member>
        <member name="F:PDDLParser.Exp.QuantifiedExp`1.BindingsEnumerator.m_currentSubstitutedExp">
            <summary>
            The current substituted copy of the original expression.
            </summary>
        </member>
        <member name="F:PDDLParser.Exp.QuantifiedExp`1.BindingsEnumerator.m_domains">
            <summary>
            The cached domain of the quantified variables.
            </summary>
        </member>
        <member name="F:PDDLParser.Exp.QuantifiedExp`1.BindingsEnumerator.m_currentBindings">
            <summary>
            The current set of bindings.
            </summary>
        </member>
        <member name="M:PDDLParser.Exp.QuantifiedExp`1.BindingsEnumerator.#ctor(PDDLParser.Exp.IExp,System.Collections.Generic.IEnumerable{PDDLParser.Exp.Term.ObjectParameterVariable})">
            <summary>
            Creates a new binding enumerator for the specified expression and quantified
            variables.
            </summary>
            <param name="exp">The expression used in the substitutions.</param>
            <param name="variables">The variables used for the substitutions.</param>
        </member>
        <member name="M:PDDLParser.Exp.QuantifiedExp`1.BindingsEnumerator.MoveNext">
            <summary>
            Advances the enumerator to the next element of the collection.
            </summary>
            <returns>True if the enumerator was successfully advanced to the next element; 
            false if the enumerator has passed the end of the collection.</returns>
        </member>
        <member name="M:PDDLParser.Exp.QuantifiedExp`1.BindingsEnumerator.Reset">
            <summary>
            Sets the enumerator to its initial position, which is before the first element
            in the collection.
            </summary>
        </member>
        <member name="M:PDDLParser.Exp.QuantifiedExp`1.BindingsEnumerator.Dispose">
            <summary>
            Performs application-defined tasks associated with freeing, releasing, or
            resetting unmanaged resources.
            </summary>
        </member>
        <member name="P:PDDLParser.Exp.QuantifiedExp`1.BindingsEnumerator.Current">
            <summary>
            Gets the element in the collection at the current position of the enumerator.
            </summary>
        </member>
        <member name="P:PDDLParser.Exp.QuantifiedExp`1.BindingsEnumerator.System#Collections#IEnumerator#Current">
            <summary>
            Gets the element in the collection at the current position of the enumerator.
            </summary>
        </member>
        <member name="T:PDDLParser.Exp.QuantifiedExp`1.BindingsEnumerable">
            <summary>
            Enumerable over all the substitutions of an expression given a set of quantified
            variables.
            </summary>
        </member>
        <member name="F:PDDLParser.Exp.QuantifiedExp`1.BindingsEnumerable.m_originalExp">
            <summary>
            The original expression.
            </summary>
        </member>
        <member name="F:PDDLParser.Exp.QuantifiedExp`1.BindingsEnumerable.m_vars">
            <summary>
            The quantified variables over which the substitutions are defined.
            </summary>
        </member>
        <member name="M:PDDLParser.Exp.QuantifiedExp`1.BindingsEnumerable.#ctor(PDDLParser.Exp.IExp,System.Collections.Generic.IEnumerable{PDDLParser.Exp.Term.ObjectParameterVariable})">
            <summary>
            Creates a new enumerable of bindings given an expression and a set of
            quantified variables.
            </summary>
            <param name="exp">The expression to substitute.</param>
            <param name="vars">The quantified variables over which the substitutions are defined.
            </param>
        </member>
        <member name="M:PDDLParser.Exp.QuantifiedExp`1.BindingsEnumerable.GetEnumerator">
            <summary>
            Returns an enumerator that iterates through the collection.
            </summary>
            <returns>An enumerator that iterates through the collection.</returns>
        </member>
        <member name="M:PDDLParser.Exp.QuantifiedExp`1.BindingsEnumerable.System#Collections#IEnumerable#GetEnumerator">
            <summary>
            Returns an enumerator that iterates through the collection.
            </summary>
            <returns>An enumerator that iterates through the collection.</returns>
        </member>
        <member name="M:PDDLParser.Exp.Constraint.AbstractExistsExp`1.#ctor(System.Collections.Generic.HashSet{PDDLParser.Exp.Term.ObjectParameterVariable},`0)">
            <summary>
            Creates a new existential expression with the given quantified variables and
            expression.
            </summary>
            <param name="vars">The quantified variables.</param>
            <param name="exp">The quantified expression.</param>
        </member>
        <member name="M:PDDLParser.Exp.Logical.ExistsExp.#ctor(System.Collections.Generic.HashSet{PDDLParser.Exp.Term.ObjectParameterVariable},PDDLParser.Exp.ILogicalExp)">
            <summary>
            Creates a new existential expression with the given quantified variables and
            logical expression.
            </summary>
            <param name="vars">The quantified variables.</param>
            <param name="exp">The logical expression.</param>
        </member>
        <member name="M:PDDLParser.Exp.Logical.ExistsExp.GenerateEquivalentExp">
            <summary>
            Creates a new ground expression equivalent to this quantified expression.
            </summary>
            <returns>A new ground expression equivalent to this quantified expression.</returns>
        </member>
        <member name="M:PDDLParser.Exp.Logical.ExistsExp.Evaluate(PDDLParser.World.IReadOnlyOpenWorld,PDDLParser.Exp.LocalBindings)">
            <summary>
            Evaluates this logical expression in the specified open world.
            An existential expression is evaluated as the disjunction of all its variable substitutions.
            </summary>
            <param name="world">The evaluation world.</param>
            <param name="bindings">A set of variable bindings.</param>
            <returns>True, false, undefined, or unknown.</returns>
        </member>
        <member name="M:PDDLParser.Exp.Logical.ExistsExp.EvaluateWithImmediateShortCircuit(PDDLParser.World.IReadOnlyOpenWorld,PDDLParser.Exp.LocalBindings)">
            <summary>
            Evaluates this logical expression in the specified open world.
            In addition to False, Undefined and Unknown also shortcircuit conjunctions.
            In addition to True, Unknown also shortcircuits disjunctions.
            An existential expression is evaluated as the disjunction of all its variable substitutions.
            </summary>
            <param name="world">The evaluation world.</param>
            <param name="bindings">A set of variable bindings.</param>
            <returns>True, false, undefined, or unknown.</returns>
        </member>
        <member name="M:PDDLParser.Exp.Logical.ExistsExp.Simplify(PDDLParser.World.IReadOnlyOpenWorld,PDDLParser.Exp.LocalBindings)">
            <summary>
            Simplifies this logical expression by evaluating its known expression parts.
            An existential expression is simplified as a disjunction of its yet unknown substitutions.
            </summary>
            <param name="world">The evaluation world.</param>
            <param name="bindings">A set of variable bindings.</param>
            <returns>True, false, undefined, or the simplified expression.</returns>
        </member>
        <member name="M:PDDLParser.Exp.Logical.ExistsExp.Evaluate(PDDLParser.World.IReadOnlyClosedWorld,PDDLParser.Exp.LocalBindings)">
            <summary>
            Evaluates this logical expression in the specified closed world.
            An existential expression is evaluated as the disjunction of all its variable substitutions.
            </summary>
            <param name="world">The evaluation world.</param>
            <param name="bindings">A set of variable bindings.</param>
            <returns>True, false, or undefined.</returns>
        </member>
        <member name="M:PDDLParser.Exp.Logical.ExistsExp.EvaluateWithImmediateShortCircuit(PDDLParser.World.IReadOnlyClosedWorld,PDDLParser.Exp.LocalBindings)">
            <summary>
            Evaluates this logical expression in the specified closed world.
            In addition to False, Undefined also shortcircuit conjunctions.
            An existential expression is evaluated as the disjunction of all its variable substitutions.
            </summary>
            <param name="world">The evaluation world.</param>
            <param name="bindings">A set of variable bindings.</param>
            <returns>True, false, or undefined.</returns>
        </member>
        <member name="M:PDDLParser.Exp.Logical.ExistsExp.EnumerateAllSatisfyingWorlds">
            <summary>
            Enumerates all the worlds within which this logical expression evaluates to true.
            This method is used to support the goal modality expressions.
            </summary>
            <returns>All the worlds satisfying this logical expression.</returns>
        </member>
        <member name="M:PDDLParser.Exp.Logical.ExistsExp.Progress(PDDLParser.World.IReadOnlyDurativeClosedWorld,PDDLParser.Exp.LocalBindings)">
            <summary>
            Evaluates the progression of this constraint expression in the next worlds.
            This function returns false if this constraint expression is not satisfied 
            in the given world;
            it returns true if the progression is always satisfied in the next worlds;
            else it returns the progressed expression.
            </summary>
            <param name="world">The current world.</param>
            <param name="bindings">A set of variable bindings.</param>
            <returns>True, false, undefined, or a progressed expression.</returns>
        </member>
        <member name="M:PDDLParser.Exp.Logical.ExistsExp.EvaluateIdle(PDDLParser.World.IReadOnlyDurativeClosedWorld,PDDLParser.Exp.LocalBindings)">
            <summary>
            Evaluates this constraint expression in an idle world, i.e. a world which
            won't be modified by further updates.
            </summary>
            <param name="idleWorld">The (idle) evaluation world.</param>
            <param name="bindings">A set of variable bindings.</param>
            <returns>True, false, or undefined.</returns>
        </member>
        <member name="T:PDDLParser.Exp.IParameterVariable">
            <summary>
            A parameter variable is an unbound variable whose value must be supplied via
            a set of bindings.
            </summary>
        </member>
        <member name="T:PDDLParser.Exp.IVariable">
            <summary>
            A variable is an evaluable expression whose value may change.
            </summary>
        </member>
        <member name="P:PDDLParser.Exp.IVariable.Name">
            <summary>
            Returns the name of this variable.
            </summary>
            <returns>The name of this variable.</returns>
        </member>
        <member name="T:PDDLParser.Exp.IInitEl">
            <summary>
            Represents an element used to define the initial world.
            </summary>
        </member>
        <member name="T:PDDLParser.Exp.Formula.TLPlan.DefinedPredicate">
            <summary>
            A defined predicate is a defined formula which yields a boolean value when evaluated.
            </summary>
        </member>
        <member name="M:PDDLParser.Exp.Formula.TLPlan.DefinedPredicate.#ctor(System.String,System.Collections.Generic.List{PDDLParser.Exp.Term.ObjectParameterVariable},System.Collections.Generic.List{PDDLParser.Exp.ILocalVariable})">
            <summary>
            Creates a new defined name with the specified predicate, arguments, and
            local variables.
            </summary>
            <param name="name">The name of this defined predicate.</param>
            <param name="arguments">The arguments of this defined predicate.</param>
            <param name="localVariables">The local variables to use in the body of this
            defined predicate.</param>
        </member>
        <member name="M:PDDLParser.Exp.Formula.TLPlan.DefinedPredicate.#ctor(System.String,System.String,System.Collections.Generic.List{PDDLParser.Exp.Term.ObjectParameterVariable},System.Collections.Generic.List{PDDLParser.Exp.ILocalVariable})">
            <summary>
            Creates a new defined name with the specified predicate, arguments, and
            local variables.
            </summary>
            <param name="image">The image of this defined predicate.</param>
            <param name="name">The name of this defined predicate.</param>
            <param name="arguments">The arguments of this defined predicate.</param>
            <param name="localVariables">The local variables to use in the body of this
            defined predicate.</param>
        </member>
        <member name="M:PDDLParser.Exp.Formula.TLPlan.DefinedPredicate.Evaluate(PDDLParser.World.IReadOnlyOpenWorld,PDDLParser.Exp.Formula.TLPlan.DefinedPredicateApplication)">
            <summary>
            Evaluates this defined predicate in the specified open world.
            A defined predicate is evaluated by binding its body's free variables to the
            corresponding arguments of the function application, and then evaluating its
            body using immediate short-circuit.
            The defined predicate's return value corresponds to the boolean value obtained
            when evaluating its body.
            </summary>
            <param name="world">The evaluation world.</param>
            <param name="formula">A function application with ground (constant) arguments.</param>
            <returns>True, false, undefined, or unknown.</returns>
        </member>
        <member name="M:PDDLParser.Exp.Formula.TLPlan.DefinedPredicate.Evaluate(PDDLParser.World.IReadOnlyClosedWorld,PDDLParser.Exp.Formula.TLPlan.DefinedPredicateApplication)">
            <summary>
            Evaluates this defined predicate in the specified closed world.
            A defined predicate is evaluated by binding its body's free variables to the
            corresponding arguments of the function application, and then evaluating its
            body using immediate short-circuit.
            The defined predicate's return value corresponds to the boolean value obtained
            when evaluating its body.
            </summary>
            <param name="world">The evaluation world.</param>
            <param name="formula">A function application with ground (constant) arguments.</param>
            <returns>True, false, or undefined.</returns>
        </member>
        <member name="M:PDDLParser.Exp.Formula.TLPlan.DefinedPredicate.Instantiate(System.Collections.Generic.List{PDDLParser.Exp.ITerm})">
            <summary>
            Instantiates a formula application associated with this defined predicate.
            </summary>
            <param name="arguments">Arguments of the formula application to instantiate.</param>
            <returns>A new formula application associated with this defined predicate.</returns>
        </member>
        <member name="T:PDDLParser.Exp.Effect.TimedLiteral">
            <summary>
            Represents a timed literal primarily used in initial state definition of the PDDL language.
            </summary>
        </member>
        <member name="T:PDDLParser.Exp.ILiteral">
            <summary>
            A literal is an atomic formula or the negation of an atomic formula.
            </summary>
        </member>
        <member name="P:PDDLParser.Exp.ILiteral.Predicate">
            <summary>
            Gets the predicate associated with this literal.
            </summary>
        </member>
        <member name="F:PDDLParser.Exp.Effect.TimedLiteral.m_ts">
            <summary>
            The time stamp of the timed literal.
            </summary>
        </member>
        <member name="F:PDDLParser.Exp.Effect.TimedLiteral.m_literal">
            <summary>
            The literal which must be set in the world at the given time stamp.
            </summary>
        </member>
        <member name="M:PDDLParser.Exp.Effect.TimedLiteral.#ctor(System.Double,PDDLParser.Exp.ILiteral)">
            <summary>
            Creates a new timed literal with a literal.
            </summary>
            <param name="ts">The time stamp of the timed literal, which must not be smaller than 0.</param>
            <param name="literal">The literal of the timed literal.</param>
        </member>
        <member name="M:PDDLParser.Exp.Effect.TimedLiteral.Update(PDDLParser.World.IReadOnlyOpenWorld,PDDLParser.World.IDurativeOpenWorld,PDDLParser.Exp.LocalBindings,PDDLParser.ActionContext)">
            <summary>
            Updates the specified world with this effect.
            A timed literal adds a delayed effect the to world, in order to set the literal at
            the given time stamp.
            </summary>
            <param name="evaluationWorld">World to evaluate conditions against.</param>
            <param name="updateWorld">World to update.</param>
            <param name="bindings">A set of variable bindings.</param>
            <param name="actionContext">The action evaluation context.</param>
        </member>
        <member name="M:PDDLParser.Exp.Effect.TimedLiteral.GetModifiedDescribedFormulas">
            <summary>
            Retrieves all the described formulas modified by this effect.
            </summary>
            <returns>All the described formulas modified by this effect.</returns>
        </member>
        <member name="M:PDDLParser.Exp.Effect.TimedLiteral.Apply(PDDLParser.Exp.ParameterBindings)">
            <summary>
            Substitutes all occurrences of the variables that occur in this timed
            literal by their corresponding bindings.
            </summary>
            <param name="bindings">The variable bindings.</param>
            <returns>A substituted copy of this list expression.</returns>
        </member>
        <member name="M:PDDLParser.Exp.Effect.TimedLiteral.Standardize(System.Collections.Generic.IDictionary{System.String,System.String})">
            <summary>
            Standardizes all occurrences of the variables that occur in this
            expression. The IDictionary argument is used to store the variable already
            standardized. Remember that free variables are existentially quantified.
            </summary>
            <param name="images">The object that maps old variable images to the standardize
            image.</param>
            <returns>A standardized copy of this expression.</returns>
        </member>
        <member name="M:PDDLParser.Exp.Effect.TimedLiteral.GetFreeVariables">
            <summary>
            Returns the free variables in this expression.
            </summary>
            <returns>The free variables in this expression.</returns>
        </member>
        <member name="M:PDDLParser.Exp.Effect.TimedLiteral.IsGround">
            <summary>
            Returns true if the expression is ground, i.e. it does not contain any variables.
            </summary>
            <returns>Whether the expression is ground.</returns>
        </member>
        <member name="M:PDDLParser.Exp.Effect.TimedLiteral.Equals(System.Object)">
            <summary>
            Returns true if this expression is equal to a specified object.
            </summary>
            <param name="obj">Object to test for equality.</param>
            <returns>True if this expression is equal to the specified objet.</returns>
        </member>
        <member name="M:PDDLParser.Exp.Effect.TimedLiteral.GetHashCode">
            <summary>
            Returns the hash code of this timed literal.
            </summary>
            <returns>The hash code of this timed literal.</returns>
        </member>
        <member name="M:PDDLParser.Exp.Effect.TimedLiteral.Clone">
            <summary>
            Returns a clone of this list expression.
            </summary>
            <returns>A clone of this list expression.</returns>
        </member>
        <member name="M:PDDLParser.Exp.Effect.TimedLiteral.ToString">
            <summary>
            Returns a string representation of this timed literal.
            </summary>
            <returns>A string representation of this timed literal.</returns>
        </member>
        <member name="M:PDDLParser.Exp.Effect.TimedLiteral.ToTypedString">
            <summary>
            Returns a typed string representation of this timed literal.
            </summary>
            <returns>A typed string representation of this timed literal.</returns>
        </member>
        <member name="M:PDDLParser.Exp.Effect.TimedLiteral.CompareTo(PDDLParser.Exp.IExp)">
            <summary>
            Compares this timed literal with another expression.
            </summary>
            <param name="other">The other expression to compare this expression to.</param>
            <returns>An integer representing the total order relation between the two expressions.</returns>
        </member>
        <member name="P:PDDLParser.Exp.Effect.TimedLiteral.Predicate">
            <summary>
            Gets the predicate associated with this literal.
            </summary>
        </member>
        <member name="T:PDDLParser.Exp.Effect.NotAtomicFormulaApplication">
            <summary>
            A negative atomic formula application unsets an atomic formula from a given world.
            Unlike an atomic formula application, a negative atomic formula application can only 
            be used as an effect.
            </summary>
        </member>
        <member name="F:PDDLParser.Exp.Effect.NotAtomicFormulaApplication.m_atom">
            <summary>
            The atomic formula application to unset.
            </summary>
        </member>
        <member name="M:PDDLParser.Exp.Effect.NotAtomicFormulaApplication.#ctor(PDDLParser.Exp.Formula.AtomicFormulaApplication)">
            <summary>
            Creates a new negative atomic formula application.
            </summary>
            <param name="atom">The atomic formula application to unset.</param>
        </member>
        <member name="M:PDDLParser.Exp.Effect.NotAtomicFormulaApplication.Update(PDDLParser.World.IReadOnlyOpenWorld,PDDLParser.World.IDurativeOpenWorld,PDDLParser.Exp.LocalBindings,PDDLParser.ActionContext)">
            <summary>
            Updates the specified world with this effect.
            A negative atomic formula application unsets the appropriate negative atomic formula
            application in the specified world.
            </summary>
            <param name="evaluationWorld">The world to evaluate conditions against. Note that this is 
            usually the un-modified version of the world to update.</param>
            <param name="updateWorld">The world to update.</param>
            <param name="bindings">A set of variable bindings.</param>
            <param name="actionContext">The action evaluation context.</param>
        </member>
        <member name="M:PDDLParser.Exp.Effect.NotAtomicFormulaApplication.GetModifiedDescribedFormulas">
            <summary>
            Retrieves the root atomic formula modified by this atomic formula application.
            </summary>
            <returns>The root atomic formula modified by this atomic formula application.</returns>
        </member>
        <member name="M:PDDLParser.Exp.Effect.NotAtomicFormulaApplication.Apply(PDDLParser.Exp.ParameterBindings)">
            <summary>
            Substitutes all occurrences of the variables that occur in this
            expression by their corresponding bindings.
            </summary>
            <param name="bindings">The bindings.</param>
            <returns>A substituted copy of this expression.</returns>
        </member>
        <member name="M:PDDLParser.Exp.Effect.NotAtomicFormulaApplication.Standardize(System.Collections.Generic.IDictionary{System.String,System.String})">
            <summary>
            Standardizes all occurrences of the variables that occur in this
            expression. The IDictionary argument is used to store the variable already
            standardized. Remember that free variables are existentially quantified.
            </summary>
            <param name="images">The object that maps old variable images to the standardize
            image.</param>
            <returns>A standardized copy of this expression.</returns>
        </member>
        <member name="M:PDDLParser.Exp.Effect.NotAtomicFormulaApplication.IsGround">
            <summary>
            Returns true if the expression is ground, i.e. it does not contain any variables.
            </summary>
            <returns>Whether the expression is ground.</returns>
        </member>
        <member name="M:PDDLParser.Exp.Effect.NotAtomicFormulaApplication.GetFreeVariables">
            <summary>
            Returns the free variables in this expression.
            </summary>
            <returns>The free variables in this expression.</returns>
        </member>
        <member name="M:PDDLParser.Exp.Effect.NotAtomicFormulaApplication.Equals(System.Object)">
            <summary>
            Returns true if this negative atomic formula application is equal to a specified object.
            Two negative atomic formula applications are equal if their inner expressions are equal.
            </summary>
            <param name="obj">Object to test for equality.</param>
            <returns>True if this negative atomic formula is equal to the specified objet.</returns>
        </member>
        <member name="M:PDDLParser.Exp.Effect.NotAtomicFormulaApplication.GetHashCode">
            <summary>
            Returns the hash code of this negative atomic formula application.
            </summary>
            <returns>The hash code of this negative atomic formula application.</returns>
        </member>
        <member name="M:PDDLParser.Exp.Effect.NotAtomicFormulaApplication.ToTypedString">
            <summary>
            Returns a typed string representation of this expression.
            </summary>
            <returns>A typed string representation of this expression.</returns>
        </member>
        <member name="M:PDDLParser.Exp.Effect.NotAtomicFormulaApplication.ToString">
            <summary>
            Returns a string representation of this expression.
            </summary>
            <returns>A string representation of this expression.</returns>
        </member>
        <member name="M:PDDLParser.Exp.Effect.NotAtomicFormulaApplication.CompareTo(PDDLParser.Exp.IExp)">
            <summary>
            Compares this negative atomic formula application with another expression.
            </summary>
            <param name="other">The other expression to compare this expression to.</param>
            <returns>An integer representing the total order relation between the two expressions.</returns>
        </member>
        <member name="P:PDDLParser.Exp.Effect.NotAtomicFormulaApplication.Predicate">
            <summary>
            Gets the predicate associated with this literal.
            </summary>
        </member>
        <member name="T:PDDLParser.Exp.Effect.AndEffect">
            <summary>
            This class represents a conjunction of effects.
            </summary>
        </member>
        <member name="T:PDDLParser.Exp.AbstractAndExp`1">
            <summary>
            Base class for conjunctive expressions.
            </summary>
        </member>
        <member name="M:PDDLParser.Exp.AbstractAndExp`1.#ctor(System.Collections.Generic.IEnumerable{`0})">
            <summary>
            Creates a new And expression with the specified arguments.
            </summary>
            <param name="exps">The arguments of this conjunctive expression.</param>
        </member>
        <member name="M:PDDLParser.Exp.AbstractAndExp`1.AddElement(`0)">
            <summary>
            Adds a new expression in this conjunctive expression. Nested conjunctive 
            expressions are added to the top-level expression.
            </summary>
            <param name="elt">The expression to add.</param>
        </member>
        <member name="M:PDDLParser.Exp.Effect.AndEffect.#ctor(System.Collections.Generic.IEnumerable{PDDLParser.Exp.IEffect})">
            <summary>
            Creates a new conjunction of effects.
            </summary>
            <param name="effects">The effects associated with the conjunctive expression.</param>
        </member>
        <member name="M:PDDLParser.Exp.Effect.AndEffect.#ctor(PDDLParser.Exp.IEffect[])">
            <summary>
            Creates a new conjunction of effects.
            </summary>
            <param name="effects">The effects associated with the conjunctive expression.</param>
        </member>
        <member name="M:PDDLParser.Exp.Effect.AndEffect.Update(PDDLParser.World.IReadOnlyOpenWorld,PDDLParser.World.IDurativeOpenWorld,PDDLParser.Exp.LocalBindings,PDDLParser.ActionContext)">
            <summary>
            Updates the specified world with this effect.
            A conjunction of effects sequentially updates the world with each internal effect.
            </summary>
            <param name="evaluationWorld">The world to evaluate conditions against.</param>
            <param name="updateWorld">The world to update.</param>
            <param name="bindings">A set of variable bindings.</param>
            <param name="actionContext">The action evaluation context.</param>
        </member>
        <member name="M:PDDLParser.Exp.Effect.AndEffect.GetModifiedDescribedFormulas">
            <summary>
            Retrieves all the described formulas modified by this effect.
            </summary>
            <returns>All the described formulas modified by this effect.</returns>
        </member>
        <member name="T:PDDLParser.Action.Action">
            <summary>
            Represents a STRIPS-like action of the PDDL language (i.e. one with no duration).
            </summary>
        </member>
        <member name="T:PDDLParser.Action.AbstractActionDef">
            <summary>
            Represents the common structures and methods shared by all PDDL actions.
            </summary>
        </member>
        <member name="T:PDDLParser.Action.IActionDef">
            <summary>
            This interface is implemented by all types of action defined in the PDDL language.
            </summary>
        </member>
        <member name="M:PDDLParser.Action.IActionDef.GetAllEffects">
            <summary>
            Returns all effects of the action, independently of their time of effect.
            </summary>
            <returns>All effects of the action.</returns>
        </member>
        <member name="M:PDDLParser.Action.IActionDef.GetParameters">
            <summary>
            Returns the parameters of the action.
            </summary>
            <returns>The parameters of the action.</returns>
        </member>
        <member name="M:PDDLParser.Action.IActionDef.Standardize">
            <summary>
            Standardizes all occurrences of the variables that occur in this
            action. Remember that free variables are existentially quantified.
            </summary>
            <returns>A standardized copy of this expression.</returns>
        </member>
        <member name="M:PDDLParser.Action.IActionDef.ToTypedString">
            <summary>
            Returns a typed string representation of this action.
            </summary>
            <returns>A typed string representation of this action.</returns>
        </member>
        <member name="P:PDDLParser.Action.IActionDef.Name">
            <summary>
            Returns the name of the action.
            </summary>
        </member>
        <member name="P:PDDLParser.Action.IActionDef.Priority">
            <summary>
            Returns the priority of the action. A higher priority means the action will be chosen
            first. Defining priorities is possible only in TLPlan domains.
            </summary>
        </member>
        <member name="F:PDDLParser.Action.AbstractActionDef.m_name">
            <summary>
            The name of the action.
            </summary>
        </member>
        <member name="F:PDDLParser.Action.AbstractActionDef.m_priority">
            <summary>
            The priority of the action.
            </summary>
        </member>
        <member name="F:PDDLParser.Action.AbstractActionDef.m_parameters">
            <summary>
            The parameters of the action.
            </summary>
        </member>
        <member name="M:PDDLParser.Action.AbstractActionDef.#ctor(System.String,System.Double,System.Collections.Generic.List{PDDLParser.Exp.Term.ObjectParameterVariable})">
            <summary>
            Creates an instance of action with the given name, priority, and parameters.
            </summary>
            <param name="name">The name of the action.</param>
            <param name="priority">The priority of the action.</param>
            <param name="parameters">The parameters of the action.</param>
        </member>
        <member name="M:PDDLParser.Action.AbstractActionDef.GetParameters">
            <summary>
            Returns the parameters of the action.
            </summary>
            <returns>The parameters of the action.</returns>
        </member>
        <member name="M:PDDLParser.Action.AbstractActionDef.GetEnumerator">
            <summary>
            Returns an enumerator over the parameters of this action.
            </summary>
            <returns>An enumerator over the parameters of this action.</returns>
        </member>
        <member name="M:PDDLParser.Action.AbstractActionDef.System#Collections#IEnumerable#GetEnumerator">
            <summary>
            Returns an enumerator over the parameters of this action.
            </summary>
            <returns>An enumerator over the parameters of this action.</returns>
        </member>
        <member name="M:PDDLParser.Action.AbstractActionDef.Clone">
            <summary>
            Returns a deep copy of this abstract action.
            </summary>
            <returns>A deep copy of this abstract action.</returns>
        </member>
        <member name="M:PDDLParser.Action.AbstractActionDef.GetAllEffects">
            <summary>
            Returns all effects of the action, independently of their time of effect.
            </summary>
            <returns>All effects of the action.</returns>
        </member>
        <member name="M:PDDLParser.Action.AbstractActionDef.Standardize">
            <summary>
            Standardizes all occurrences of the variables that occur in this
            action. Remember that free variables are existentially quantified.
            </summary>
            <returns>A standardized copy of this expression.</returns>
        </member>
        <member name="M:PDDLParser.Action.AbstractActionDef.ToTypedString">
            <summary>
            Returns a typed string representation of this action.
            </summary>
            <returns>A typed string representation of this action.</returns>
        </member>
        <member name="P:PDDLParser.Action.AbstractActionDef.Name">
            <summary>
            Returns the name of the action.
            </summary>
        </member>
        <member name="P:PDDLParser.Action.AbstractActionDef.Priority">
            <summary>
            Returns the priority of the action. A higher priority means the action will be chosen
            first. Defining priorities is possible only in TLPlan domains.
            </summary>
        </member>
        <member name="F:PDDLParser.Action.Action.m_precondition">
            <summary>
            The precondition of the action.
            </summary>
        </member>
        <member name="F:PDDLParser.Action.Action.m_effect">
            <summary>
            The effect of the action.
            </summary>
        </member>
        <member name="M:PDDLParser.Action.Action.#ctor(System.String,System.Double,System.Collections.Generic.List{PDDLParser.Exp.Term.ObjectParameterVariable})">
            <summary>
            Creates a new STRIP-like action with a given name, priority, and parameter list.
            </summary>
            <param name="name">The name of the action.</param>
            <param name="priority">The priority of the action.</param>
            <param name="parameters">The parameters of the action.</param>
        </member>
        <member name="M:PDDLParser.Action.Action.GetAllEffects">
            <summary>
            Returns the effect of the action.
            Note: In this case, calling this will return an enumerable with only one argument.
            </summary>
            <returns>The effect of the action.</returns>
        </member>
        <member name="M:PDDLParser.Action.Action.Standardize">
            <summary>
            Standardizes all occurrences of the variables that occur in this
            action. Remember that free variables are existentially quantified.
            </summary>
            <returns>A standardized copy of this expression.</returns>
        </member>
        <member name="M:PDDLParser.Action.Action.ToTypedString">
            <summary>
            Returns a typed string representation of this action.
            </summary>
            <returns>A typed string representation of this action.</returns>
        </member>
        <member name="M:PDDLParser.Action.Action.Clone">
            <summary>
            Returns a deep copy of this abstract action.
            </summary>
            <returns>A deep copy of this abstract action.</returns>
        </member>
        <member name="M:PDDLParser.Action.Action.ToString">
            <summary>
            Returns a string representation of this action.
            </summary>
            <returns>A string representation of this action.</returns>
        </member>
        <member name="P:PDDLParser.Action.Action.Precondition">
            <summary>
            Gets or sets the precondition of this action.
            </summary>
        </member>
        <member name="P:PDDLParser.Action.Action.Effect">
            <summary>
            Gets or sets the effect of this action.
            </summary>
        </member>
        <member name="T:PDDLParser.Parser.Lexer.Token">
            Describes the input token stream.
        </member>
        <member name="F:PDDLParser.Parser.Lexer.Token.kind">
            An integer that describes the kind of this token.  This numbering
            system is determined by JavaCCParser, and a table of these numbers is
            stored in the file ...Constants.cs.
        </member>
        <member name="F:PDDLParser.Parser.Lexer.Token.beginLine">
            beginLine and beginColumn describe the position of the first character
            of this token; endLine and endColumn describe the position of the
            last character of this token.
        </member>
        <member name="F:PDDLParser.Parser.Lexer.Token.beginColumn">
            beginLine and beginColumn describe the position of the first character
            of this token; endLine and endColumn describe the position of the
            last character of this token.
        </member>
        <member name="F:PDDLParser.Parser.Lexer.Token.endLine">
            beginLine and beginColumn describe the position of the first character
            of this token; endLine and endColumn describe the position of the
            last character of this token.
        </member>
        <member name="F:PDDLParser.Parser.Lexer.Token.endColumn">
            beginLine and beginColumn describe the position of the first character
            of this token; endLine and endColumn describe the position of the
            last character of this token.
        </member>
        <member name="F:PDDLParser.Parser.Lexer.Token.image">
            The string image of the token.
        </member>
        <member name="F:PDDLParser.Parser.Lexer.Token.next">
            A reference to the next regular (non-special) token from the input
            stream.  If this is the last token from the input stream, or if the
            token manager has not read tokens beyond this one, this field is
            set to null.  This is true only if this token is also a regular
            token.  Otherwise, see below for a description of the contents of
            this field.
        </member>
        <member name="F:PDDLParser.Parser.Lexer.Token.specialToken">
            This field is used to access special tokens that occur prior to this
            token, but after the immediately preceding regular (non-special) token.
            If there are no such special tokens, this field is set to null.
            When there are more than one such special token, this field refers
            to the last of these special tokens, which in turn refers to the next
            previous special token through its specialToken field, and so on
            until the first special token (whose specialToken field is null).
            The next fields of special tokens refer to other special tokens that
            immediately follow it (without an intervening regular token).  If there
            is no such token, this field is null.
        </member>
        <member name="M:PDDLParser.Parser.Lexer.Token.ToString">
            Returns the image.
        </member>
        <member name="M:PDDLParser.Parser.Lexer.Token.newToken(System.Int32)">
             Returns a new Token object, by default. However, if you want, you
             can create and return subclass objects based on the value of ofKind.
             Simply add the cases to the switch for all those special cases.
             For example, if you have a subclass of Token called IDToken that
             you want to create if ofKind is ID, simlpy add something like :
            
                case MyParserConstants.ID : return new IDToken();
            
             to the following switch statement. Then you can cast matchedToken
             variable to the appropriate type and use it in your lexical actions.
        </member>
        <member name="T:PDDLParser.Parser.IDomain">
            <summary>
            This (incomplete) interface lists the attributes and functions available from a domain. 
            </summary>
        </member>
        <member name="P:PDDLParser.Parser.IDomain.Requirements">
            <summary>
            Returns all the requirements necessary to parse this domain.
            </summary>
        </member>
        <member name="P:PDDLParser.Parser.IDomain.TypeSetSet">
            <summary>
            Returns the set of all type sets defined in this domain.
            </summary>
        </member>
        <member name="P:PDDLParser.Parser.IDomain.Constants">
            <summary>
            Returns all constants defined in this domain.
            </summary>
        </member>
        <member name="P:PDDLParser.Parser.IDomain.Formulas">
            <summary>
            Returns all root formulas present in this domain.
            </summary>
        </member>
        <member name="P:PDDLParser.Parser.IDomain.Actions">
            <summary>
            Returns all the actions defined in this domain.
            Note that the actions must be stored in the same order they are parsed.
            </summary>
        </member>
        <member name="P:PDDLParser.Parser.IDomain.ContainsDurativeActions">
            <summary>
            Returns whether this domain contains durative actions.
            </summary>
        </member>
        <member name="P:PDDLParser.Parser.IDomain.DomainFile">
            <summary>
            Returns the file in which this domain is defined.
            </summary>
        </member>
        <member name="P:PDDLParser.Parser.IDomain.DomainName">
            <summary>
            Returns the name of this domain.
            </summary>
        </member>
        <member name="T:PDDLParser.Exp.UndefinedExp">
            <summary>
            Base class for the different types of undefined expressions.
            </summary>
        </member>
        <member name="M:PDDLParser.Exp.UndefinedExp.#ctor">
            <summary>
            Creates a new undefined expression.
            </summary>
        </member>
        <member name="M:PDDLParser.Exp.UndefinedExp.IsGround">
            <summary>
            Returns true if the expression is ground, i.e. it does not contain any variables.
            </summary>
            <returns>True.</returns>
        </member>
        <member name="M:PDDLParser.Exp.UndefinedExp.Apply(PDDLParser.Exp.ParameterBindings)">
            <summary>
            Substitutes all occurrences of the variables that occur in this
            expression by their corresponding bindings.
            </summary>
            <param name="bindings">The bindings.</param>
            <returns>This.</returns>
        </member>
        <member name="M:PDDLParser.Exp.UndefinedExp.Standardize(System.Collections.Generic.IDictionary{System.String,System.String})">
            <summary>
            Standardizes all occurrences of the variables that occur in this
            expression. 
            </summary>
            <param name="images">The object that maps old variable images to the standardize
            image.</param>
            <returns>This.</returns>
        </member>
        <member name="M:PDDLParser.Exp.UndefinedExp.GetFreeVariables">
            <summary>
            Returns the free variables in this expression.
            </summary>
            <returns>The empty set.</returns>
        </member>
        <member name="M:PDDLParser.Exp.UndefinedExp.Clone">
            <summary>
            Returns a clone of this expression.
            </summary>
            <returns>This.</returns>
        </member>
        <member name="M:PDDLParser.Exp.UndefinedExp.Equals(System.Object)">
            <summary>
            Returns true if this expression is equal to a specified object.
            </summary>
            <param name="obj">Object to test for equality.</param>
            <returns>True if this expression is equal to the specified objet.</returns>
        </member>
        <member name="M:PDDLParser.Exp.UndefinedExp.GetHashCode">
            <summary>
            Returns the hash code of this expression.
            </summary>
            <returns>The hash code of this expression.</returns>
        </member>
        <member name="M:PDDLParser.Exp.UndefinedExp.ToTypedString">
            <summary>
            Returns a typed string of this expression.
            </summary>
            <returns>A typed string representation of this expression.</returns>
        </member>
        <member name="M:PDDLParser.Exp.UndefinedExp.ToString">
            <summary>
            Returns a string representation of this expression.
            </summary>
            <returns>A string representation of this expression.</returns>
        </member>
        <member name="T:PDDLParser.Exp.Logical.UndefinedLogicalExp">
            <summary>
            This class represents an undefined logical expression.
            </summary>
        </member>
        <member name="F:PDDLParser.Exp.Logical.UndefinedLogicalExp.s_undefinedExp">
            <summary>
            The immutable undefined logical expression.
            </summary>
        </member>
        <member name="M:PDDLParser.Exp.Logical.UndefinedLogicalExp.#ctor">
            <summary>
            Creates a new undefined logical expression. Note that this constructor is private.
            </summary>
        </member>
        <member name="M:PDDLParser.Exp.Logical.UndefinedLogicalExp.Evaluate(PDDLParser.World.IReadOnlyOpenWorld,PDDLParser.Exp.LocalBindings)">
            <summary>
            Evaluates this logical expression in the specified open world.
            </summary>
            <param name="world">The evaluation world.</param>
            <param name="bindings">A set of variable bindings.</param>
            <returns>Undefined.</returns>
        </member>
        <member name="M:PDDLParser.Exp.Logical.UndefinedLogicalExp.EvaluateWithImmediateShortCircuit(PDDLParser.World.IReadOnlyOpenWorld,PDDLParser.Exp.LocalBindings)">
            <summary>
            Evaluates this logical expression in the specified open world.
            </summary>
            <param name="world">The evaluation world.</param>
            <param name="bindings">A set of variable bindings.</param>
            <returns>Undefined.</returns>
        </member>
        <member name="M:PDDLParser.Exp.Logical.UndefinedLogicalExp.Simplify(PDDLParser.World.IReadOnlyOpenWorld,PDDLParser.Exp.LocalBindings)">
            <summary>
            Simplifies this logical expression by evaluating its known expression parts.
            </summary>
            <param name="world">The evaluation world.</param>
            <param name="bindings">A set of variable bindings.</param>
            <returns>Undefined.</returns>
        </member>
        <member name="M:PDDLParser.Exp.Logical.UndefinedLogicalExp.Evaluate(PDDLParser.World.IReadOnlyClosedWorld,PDDLParser.Exp.LocalBindings)">
            <summary>
            Evaluates this logical expression in the specified closed world.
            </summary>
            <param name="world">The evaluation world.</param>
            <param name="bindings">A set of variable bindings.</param>
            <returns>Undefined.</returns>
        </member>
        <member name="M:PDDLParser.Exp.Logical.UndefinedLogicalExp.EvaluateWithImmediateShortCircuit(PDDLParser.World.IReadOnlyClosedWorld,PDDLParser.Exp.LocalBindings)">
            <summary>
            Evaluates this logical expression in the specified closed world.
            </summary>
            <param name="world">The evaluation world.</param>
            <param name="bindings">A set of variable bindings.</param>
            <returns>Undefined.</returns>
        </member>
        <member name="M:PDDLParser.Exp.Logical.UndefinedLogicalExp.EnumerateAllSatisfyingWorlds">
            <summary>
            Enumerates all the worlds within which this logical expression evaluates to true.
            This method is used to support the goal modality expressions.
            Note that no world can satisfy a false expression.
            </summary>
            <returns>The empty set.</returns>
        </member>
        <member name="M:PDDLParser.Exp.Logical.UndefinedLogicalExp.Progress(PDDLParser.World.IReadOnlyDurativeClosedWorld,PDDLParser.Exp.LocalBindings)">
            <summary>
            Evaluates the progression of this constraint expression in the next worlds.
            </summary>
            <param name="world">The current world.</param>
            <param name="bindings">A set of variable bindings.</param>
            <returns>Undefined.</returns>
        </member>
        <member name="M:PDDLParser.Exp.Logical.UndefinedLogicalExp.EvaluateIdle(PDDLParser.World.IReadOnlyDurativeClosedWorld,PDDLParser.Exp.LocalBindings)">
            <summary>
            Evaluates this constraint expression in an idle world, i.e. a world which
            won't be modified by further updates.
            </summary>
            <param name="idleWorld">The (idle) evaluation world.</param>
            <param name="bindings">A set of variable bindings.</param>
            <returns>Undefined.</returns>
        </member>
        <member name="P:PDDLParser.Exp.Logical.UndefinedLogicalExp.Undefined">
            <summary>
            The undefined logical expression.
            </summary>
        </member>
        <member name="T:PDDLParser.Exp.Numeric.UndefinedNumericExp">
            <summary>
            This class represents an undefined numeric expression.
            </summary>
        </member>
        <member name="F:PDDLParser.Exp.Numeric.UndefinedNumericExp.s_undefinedExp">
            <summary>
            The immutable undefined numeric expression.
            </summary>
        </member>
        <member name="M:PDDLParser.Exp.Numeric.UndefinedNumericExp.#ctor">
            <summary>
            Creates a new undefined numeric expression. Note that this constructor is private.
            </summary>
        </member>
        <member name="M:PDDLParser.Exp.Numeric.UndefinedNumericExp.Evaluate(PDDLParser.World.IReadOnlyOpenWorld,PDDLParser.Exp.LocalBindings)">
            <summary>
            Evaluates this numeric expression in the specified open world.
            </summary>
            <param name="world">The evaluation world.</param>
            <param name="bindings">A set of variable bindings.</param>
            <returns>Undefined.</returns>
        </member>
        <member name="M:PDDLParser.Exp.Numeric.UndefinedNumericExp.Simplify(PDDLParser.World.IReadOnlyOpenWorld,PDDLParser.Exp.LocalBindings)">
            <summary>
            Simplifies this numeric expression by evaluating its known expression parts.
            </summary>
            <param name="world">The evaluation world.</param>
            <param name="bindings">A set of variable bindings.</param>
            <returns>Undefined.</returns>
        </member>
        <member name="M:PDDLParser.Exp.Numeric.UndefinedNumericExp.Evaluate(PDDLParser.World.IReadOnlyClosedWorld,PDDLParser.Exp.LocalBindings)">
            <summary>
            Evaluates this numeric expression in the specified closed world.
            </summary>
            <param name="world">The evaluation world.</param>
            <param name="bindings">A set of variable bindings.</param>
            <returns>Undefined.</returns>
        </member>
        <member name="P:PDDLParser.Exp.Numeric.UndefinedNumericExp.Undefined">
            <summary>
            The undefined numeric expression.
            </summary>
        </member>
        <member name="T:PDDLParser.Exp.Term.UndefinedTerm">
            <summary>
            This class represents an undefined term.
            </summary>
        </member>
        <member name="F:PDDLParser.Exp.Term.UndefinedTerm.s_undefinedTerm">
            <summary>
            The immutable undefined term.
            </summary>
        </member>
        <member name="M:PDDLParser.Exp.Term.UndefinedTerm.#ctor">
            <summary>
            Creates a new undefined term. Note that this constructor is private.
            </summary>
        </member>
        <member name="M:PDDLParser.Exp.Term.UndefinedTerm.GetTypeSet">
            <summary>
            Returns the typeset of this term.
            </summary>
            <returns>This undefined typeset.</returns>
        </member>
        <member name="M:PDDLParser.Exp.Term.UndefinedTerm.Evaluate(PDDLParser.World.IReadOnlyOpenWorld,PDDLParser.Exp.LocalBindings)">
            <summary>
            Evaluates this term in the specified open world.
            </summary>
            <param name="world">The evaluation world.</param>
            <param name="bindings">A set of variable bindings.</param>
            <returns>Undefined.</returns>
        </member>
        <member name="M:PDDLParser.Exp.Term.UndefinedTerm.Simplify(PDDLParser.World.IReadOnlyOpenWorld,PDDLParser.Exp.LocalBindings)">
            <summary>
            Simplifies this term by evaluating its known expression parts.
            </summary>
            <param name="world">The evaluation world.</param>
            <param name="bindings">A set of variable bindings.</param>
            <returns>Undefined.</returns>
        </member>
        <member name="M:PDDLParser.Exp.Term.UndefinedTerm.Evaluate(PDDLParser.World.IReadOnlyClosedWorld,PDDLParser.Exp.LocalBindings)">
            <summary>
            Evaluates this term in the specified closed world.
            </summary>
            <param name="world">The evaluation world.</param>
            <param name="bindings">A set of variable bindings.</param>
            <returns>Undefined.</returns>
        </member>
        <member name="M:PDDLParser.Exp.Term.UndefinedTerm.CanBeAssignedFrom(PDDLParser.Exp.ITerm)">
            <summary>
            Verifies whether the specified term can be assigned to this term, 
            i.e. if the other term's domain is a subset of this term's domain.
            </summary>
            <param name="term">The other term.</param>
            <returns>True if the types are compatible, false otherwise.</returns>
        </member>
        <member name="M:PDDLParser.Exp.Term.UndefinedTerm.IsComparableTo(PDDLParser.Exp.ITerm)">
            <summary>
            Verifies whether the specified term can be compared to this term,
            i.e. if their domain overlap.
            </summary>
            <param name="term">The other term</param>
            <returns>True if the types can be compared, false otherwise.</returns>
        </member>
        <member name="P:PDDLParser.Exp.Term.UndefinedTerm.Undefined">
            <summary>
            The undefined term.
            </summary>
        </member>
        <member name="T:PDDLParser.Exp.Struct.TimeValue">
            <summary>
            Represents a bounded time value, to be used in an interval.
            </summary>
        </member>
        <member name="F:PDDLParser.Exp.Struct.TimeValue.m_timeValue">
            <summary>
            The actual time value of the bound.
            </summary>
        </member>
        <member name="F:PDDLParser.Exp.Struct.TimeValue.m_isIntervalOpen">
            <summary>
            Whether the interval is open or closed.
            </summary>
        </member>
        <member name="F:PDDLParser.Exp.Struct.TimeValue.m_isLowerBound">
            <summary>
            Whether this is the lower or the upper bound of an interval.
            </summary>
        </member>
        <member name="M:PDDLParser.Exp.Struct.TimeValue.#ctor(System.Double,System.Boolean,System.Boolean)">
            <summary>
            Creates a new bounded time value.
            </summary>
            <remarks>When creating an infinite bounded value, it must be open.</remarks>
            <param name="time">The time of the bound.</param>
            <param name="isOpen">Whether the interval is open.</param>
            <param name="isLowerBound">Whether this is a lower bound.</param>
        </member>
        <member name="M:PDDLParser.Exp.Struct.TimeValue.Min(PDDLParser.Exp.Struct.TimeValue,PDDLParser.Exp.Struct.TimeValue)">
            <summary>
            Returns the minimum of two bounded time values. This takes into account their
            actual time, as well as whether they are open and whether they are lower bounds.
            </summary>
            <remarks>
            <para>
            Two bounded time values with the same time are not necessarily equivalent. For example,
            A closed upper bound time value of 5 will be considered greater than an open upper bound
            time value of 5. This is because the actual limit of the open upper bound is slightly less
            than five, whereas the limit of the closed upper bound is exactly five.
            </para>
            <para>
            Also note that, while two values may be regarded as the same when using <c>Min</c>,
            they may not be considered equal. More specifically, if both bounds are closed, <c>Min</c>
            may return either, but they might not be equal (e.g. one is a lower bound, the other, an upper bound).
            </para>
            </remarks>
            <param name="value1">The first bounded time value to compare.</param>
            <param name="value2">The second time value to compare.</param>
            <returns>The smallest bounded time value.</returns>
        </member>
        <member name="M:PDDLParser.Exp.Struct.TimeValue.IsLowerThan(System.Double)">
            <summary>
            Returns whether the bounded time value is lower than the given time.
            </summary>
            <param name="time">The time.</param>
            <returns>True if the bounded time value is lower than the given time.</returns>
        </member>
        <member name="M:PDDLParser.Exp.Struct.TimeValue.IsGreaterThan(System.Double)">
            <summary>
            Returns whether the bounded time value is greater than the given time.
            </summary>
            <param name="time">The time.</param>
            <returns>True if the bounded time value is greater than the given time.</returns>
        </member>
        <member name="M:PDDLParser.Exp.Struct.TimeValue.GetHashCode">
            <summary>
            Returns the hash code of this bounded time value.
            </summary>
            <returns>The hash code of this bounded time value.</returns>
        </member>
        <member name="M:PDDLParser.Exp.Struct.TimeValue.ToString">
            <summary>
            Returns a string representation of this bounded time value.
            </summary>
            <returns>A string representation of this bounded time value.</returns>
        </member>
        <member name="M:PDDLParser.Exp.Struct.TimeValue.CompareTo(PDDLParser.Exp.Struct.TimeValue)">
            <summary>
            Compares this bounded time value with another bounded time value.
            </summary>
            <param name="other">The other bounded time value to compare this bounded time value to.</param>
            <returns>An integer representing the total order relation between the two bounded time values.
            </returns>
        </member>
        <member name="P:PDDLParser.Exp.Struct.TimeValue.Time">
            <summary>
            Gets or sets the actual time value of the bound.
            </summary>
        </member>
        <member name="P:PDDLParser.Exp.Struct.TimeValue.IsOpen">
            <summary>
            Gets or sets whether the interval is open or closed.
            </summary>
        </member>
        <member name="P:PDDLParser.Exp.Struct.TimeValue.IsLowerBound">
            <summary>
            Gets whether this is a lower bound.
            </summary>
            <remarks><c>IsLowerBound == !<see cref="P:PDDLParser.Exp.Struct.TimeValue.IsUpperBound"/></c></remarks>
            <seealso cref="P:PDDLParser.Exp.Struct.TimeValue.IsUpperBound"/>
        </member>
        <member name="P:PDDLParser.Exp.Struct.TimeValue.IsUpperBound">
            <summary>
            Gets whether this is an upper bound.
            </summary>
            <remarks><c>IsUpperBound == !<see cref="P:PDDLParser.Exp.Struct.TimeValue.IsLowerBound"/></c></remarks>
            <seealso cref="P:PDDLParser.Exp.Struct.TimeValue.IsLowerBound"/>
        </member>
        <member name="T:PDDLParser.Exp.Struct.TimeInterval">
            <summary>
            Represents a time interval, which can have both ends open or closed, finite or infinite.
            </summary>
        </member>
        <member name="F:PDDLParser.Exp.Struct.TimeInterval.m_lowerBound">
            <summary>
            The lower bound of the interval.
            </summary>
        </member>
        <member name="F:PDDLParser.Exp.Struct.TimeInterval.m_upperBound">
            <summary>
            The upper bound of the interval.
            </summary>
        </member>
        <member name="M:PDDLParser.Exp.Struct.TimeInterval.#ctor(System.Double,System.Boolean,System.Double,System.Boolean)">
            <summary>
            Creates a new time interval.
            </summary>
            <param name="lowerTimeBound">The lower bound time.</param>
            <param name="lowerBoundOpen">Whether the lower bound is open.</param>
            <param name="upperTimeBound">The upper bound time.</param>
            <param name="upperBoundOpen">Whether the upper bound is open.</param>
            <remarks>When using infinite values, the bound must be open.</remarks>
        </member>
        <member name="M:PDDLParser.Exp.Struct.TimeInterval.IsTimeLowerThanInterval(System.Double)">
            <summary>
            Returns whether the given is before the interval.
            </summary>
            <param name="time">The time.</param>
            <returns>Whether the given is before the interval.</returns>
        </member>
        <member name="M:PDDLParser.Exp.Struct.TimeInterval.IsTimeGreaterThanInterval(System.Double)">
            <summary>
            Returns whether the given is after the interval.
            </summary>
            <param name="time">The time.</param>
            <returns>Whether the given is after the interval.</returns>
        </member>
        <member name="M:PDDLParser.Exp.Struct.TimeInterval.IsTimeInInterval(System.Double)">
            <summary>
            Returns whether the given is in the interval.
            </summary>
            <param name="time">The time.</param>
            <returns>Whether the given is in the interval.</returns>
        </member>
        <member name="M:PDDLParser.Exp.Struct.TimeInterval.CompareTimeToInterval(System.Double)">
            <summary>
            Compares the time with the interval.
            </summary>
            <param name="time">The time.</param>
            <returns>
            An integer representing the total order relation between the two worlds.
            A value smaller than zero indicates that the time is before the interval.
            A value of zero indicates that the time is in the interval.
            A value greater than zero indicates that the time is after the interval.
            </returns>
        </member>
        <member name="M:PDDLParser.Exp.Struct.TimeInterval.AddTime(System.Double)">
            <summary>
            Returns a copy of this time interval with the added time.
            </summary>
            <param name="time">The time to add to the lower and upper bounds.</param>
            <returns>A copy of this time interval with the added time.</returns>
        </member>
        <member name="M:PDDLParser.Exp.Struct.TimeInterval.GetHashCode">
            <summary>
            Returns the hash code of this time interval.
            </summary>
            <returns>The hash code of this time interval.</returns>
        </member>
        <member name="M:PDDLParser.Exp.Struct.TimeInterval.ToString">
            <summary>
            Returns a string representation of this time interval.
            </summary>
            <returns>A string representation of this time interval.</returns>
        </member>
        <member name="M:PDDLParser.Exp.Struct.TimeInterval.CompareTo(PDDLParser.Exp.Struct.TimeInterval)">
            <summary>
            Compares this time interval with another time interval.
            </summary>
            <param name="other">The other time interval to compare this time interval to.</param>
            <returns>An integer representing the total order relation between the two time intervals.
            </returns>
        </member>
        <member name="P:PDDLParser.Exp.Struct.TimeInterval.LowerBound">
            <summary>
            Gets the lower bound of the interval.
            </summary>
        </member>
        <member name="P:PDDLParser.Exp.Struct.TimeInterval.UpperBound">
            <summary>
            Gets the upper bound of the interval.
            </summary>
        </member>
        <member name="T:PDDLParser.Exp.Struct.FuzzyDouble">
            <summary>
            A FuzzyDouble represents a double value which may be undefined or unknown.
            </summary>
        </member>
        <member name="F:PDDLParser.Exp.Struct.FuzzyDouble.Unknown">
            <summary>
            FuzzyDouble unknown value.
            </summary>
        </member>
        <member name="F:PDDLParser.Exp.Struct.FuzzyDouble.Undefined">
            <summary>
            FuzzyDouble undefined value.
            </summary>
        </member>
        <member name="F:PDDLParser.Exp.Struct.FuzzyDouble.m_value">
            <summary>
            The value of this FuzzyDouble.
            </summary>
        </member>
        <member name="F:PDDLParser.Exp.Struct.FuzzyDouble.m_status">
            <summary>
            Indicates the status of this Double.
            </summary>
        </member>
        <member name="M:PDDLParser.Exp.Struct.FuzzyDouble.#ctor(System.Double)">
            <summary>
            Creates a new FuzzyDouble with the specified double value.
            </summary>
            <param name="value">The new FuzzyDouble's value.</param>
        </member>
        <member name="M:PDDLParser.Exp.Struct.FuzzyDouble.#ctor(PDDLParser.Exp.Struct.Double)">
            <summary>
            Creates a new FuzzyDouble with the specified Double value.
            </summary>
            <param name="value">The new FuzzyDouble's value.</param>
        </member>
        <member name="M:PDDLParser.Exp.Struct.FuzzyDouble.#ctor(PDDLParser.Exp.Struct.FuzzyDouble.State,System.Double)">
            <summary>
            Creates a new FuzzyDouble with the specified status and double value.
            </summary>
            <param name="status">The new Double's status.</param>
            <param name="value">The new Double's value.</param>
        </member>
        <member name="M:PDDLParser.Exp.Struct.FuzzyDouble.FuzzyDoubleToDouble(PDDLParser.Exp.Struct.FuzzyDouble)">
            <summary>
            Returns the Double value corresponding to the specified FuzzyDouble value.
            </summary>
            <param name="value">A FuzzyDouble value.</param>
            <returns>The Double value corresponding to the specified FuzzyDouble value.</returns>
        </member>
        <member name="M:PDDLParser.Exp.Struct.FuzzyDouble.ToDoubleValue">
            <summary>
            Returns the corresponding Double value of this FuzzyDouble.
            Note that FuzzyDouble.Unknown cannot be converted to Double and thus throws 
            an UnknownEvaluationResultException.
            </summary>
            <returns>The corresponding Double value of this FuzzyDouble.</returns>
        </member>
        <member name="M:PDDLParser.Exp.Struct.FuzzyDouble.op_LessThan(PDDLParser.Exp.Struct.FuzzyDouble,PDDLParser.Exp.Struct.FuzzyDouble)">
            <summary>
            Checks whether a given FuzzyDouble is strictly less than another given FuzzyDouble.
            This comparison returns Bool.Undefined if at least one of two operands is undefined.
            </summary>
            <param name="d1">The first operand.</param>
            <param name="d2">The second operand.</param>
            <returns>Bool.Undefined if at least one of two operands is undefined, else
            Bool.True if the first operand is strictly less than the second operand.</returns>
        </member>
        <member name="M:PDDLParser.Exp.Struct.FuzzyDouble.op_LessThanOrEqual(PDDLParser.Exp.Struct.FuzzyDouble,PDDLParser.Exp.Struct.FuzzyDouble)">
            <summary>
            Checks whether a given FuzzyDouble is less than or equal to another given FuzzyDouble.
            This comparison returns Bool.Undefined if at least one of two operands is undefined.
            </summary>
            <param name="d1">The first operand.</param>
            <param name="d2">The second operand.</param>
            <returns>Bool.Undefined if at least one of two operands is undefined, else
            Bool.True if the first operand is less than or equal to the second operand.</returns>
        </member>
        <member name="M:PDDLParser.Exp.Struct.FuzzyDouble.op_GreaterThan(PDDLParser.Exp.Struct.FuzzyDouble,PDDLParser.Exp.Struct.FuzzyDouble)">
            <summary>
            Checks whether a given FuzzyDouble is strictly greater than another given FuzzyDouble.
            This comparison returns Bool.Undefined if at least one of two operands is undefined.
            </summary>
            <param name="d1">The first operand.</param>
            <param name="d2">The second operand.</param>
            <returns>Bool.Undefined if at least one of two operands is undefined, else
            Bool.True if the first operand is strictly greater than the second operand.</returns>
        </member>
        <member name="M:PDDLParser.Exp.Struct.FuzzyDouble.op_GreaterThanOrEqual(PDDLParser.Exp.Struct.FuzzyDouble,PDDLParser.Exp.Struct.FuzzyDouble)">
            <summary>
            Checks whether a given FuzzyDouble is greater than or equal to another given FuzzyDouble.
            This comparison returns Bool.Undefined if at least one of two operands is undefined.
            </summary>
            <param name="d1">The first operand.</param>
            <param name="d2">The second operand.</param>
            <returns>Bool.Undefined if at least one of two operands is undefined, else
            Bool.True if the first operand is greater than or equal to the second operand.</returns>
        </member>
        <member name="M:PDDLParser.Exp.Struct.FuzzyDouble.op_Equality(PDDLParser.Exp.Struct.FuzzyDouble,PDDLParser.Exp.Struct.FuzzyDouble)">
            <summary>
            Checks whether a given FuzzyDouble is equal to another given FuzzyDouble.
            This comparison returns Bool.Undefined if at least one of two operands is undefined.
            </summary>
            <param name="d1">The first operand.</param>
            <param name="d2">The second operand.</param>
            <returns>Bool.Undefined if at least one of two operands is undefined, else
            Bool.True if the first operand is equal to the second operand.</returns>
        </member>
        <member name="M:PDDLParser.Exp.Struct.FuzzyDouble.op_Inequality(PDDLParser.Exp.Struct.FuzzyDouble,PDDLParser.Exp.Struct.FuzzyDouble)">
            <summary>
            Checks whether a given FuzzyDouble is different from another given FuzzyDouble.
            This comparison returns Bool.Undefined if at least one of two operands is undefined.
            </summary>
            <param name="d1">The first operand.</param>
            <param name="d2">The second operand.</param>
            <returns>Bool.Undefined if at least one of two operands is undefined, else
            Bool.True if the first operand is different from the second operand.</returns>
        </member>
        <member name="M:PDDLParser.Exp.Struct.FuzzyDouble.op_UnaryNegation(PDDLParser.Exp.Struct.FuzzyDouble)">
            <summary>
            Performs the negation of a given FuzzyDouble.
            This operation returns an undefined value if the given FuzzyDouble is undefined.
            </summary>
            <param name="d">The value to negate.</param>
            <returns>Double.Undefined if the operand is undefined, or else the negated value.</returns>
        </member>
        <member name="M:PDDLParser.Exp.Struct.FuzzyDouble.op_Addition(PDDLParser.Exp.Struct.FuzzyDouble,PDDLParser.Exp.Struct.FuzzyDouble)">
            <summary>
            Adds two <see cref="T:PDDLParser.Exp.Struct.FuzzyDouble"/> instances together.
            </summary>
            <param name="d1">The first operand.</param>
            <param name="d2">The second operand.</param>
            <returns><see cref="F:PDDLParser.Exp.Struct.FuzzyDouble.Undefined"/> if one operand is undefined, <see cref="F:PDDLParser.Exp.Struct.FuzzyDouble.Unknown"/> if
            one operand is unknown, or a new <see cref="T:PDDLParser.Exp.Struct.FuzzyDouble"/> whose value is the sum of the operands' values.</returns>
        </member>
        <member name="M:PDDLParser.Exp.Struct.FuzzyDouble.Equals(System.Object)">
            <summary>
            Returns true if this FuzzyDouble is equal to another object.
            </summary>
            <param name="obj">The other object to test for equality.</param>
            <returns>True if this FuzzyDouble is equal to the other object.</returns>
        </member>
        <member name="M:PDDLParser.Exp.Struct.FuzzyDouble.GetHashCode">
            <summary>
            Returns the hashcode of this FuzzyDouble.
            </summary>
            <returns>The hashcode of this FuzzyDouble.</returns>
        </member>
        <member name="M:PDDLParser.Exp.Struct.FuzzyDouble.ToString">
            <summary>
            Returns a string representation of the FuzzyDouble value.
            </summary>
            <returns>A string representation of the FuzzyDouble value.</returns>
        </member>
        <member name="P:PDDLParser.Exp.Struct.FuzzyDouble.Status">
            <summary>
            Returns the status of this FuzzyDouble.
            </summary>
        </member>
        <member name="P:PDDLParser.Exp.Struct.FuzzyDouble.Value">
            <summary>
            Returns the inner double value of this FuzzyDouble.
            The value should only be accessed if this FuzzyDouble is defined.
            </summary>
        </member>
        <member name="T:PDDLParser.Exp.Struct.FuzzyDouble.State">
            <summary>
            The internal status of this FuzzyDouble, which indicates whether it is defined,
            unknown, or undefined.
            </summary>
        </member>
        <member name="F:PDDLParser.Exp.Struct.FuzzyDouble.State.Defined">
            <summary>
            Indicates that this FuzzyDouble is defined, and thus its internal double value
            can be accessed.
            </summary>
        </member>
        <member name="F:PDDLParser.Exp.Struct.FuzzyDouble.State.Unknown">
            <summary>
            Indicates that this FuzzyDouble is unknown.
            </summary>
        </member>
        <member name="F:PDDLParser.Exp.Struct.FuzzyDouble.State.Undefined">
            <summary>
            Indicates that this FuzzyDouble is undefined.
            </summary>
        </member>
        <member name="T:PDDLParser.Exp.Metric.ForallConstraintPrefExp">
            <summary>
            Represents a quantified constraint preference expression of the PDDL language, i.e.
            a quantified preference that lies in a domain or a problem's constraints.
            </summary>
        </member>
        <member name="T:PDDLParser.Exp.Metric.AbstractForallPrefExp">
            <summary>
            Represents the common part of all quantified preference expressions of the PDDL language.
            </summary>
        </member>
        <member name="T:PDDLParser.Exp.IPrefExp">
            <summary>
            Represents the basic interface of preferences. Note that these are not evaluable.
            </summary>
        </member>
        <member name="M:PDDLParser.Exp.IPrefExp.GetOriginalExp">
            <summary>
            Returns the body of the preference.
            </summary>
            <returns>The body of the preference.</returns>
        </member>
        <member name="P:PDDLParser.Exp.IPrefExp.Unnamed">
            <summary>
            Returns whether the preference is unnamed.
            </summary>
            <remarks>
            An unnamed preference still has a name; however, this name is unique and not parsable,
            hence there will be no conflicts with other preference names.
            </remarks>
        </member>
        <member name="P:PDDLParser.Exp.IPrefExp.Name">
            <summary>
            Returns the name of the preferences.
            </summary>
            <remarks>
            This may be an unparsable name if the preference is unnamed.
            </remarks>
        </member>
        <member name="F:PDDLParser.Exp.Metric.AbstractForallPrefExp.m_sortedVars">
            <summary>
            The set of quantified variables contained in this quantified preference expression.
            They are kept in a list to allow efficient comparisons between two quantified expressions.
            </summary>
        </member>
        <member name="F:PDDLParser.Exp.Metric.AbstractForallPrefExp.m_prefExp">
            <summary>
            The wrapped preference expression used as a base.
            </summary>
        </member>
        <member name="M:PDDLParser.Exp.Metric.AbstractForallPrefExp.#ctor(System.Collections.Generic.HashSet{PDDLParser.Exp.Term.ObjectParameterVariable},PDDLParser.Exp.IPrefExp)">
            <summary>
            Creates a new quantified preference expression.
            </summary>
            <param name="vars">The set of variables quantifying the preference expression.</param>
            <param name="pref">The quantified preference expression.</param>
        </member>
        <member name="M:PDDLParser.Exp.Metric.AbstractForallPrefExp.GetOriginalExp">
            <summary>
            Returns the body of the preference.
            </summary>
            <returns>The body of the preference.</returns>
        </member>
        <member name="M:PDDLParser.Exp.Metric.AbstractForallPrefExp.IsGround">
            <summary>
            Returns true if the preference is ground, i.e. it does not contain any variables.
            </summary>
            <returns>Whether the preference is ground.</returns>
        </member>
        <member name="M:PDDLParser.Exp.Metric.AbstractForallPrefExp.GetFreeVariables">
            <summary>
            Returns the free variables in this preference.
            </summary>
            <returns>The free variables in this preference.</returns>
        </member>
        <member name="M:PDDLParser.Exp.Metric.AbstractForallPrefExp.Equals(System.Object)">
            <summary>
            Returns true if this preference is equal to a specified object.
            </summary>
            <param name="obj">Object to test for equality.</param>
            <returns>True if this preference is equal to the specified objet.</returns>
        </member>
        <member name="M:PDDLParser.Exp.Metric.AbstractForallPrefExp.GetHashCode">
            <summary>
            Returns the hash code of this preference.
            </summary>
            <returns>The hash code of this preference.</returns>
        </member>
        <member name="M:PDDLParser.Exp.Metric.AbstractForallPrefExp.ToString">
            <summary>
            Returns a string representation of this preference.
            </summary>
            <returns>A string representation of this preference.</returns>
        </member>
        <member name="M:PDDLParser.Exp.Metric.AbstractForallPrefExp.ToTypedString">
            <summary>
            Returns a typed string of this preference.
            </summary>
            <returns>A typed string representation of this preference.</returns>
        </member>
        <member name="P:PDDLParser.Exp.Metric.AbstractForallPrefExp.Unnamed">
            <summary>
            Returns whether the preference is unnamed.
            </summary>
            <seealso cref="P:PDDLParser.Exp.IPrefExp.Unnamed"/>
        </member>
        <member name="P:PDDLParser.Exp.Metric.AbstractForallPrefExp.Name">
            <summary>
            Returns the name of the preferences.
            </summary>
            <seealso cref="P:PDDLParser.Exp.IPrefExp.Name"/>
        </member>
        <member name="T:PDDLParser.Exp.IConstraintPrefExp">
            <summary>
            Represents a constraint preference (i.e. a preference that is in the :constraints part of a domain or problem).
            <remarks>
            Constraint preferences create unparsable dummy literals as a way to determine whether a preference was violated.
            If a preference's constraint progresses or evaluates to false, the corresponding literal is set to true. The
            metric's "is-violated" modalities then count the number of these literals set to true in order to compute their
            value.
            </remarks>
            </summary>
        </member>
        <member name="M:PDDLParser.Exp.IConstraintPrefExp.GetDummyAtomicFormula">
            <summary>
            Returns the preference's corresponding dummy literal, which is used to determine whether the preference has been violated.
            </summary>
            <returns>The preference's corresponding violation literal.</returns>
        </member>
        <member name="M:PDDLParser.Exp.IConstraintPrefExp.GetViolationEffect">
            <summary>
            Returns the effect which must be applied to the world if the preference is violated.
            </summary>
            <remarks>This is only setting a given literal to true.</remarks>
            <remarks>It is an error to call this on a quantified preference. Call <see cref="M:PDDLParser.Exp.IConstraintPrefExp.GetAllSubstitutedConstraintPreferences"/> first.</remarks>
            <returns>The effect to apply to the world upon violation of the preference.</returns>
        </member>
        <member name="M:PDDLParser.Exp.IConstraintPrefExp.GetAllSubstitutedConstraintPreferences">
            <summary>
            Returns all substituted preferences, in their simplest form. This will therefore expand preference quantifiers.
            </summary>
            <returns>All substituted and grounded preferences.</returns>
            <remarks>An unquantified preference returns only itself.</remarks>
        </member>
        <member name="P:PDDLParser.Exp.IConstraintPrefExp.Constraint">
            <summary>
            Gets or sets the constraint of the preference (i.e. the preference's "body"). Setting this property should only be used in
            order to update the preference's constraint with its progressed form.
            </summary>
        </member>
        <member name="M:PDDLParser.Exp.Metric.ForallConstraintPrefExp.#ctor(System.Collections.Generic.HashSet{PDDLParser.Exp.Term.ObjectParameterVariable},PDDLParser.Exp.IConstraintPrefExp)">
            <summary>
            Creates a new quantified constraint preference expression.
            </summary>
            <param name="vars">The set of variables quantifying the preference expression.</param>
            <param name="pref">The quantified constraint preference expression.</param>
        </member>
        <member name="M:PDDLParser.Exp.Metric.ForallConstraintPrefExp.GetDummyAtomicFormula">
            <summary>
            Returns the preference's corresponding dummy literal, which is used to determine whether the preference has been violated.
            </summary>
            <returns>The preference's corresponding violation literal.</returns>
        </member>
        <member name="M:PDDLParser.Exp.Metric.ForallConstraintPrefExp.GetViolationEffect">
            <summary>
            It is an error to call this on a quantified preference expression.
            Call <see cref="M:PDDLParser.Exp.Metric.ForallConstraintPrefExp.GetAllSubstitutedConstraintPreferences"/> first.
            </summary>
            <returns>Throws an exception.</returns>
            <exception cref="T:System.NotSupportedException">Thrown because this is not supported. Call <see cref="M:PDDLParser.Exp.Metric.ForallConstraintPrefExp.GetAllSubstitutedConstraintPreferences"/> first.</exception>
        </member>
        <member name="M:PDDLParser.Exp.Metric.ForallConstraintPrefExp.GetAllSubstitutedConstraintPreferences">
            <summary>
            Returns all substituted preferences, in their simplest form. This will therefore expand preference quantifiers.
            </summary>
            <returns>All substituted and grounded preferences.</returns>
        </member>
        <member name="M:PDDLParser.Exp.Metric.ForallConstraintPrefExp.GetPreference">
            <summary>
            Gets the wrapped constraint preference.
            </summary>
            <returns>The wrapped constraint preference.</returns>
        </member>
        <member name="P:PDDLParser.Exp.Metric.ForallConstraintPrefExp.Constraint">
            <summary>
            Gets or sets the constraint of the preference (i.e. the preference's "body"). Setting this property should only be used in
            order to update the preference's constraint with its progressed form.
            </summary>
        </member>
        <member name="T:PDDLParser.Exp.Logical.TrueExp">
            <summary>
            This class represents a true logical expression, i.e. a tautology.
            </summary>
        </member>
        <member name="F:PDDLParser.Exp.Logical.TrueExp.s_trueExp">
            <summary>
            The immutable true expression.
            </summary>
        </member>
        <member name="M:PDDLParser.Exp.Logical.TrueExp.#ctor">
            <summary>
            Creates a new true expression. Note that this constructor is private.
            </summary>
        </member>
        <member name="M:PDDLParser.Exp.Logical.TrueExp.Evaluate(PDDLParser.World.IReadOnlyOpenWorld,PDDLParser.Exp.LocalBindings)">
            <summary>
            Evaluates this logical expression in the specified open world.
            </summary>
            <param name="world">The evaluation world.</param>
            <param name="bindings">A set of variable bindings.</param>
            <returns>True.</returns>
        </member>
        <member name="M:PDDLParser.Exp.Logical.TrueExp.EvaluateWithImmediateShortCircuit(PDDLParser.World.IReadOnlyOpenWorld,PDDLParser.Exp.LocalBindings)">
            <summary>
            Evaluates this logical expression in the specified open world.
            </summary>
            <param name="world">The evaluation world.</param>
            <param name="bindings">A set of variable bindings.</param>
            <returns>True.</returns>
        </member>
        <member name="M:PDDLParser.Exp.Logical.TrueExp.Simplify(PDDLParser.World.IReadOnlyOpenWorld,PDDLParser.Exp.LocalBindings)">
            <summary>
            Simplifies this logical expression by evaluating its known expression parts.
            </summary>
            <param name="world">The evaluation world.</param>
            <param name="bindings">A set of variable bindings.</param>
            <returns>True.</returns>
        </member>
        <member name="M:PDDLParser.Exp.Logical.TrueExp.Evaluate(PDDLParser.World.IReadOnlyClosedWorld,PDDLParser.Exp.LocalBindings)">
            <summary>
            Evaluates this logical expression in the specified closed world.
            </summary>
            <param name="world">The evaluation world.</param>
            <param name="bindings">A set of variable bindings.</param>
            <returns>True.</returns>
        </member>
        <member name="M:PDDLParser.Exp.Logical.TrueExp.EvaluateWithImmediateShortCircuit(PDDLParser.World.IReadOnlyClosedWorld,PDDLParser.Exp.LocalBindings)">
            <summary>
            Evaluates this logical expression in the specified closed world.
            </summary>
            <param name="world">The evaluation world.</param>
            <param name="bindings">A set of variable bindings.</param>
            <returns>True.</returns>
        </member>
        <member name="M:PDDLParser.Exp.Logical.TrueExp.EnumerateAllSatisfyingWorlds">
            <summary>
            Enumerates all the worlds within which this logical expression evaluates to true.
            This method is used to support the goal modality expressions.
            Note that no world can satisfy a false expression.
            </summary>
            <returns>All worlds</returns>
        </member>
        <member name="M:PDDLParser.Exp.Logical.TrueExp.Progress(PDDLParser.World.IReadOnlyDurativeClosedWorld,PDDLParser.Exp.LocalBindings)">
            <summary>
            Evaluates the progression of this constraint expression in the next worlds.
            </summary>
            <param name="world">The current world.</param>
            <param name="bindings">A set of variable bindings.</param>
            <returns>True.</returns>
        </member>
        <member name="M:PDDLParser.Exp.Logical.TrueExp.EvaluateIdle(PDDLParser.World.IReadOnlyDurativeClosedWorld,PDDLParser.Exp.LocalBindings)">
            <summary>
            Evaluates this constraint expression in an idle world, i.e. a world which
            won't be modified by further updates.
            </summary>
            <param name="idleWorld">The (idle) evaluation world.</param>
            <param name="bindings">A set of variable bindings.</param>
            <returns>True.</returns>
        </member>
        <member name="M:PDDLParser.Exp.Logical.TrueExp.Apply(PDDLParser.Exp.ParameterBindings)">
            <summary>
            Substitutes all occurrences of the variables that occur in this
            expression by their corresponding bindings.
            </summary>
            <param name="bindings">The bindings.</param>
            <returns>This.</returns>
        </member>
        <member name="M:PDDLParser.Exp.Logical.TrueExp.Standardize(System.Collections.Generic.IDictionary{System.String,System.String})">
            <summary>
            Standardizes all occurrences of the variables that occur in this
            expression. The IDictionary argument is used to store the variable already
            standardized. Remember that free variables are existentially quantified.
            </summary>
            <param name="images">The object that maps old variable images to the standardize
            image.</param>
            <returns>This.</returns>
        </member>
        <member name="M:PDDLParser.Exp.Logical.TrueExp.IsGround">
            <summary>
            Returns true if the expression is ground, i.e. it does not contain any variables.
            </summary>
            <returns>True.</returns>
        </member>
        <member name="M:PDDLParser.Exp.Logical.TrueExp.GetFreeVariables">
            <summary>
            Returns the free variables in this expression.
            </summary>
            <returns>The empty set.</returns>
        </member>
        <member name="M:PDDLParser.Exp.Logical.TrueExp.Clone">
            <summary>
            Returns a clone of this expression.
            </summary>
            <returns>This.</returns>
        </member>
        <member name="M:PDDLParser.Exp.Logical.TrueExp.Equals(System.Object)">
            <summary>
            Returns true if this expression is equal to a specified object.
            </summary>
            <param name="obj">Object to test for equality.</param>
            <returns>True if this expression is equal to the specified objet.</returns>
        </member>
        <member name="M:PDDLParser.Exp.Logical.TrueExp.GetHashCode">
            <summary>
            Returns the hash code of this expression.
            </summary>
            <returns>The hash code of this expression.</returns>
        </member>
        <member name="M:PDDLParser.Exp.Logical.TrueExp.ToTypedString">
            <summary>
            Returns a typed string of this expression.
            </summary>
            <returns>A typed string representation of this expression.</returns>
        </member>
        <member name="M:PDDLParser.Exp.Logical.TrueExp.ToString">
            <summary>
            Returns a string representation of this expression.
            </summary>
            <returns>A string representation of this expression.</returns>
        </member>
        <member name="P:PDDLParser.Exp.Logical.TrueExp.True">
            <summary>
            The true expression.
            </summary>
        </member>
        <member name="T:PDDLParser.Exp.Logical.AndExp">
            <summary>
            This class represents a conjunction of logical expressions.
            </summary>
        </member>
        <member name="M:PDDLParser.Exp.Logical.AndExp.#ctor(System.Collections.Generic.IEnumerable{PDDLParser.Exp.ILogicalExp})">
            <summary>
            Creates a new conjunction of logical expressions.
            </summary>
            <param name="exps">The logical expressions associated with the new conjunctive
            expression.</param>
        </member>
        <member name="M:PDDLParser.Exp.Logical.AndExp.#ctor(PDDLParser.Exp.ILogicalExp[])">
            <summary>
            Creates a new conjunction of logical expressions.
            </summary>
            <param name="exps">The logical expressions associated with the new conjunctive
            expression.</param>
        </member>
        <member name="M:PDDLParser.Exp.Logical.AndExp.Evaluate(PDDLParser.World.IReadOnlyOpenWorld,PDDLParser.Exp.LocalBindings)">
            <summary>
            Evaluates this logical expression in the specified open world.
            </summary>
            <param name="world">The evaluation world.</param>
            <param name="bindings">A set of variable bindings.</param>
            <returns>True, false, undefined, or unknown.</returns>
        </member>
        <member name="M:PDDLParser.Exp.Logical.AndExp.EvaluateWithImmediateShortCircuit(PDDLParser.World.IReadOnlyOpenWorld,PDDLParser.Exp.LocalBindings)">
            <summary>
            Evaluates this logical expression in the specified open world.
            In addition to False, Undefined and Unknown also shortcircuit conjunctions.
            In addition to True, Unknown also shortcircuits disjunctions.
            </summary>
            <param name="world">The evaluation world.</param>
            <param name="bindings">A set of variable bindings.</param>
            <returns>True, false, undefined, or unknown.</returns>
        </member>
        <member name="M:PDDLParser.Exp.Logical.AndExp.Simplify(PDDLParser.World.IReadOnlyOpenWorld,PDDLParser.Exp.LocalBindings)">
            <summary>
            Simplifies this logical expression by evaluating its known expression parts.
            </summary>
            <param name="world">The evaluation world.</param>
            <param name="bindings">A set of variable bindings.</param>
            <returns>True, false, undefined, or the simplified expression.</returns>
        </member>
        <member name="M:PDDLParser.Exp.Logical.AndExp.Evaluate(PDDLParser.World.IReadOnlyClosedWorld,PDDLParser.Exp.LocalBindings)">
            <summary>
            Evaluates this logical expression in the specified closed world.
            </summary>
            <param name="world">The evaluation world.</param>
            <param name="bindings">A set of variable bindings.</param>
            <returns>True, false, or undefined.</returns>
        </member>
        <member name="M:PDDLParser.Exp.Logical.AndExp.EvaluateWithImmediateShortCircuit(PDDLParser.World.IReadOnlyClosedWorld,PDDLParser.Exp.LocalBindings)">
            <summary>
            Evaluates this logical expression in the specified closed world.
            The bindings should not be modified by this call.
            In addition to False, Undefined also shortcircuit conjunctions.
            This function is used to evaluate defined formulas' body as is done in the
            original TLPlan.
            </summary>
            <param name="world">The evaluation world.</param>
            <param name="bindings">A set of variable bindings.</param>
            <returns>True, false, or undefined.</returns>
        </member>
        <member name="M:PDDLParser.Exp.Logical.AndExp.EnumerateAllSatisfyingWorlds">
            <summary>
            Enumerates all the worlds within which this logical expression evaluates to true.
            The worlds satisfying a conjunctive expression correspond to all the legal permutations
            of the worlds satisfying the individual logical expressions.
            </summary>
            <returns>All the worlds satisfying this logical expression.</returns>
        </member>
        <member name="M:PDDLParser.Exp.Logical.AndExp.Progress(PDDLParser.World.IReadOnlyDurativeClosedWorld,PDDLParser.Exp.LocalBindings)">
            <summary>
            Evaluates the progression of this constraint expression in the next worlds.
            This function returns false if this constraint expression is not satisfied 
            in the given world;
            it returns true if the progression is always satisfied in the next worlds;
            else it returns the progressed expression.
            </summary>
            <param name="world">The current world.</param>
            <param name="bindings">A set of variable bindings.</param>
            <returns>True, false, undefined, or a progressed expression.</returns>
        </member>
        <member name="M:PDDLParser.Exp.Logical.AndExp.EvaluateIdle(PDDLParser.World.IReadOnlyDurativeClosedWorld,PDDLParser.Exp.LocalBindings)">
            <summary>
            Evaluates this constraint expression in an idle world, i.e. a world which
            won't be modified by further updates.
            </summary>
            <param name="idleWorld">The (idle) evaluation world.</param>
            <param name="bindings">A set of variable bindings.</param>
            <returns>True, false, or undefined.</returns>
        </member>
        <member name="T:PDDLParser.Exp.Logical.AndExp.ContextData">
            <summary>
            An instance of ContextData stores a world and a list of worlds satisfying a 
            given element of the conjunctive formula.
            </summary>
        </member>
        <member name="M:PDDLParser.Exp.Logical.AndExp.ContextData.#ctor(PDDLParser.World.PartialWorld,System.Collections.Generic.IEnumerator{PDDLParser.World.PartialWorld})">
            <summary>
            Creates a new ContextData instance with the specified world and and list of 
            satisfying worlds.
            </summary>
            <param name="world">The world to store in the new instance.</param>
            <param name="allWorlds">The list of worlds satysfing some logical expression.</param>
        </member>
        <member name="P:PDDLParser.Exp.Logical.AndExp.ContextData.World">
            <summary>
            The world.
            </summary>
        </member>
        <member name="P:PDDLParser.Exp.Logical.AndExp.ContextData.AllSatisfyingWorlds">
            <summary>
            The list of worlds satisfying some logical expression.
            </summary>
        </member>
        <member name="T:PDDLParser.Exp.Formula.FluentApplication">
            <summary>
            A fluent application is an application of a fluent.
            </summary>
        </member>
        <member name="T:PDDLParser.Exp.Formula.DescribedFormulaApplication">
            <summary>
            A described formula application is an application of a described formula.
            </summary>
        </member>
        <member name="T:PDDLParser.Exp.Formula.FormulaApplication">
            <summary>
            This abstract class is the base class for formula applications, 
            i.e. instances of root formulas.
            </summary>
        </member>
        <member name="F:PDDLParser.Exp.Formula.FormulaApplication.ID_NOT_CONSTANT_ARGUMENTS">
            <summary>
            ID assigned to a formula with some non-constant arguments.
            </summary>
        </member>
        <member name="F:PDDLParser.Exp.Formula.FormulaApplication.m_argumentsID">
            <summary>
            An ID representing this formula application (unique for the root formula).
            The ID is equal to -1 if the formula application is not ground.
            </summary>
        </member>
        <member name="F:PDDLParser.Exp.Formula.FormulaApplication.m_rootFormula">
            <summary>
            The corresponding root formula of this formula application.
            </summary>
        </member>
        <member name="F:PDDLParser.Exp.Formula.FormulaApplication.m_arguments">
            <summary>
            The arguments of the formula.
            </summary>
        </member>
        <member name="M:PDDLParser.Exp.Formula.FormulaApplication.#ctor(PDDLParser.Exp.Formula.RootFormula,System.Collections.Generic.List{PDDLParser.Exp.ITerm})">
            <summary>
            Creates a new formula application of a specified root formula with a given
            list of arguments.
            </summary>
            <param name="rootFormula">The root formula to instantiate.</param>
            <param name="arguments">The arguments of this formula application.</param>
        </member>
        <member name="M:PDDLParser.Exp.Formula.FormulaApplication.EvaluateArguments(PDDLParser.World.IReadOnlyOpenWorld,PDDLParser.Exp.LocalBindings)">
            <summary>
            Evaluates the arguments of this formula application in a given world.
            </summary>
            <param name="world">The evaluation world.</param>
            <param name="bindings">A set of variable bindings.</param>
            <returns>Unknown, undefined, or a new formula application defined by a list of 
            evaluated (constant) arguments.</returns>
        </member>
        <member name="M:PDDLParser.Exp.Formula.FormulaApplication.SimplifyArguments(PDDLParser.World.IReadOnlyOpenWorld,PDDLParser.Exp.LocalBindings)">
            <summary>
            Simplifies, if possible, the arguments of this formula application by evaluating them in a given world.
            </summary>
            <param name="world">The evaluation world.</param>
            <param name="bindings">A set of variable bindings.</param>
            <returns>Undefined, or a new formula application defined by a list of simplified arguments.</returns>
        </member>
        <member name="M:PDDLParser.Exp.Formula.FormulaApplication.EvaluateArguments(PDDLParser.World.IReadOnlyClosedWorld,PDDLParser.Exp.LocalBindings)">
            <summary>
            Evaluates the arguments of this formula application in a given world.
            </summary>
            <param name="world">The evaluation world.</param>
            <param name="bindings">A set of variable bindings.</param>
            <returns>Undefined, or a new formula application defined by a list of 
            evaluated (constant) arguments.</returns>
        </member>
        <member name="M:PDDLParser.Exp.Formula.FormulaApplication.CalculateArgumentsID">
            <summary>
            Calculates the unique ID of this formula application.
            </summary>
            <returns>The unique ID of this formula application, which is -1 if this formula
            application is not ground.</returns>
        </member>
        <member name="M:PDDLParser.Exp.Formula.FormulaApplication.GetArguments">
            <summary>
            Returns the arguments of this formula.
            </summary>
            <returns>The arguments of this formula.</returns>
        </member>
        <member name="M:PDDLParser.Exp.Formula.FormulaApplication.Apply(PDDLParser.Exp.ParameterBindings)">
            <summary>
            Substitutes all occurrences of the variables that occur in this
            expression by their corresponding bindings.
            </summary>
            <param name="bindings">The bindings.</param>
            <returns>A substituted copy of this expression.</returns>
        </member>
        <member name="M:PDDLParser.Exp.Formula.FormulaApplication.Apply(System.Collections.Generic.List{PDDLParser.Exp.ITerm})">
            <summary>
            Returns a copy of this formula application with the specified arguments.
            Implementation by MemberwiseClone() seems slower than calling the appropriate 
            constructor directly.
            </summary>
            <param name="arguments">The arguments of the new formula application.</param>
            <returns>A copy of this expression with the given arguments.</returns>
        </member>
        <member name="M:PDDLParser.Exp.Formula.FormulaApplication.Standardize(System.Collections.Generic.IDictionary{System.String,System.String})">
            <summary>
            Standardizes all occurrences of the variables that occur in this
            expression.
            </summary>
            <param name="images">The object that maps old variable images to the standardize
            image.</param>
            <returns>A standardized copy of this expression.</returns>
        </member>
        <member name="M:PDDLParser.Exp.Formula.FormulaApplication.IsGround">
            <summary>
            Returns true if the expression is ground, i.e. it does not contain any variables.
            </summary>
            <returns>Whether the expression is ground.</returns>
        </member>
        <member name="M:PDDLParser.Exp.Formula.FormulaApplication.GetFreeVariables">
            <summary>
            Returns the free variables in this expression.
            </summary>
            <returns>The free variables in this expression.</returns>
        </member>
        <member name="M:PDDLParser.Exp.Formula.FormulaApplication.Clone">
            <summary>
            Returns a clone of this expression.
            </summary>
            <returns>A clone of this expression.</returns>
        </member>
        <member name="M:PDDLParser.Exp.Formula.FormulaApplication.Equals(System.Object)">
            <summary>
            Returns true if this formula application is equal to a specified object.
            By default, two formula applications are equal if their root formulas are the same,
            and their IDs are the same (and not == -1) or their IDs are both -1 and they are 
            equal according to the base class criteria.
            </summary>
            <param name="obj">Object to test for equality.</param>
            <returns>True if this application formula is equal to the specified objet.</returns>
        </member>
        <member name="M:PDDLParser.Exp.Formula.FormulaApplication.GetHashCode">
            <summary>
            Returns the hash code of this application formula.
            </summary>
            <returns>The hash code of this application formula.</returns>
        </member>
        <member name="M:PDDLParser.Exp.Formula.FormulaApplication.ToString">
            <summary>
            Returns a string representation of this formula.
            </summary>
            <returns>A string representation of this formula.</returns>
        </member>
        <member name="M:PDDLParser.Exp.Formula.FormulaApplication.ToTypedString">
            <summary>
            Returns a typed string representation of this formula.
            </summary>
            <returns>A typed string representation of this formula.</returns>
        </member>
        <member name="M:PDDLParser.Exp.Formula.FormulaApplication.CompareTo(PDDLParser.Exp.IExp)">
            <summary>
            Compares this formula application with another expression.
            </summary>
            <param name="obj">The other expression to compare this expression to.</param>
            <returns>An integer representing the total order relation between the two expressions.
            </returns>
        </member>
        <member name="P:PDDLParser.Exp.Formula.FormulaApplication.AllConstantArguments">
            <summary>
            Gets whether all the arguments of this formula are constant.
            </summary>
        </member>
        <member name="P:PDDLParser.Exp.Formula.FormulaApplication.Name">
            <summary>
            Gets the name of this formula application.
            </summary>
        </member>
        <member name="P:PDDLParser.Exp.Formula.FormulaApplication.ArgumentsID">
            <summary>
            Gets the argument ID of this formula application, which is calculated by summing
            up the ID of all its arguments.
            </summary>
        </member>
        <member name="P:PDDLParser.Exp.Formula.FormulaApplication.FormulaID">
            <summary>
            Gets the unique formula ID of this formula application, which is calculated
            as the sum of the formula's offset and this formula application's arguments ID.
            </summary>
        </member>
        <member name="M:PDDLParser.Exp.Formula.DescribedFormulaApplication.#ctor(PDDLParser.Exp.Formula.DescribedFormula,System.Collections.Generic.List{PDDLParser.Exp.ITerm})">
            <summary>
            Creates a new described formula application of a specified described formula with a given
            list of arguments.
            </summary>
            <param name="describedFormula">The descrbed formula to instantiate.</param>
            <param name="arguments">The arguments of this formula application.</param>
        </member>
        <member name="P:PDDLParser.Exp.Formula.DescribedFormulaApplication.DetectCycles">
            <summary>
            Whether the cycles detection mechanism should use this formula application.
            </summary>
        </member>
        <member name="P:PDDLParser.Exp.Formula.DescribedFormulaApplication.Invariant">
            <summary>
            Returns whether this described formula application is invariant, i.e. if it is never 
            modified by actions.
            </summary>
        </member>
        <member name="M:PDDLParser.Exp.Formula.FluentApplication.#ctor(PDDLParser.Exp.Formula.Fluent,System.Collections.Generic.List{PDDLParser.Exp.ITerm})">
            <summary>
            Creates a new fluent application of a specified fluent with a given list
            of arguments.
            </summary>
            <param name="fluent">The fluent to instantiate.</param>
            <param name="arguments">The arguments of this fluent application.</param>
        </member>
        <member name="P:PDDLParser.Exp.Formula.FluentApplication.RootFluent">
            <summary>
            Gets the fluent associated with this fluent application.
            </summary>
        </member>
        <member name="T:PDDLParser.Exp.Formula.AtomicFormulaApplication">
            <summary>
            An atomic formula application is an application of an atomic formula.
            It can be used both as a logical expression and as an effect.
            </summary>
        </member>
        <member name="M:PDDLParser.Exp.Formula.AtomicFormulaApplication.#ctor(PDDLParser.Exp.Formula.AtomicFormula,System.Collections.Generic.List{PDDLParser.Exp.ITerm})">
            <summary>
            Creates a new atomic formula application of a specified atomic formula with a 
            given list of arguments.
            </summary>
            <param name="atomicFormula">The atomic formula to instantiate.</param>
            <param name="arguments">The arguments of this atomic formula application.</param>
        </member>
        <member name="M:PDDLParser.Exp.Formula.AtomicFormulaApplication.Apply(System.Collections.Generic.List{PDDLParser.Exp.ITerm})">
            <summary>
            Returns a copy of this formula application with the specified arguments.
            </summary>
            <param name="arguments">The arguments of the new formula application.</param>
            <returns>A copy of this expression with the given arguments.</returns>
        </member>
        <member name="M:PDDLParser.Exp.Formula.AtomicFormulaApplication.Update(PDDLParser.World.IReadOnlyOpenWorld,PDDLParser.World.IDurativeOpenWorld,PDDLParser.Exp.LocalBindings,PDDLParser.ActionContext)">
            <summary>
            Updates the specified world by setting to true this atomic formula application.
            </summary>
            <param name="evaluationWorld">The world to evaluate conditions against.</param>
            <param name="updateWorld">The world to update.</param>
            <param name="bindings">A set of variable bindings.</param>
            <param name="actionContext">The action evaluation context.</param>
        </member>
        <member name="M:PDDLParser.Exp.Formula.AtomicFormulaApplication.GetModifiedDescribedFormulas">
            <summary>
            Retrieves all the described formulas modified by this effect.
            </summary>
            <returns>All the described formulas modified by this effect.</returns>
        </member>
        <member name="M:PDDLParser.Exp.Formula.AtomicFormulaApplication.Evaluate(PDDLParser.World.IReadOnlyOpenWorld,PDDLParser.Exp.LocalBindings)">
            <summary>
            Evaluates this logical expression in the specified open world.
            An atomic formula application is evaluated by first evaluating its arguments and then
            by retrieving the value of this application in the world.
            </summary>
            <param name="world">The evaluation world.</param>
            <param name="bindings">A set of variable bindings.</param>
            <returns>True, false, undefined, or unknown.</returns>
        </member>
        <member name="M:PDDLParser.Exp.Formula.AtomicFormulaApplication.EvaluateWithImmediateShortCircuit(PDDLParser.World.IReadOnlyOpenWorld,PDDLParser.Exp.LocalBindings)">
            <summary>
            Evaluates this logical expression in the specified open world.
            In addition to False, Undefined and Unknown also shortcircuit conjunctions.
            In addition to True, Unknown also shortcircuits disjunctions.
            An atomic formula application is evaluated by first evaluating its arguments and then
            by retrieving its value in the specified world.
            </summary>
            <param name="world">The evaluation world.</param>
            <param name="bindings">A set of variable bindings.</param>
            <returns>True, false, undefined, or unknown.</returns>
        </member>
        <member name="M:PDDLParser.Exp.Formula.AtomicFormulaApplication.Simplify(PDDLParser.World.IReadOnlyOpenWorld,PDDLParser.Exp.LocalBindings)">
            <summary>
            Simplifies this logical expression by evaluating its known expression parts.
            An atomic formula application is simplified by first simplifying its arguments and then
            by attempting to retrieve its value in the specified world (if it is ground).
            </summary>
            <param name="world">The evaluation world.</param>
            <param name="bindings">A set of variable bindings.</param>
            <returns>True, false, undefined, or the simplified expression.</returns>
        </member>
        <member name="M:PDDLParser.Exp.Formula.AtomicFormulaApplication.Evaluate(PDDLParser.World.IReadOnlyClosedWorld,PDDLParser.Exp.LocalBindings)">
            <summary>
            Evaluates this logical expression in the specified closed world.
            An atomic formula application is evaluated by first evaluating its arguments and then
            by retrieving its value in the specified world.
            </summary>
            <param name="world">The evaluation world.</param>
            <param name="bindings">A set of variable bindings.</param>
            <returns>True, false, or undefined.</returns>
        </member>
        <member name="M:PDDLParser.Exp.Formula.AtomicFormulaApplication.EvaluateWithImmediateShortCircuit(PDDLParser.World.IReadOnlyClosedWorld,PDDLParser.Exp.LocalBindings)">
            <summary>
            Evaluates this logical expression in the specified closed world.
            In addition to False, Undefined also shortcircuit conjunctions.
            An atomic formula application is evaluated by first evaluating its arguments and then
            by retrieving its value in the specified world.
            </summary>
            <param name="world">The evaluation world.</param>
            <param name="bindings">A set of variable bindings.</param>
            <returns>True, false, or undefined.</returns>
        </member>
        <member name="M:PDDLParser.Exp.Formula.AtomicFormulaApplication.EnumerateAllSatisfyingWorlds">
            <summary>
            Enumerates all the worlds within which this logical expression evaluates to true.
            This method is used to support the goal modality expressions.
            </summary>
            <returns>All the worlds satisfying this logical expression.</returns>
        </member>
        <member name="M:PDDLParser.Exp.Formula.AtomicFormulaApplication.Progress(PDDLParser.World.IReadOnlyDurativeClosedWorld,PDDLParser.Exp.LocalBindings)">
            <summary>
            Evaluates the progression of this constraint expression in the next worlds.
            The progression is computed by evaluating the atomic formula application.
            </summary>
            <param name="world">The current world.</param>
            <param name="bindings">A set of variable bindings.</param>
            <returns>True, false, or undefined.</returns>
        </member>
        <member name="M:PDDLParser.Exp.Formula.AtomicFormulaApplication.EvaluateIdle(PDDLParser.World.IReadOnlyDurativeClosedWorld,PDDLParser.Exp.LocalBindings)">
            <summary>
            Evaluates this constraint expression in an idle world, i.e. a world which
            won't be modified by further updates.
            </summary>
            <param name="idleWorld">The (idle) evaluation world.</param>
            <param name="bindings">A set of variable bindings.</param>
            <returns>True, false, or undefined.</returns>
        </member>
        <member name="M:PDDLParser.Exp.Formula.AtomicFormulaApplication.CompareTo(PDDLParser.Exp.Formula.AtomicFormulaApplication)">
            <summary>
            Compares two atomic formula applications.
            </summary>
            <param name="other">The other atomic formula application to compare this formula to.</param>
            <returns>An integer representing the total order relation between the two formulas.</returns>
        </member>
        <member name="P:PDDLParser.Exp.Formula.AtomicFormulaApplication.Predicate">
            <summary>
            Gets the predicate associated with this literal.
            </summary>
        </member>
        <member name="T:PDDLParser.Exp.Formula.TLPlan.DefinedObjectFunctionApplication">
            <summary>
            A defined object function application is an application of a defined object function.
            </summary>
        </member>
        <member name="T:PDDLParser.Exp.Formula.DefinedFormulaApplication">
            <summary>
            A defined formula application is an application of a defined formula.
            When evaluated, a defined formula application performs a (possibly complex) evaluation
            of its body.
            </summary>
        </member>
        <member name="M:PDDLParser.Exp.Formula.DefinedFormulaApplication.#ctor(PDDLParser.Exp.Formula.DefinedFormula,System.Collections.Generic.List{PDDLParser.Exp.ITerm})">
            <summary>
            Creates a new defined formula application of a specified defined formula with a 
            given list of arguments.
            </summary>
            <param name="definedFormula">The defined formula to instantiate.</param>
            <param name="arguments">The arguments of the new defined formula application.</param>
        </member>
        <member name="M:PDDLParser.Exp.Formula.TLPlan.DefinedObjectFunctionApplication.#ctor(PDDLParser.Exp.Formula.TLPlan.DefinedObjectFunction,System.Collections.Generic.List{PDDLParser.Exp.ITerm})">
            <summary>
            Creates a new defined object function application of a specified defined object function
            with a given list of arguments.
            </summary>
            <param name="objectFunction">The defined object function to instantiate.</param>
            <param name="arguments">The arguments of this new defined object function application.</param>
        </member>
        <member name="M:PDDLParser.Exp.Formula.TLPlan.DefinedObjectFunctionApplication.getDefinedObjectFunction">
            <summary>
            Returns the defined object function corresponding to this function application.
            </summary>
            <returns>The defined object function corresponding to this function application.</returns>
        </member>
        <member name="M:PDDLParser.Exp.Formula.TLPlan.DefinedObjectFunctionApplication.Apply(System.Collections.Generic.List{PDDLParser.Exp.ITerm})">
            <summary>
            Returns a copy of this formula application with the specified arguments.
            </summary>
            <param name="arguments">The arguments of the new formula application.</param>
            <returns>A copy of this expression with the given arguments.</returns>
        </member>
        <member name="M:PDDLParser.Exp.Formula.TLPlan.DefinedObjectFunctionApplication.Evaluate(PDDLParser.World.IReadOnlyOpenWorld,PDDLParser.Exp.LocalBindings)">
            <summary>
            Evaluates this term in the specified open world.
            An object function application is evaluated by first evaluating its arguments 
            and then evaluating the corresponding defined function's body with the appropriate bindings.
            </summary>
            <param name="world">The evaluation world.</param>
            <param name="bindings">A set of variable bindings.</param>
            <returns>Undefined, unknown, or the constant resulting from the evaluation.</returns>
        </member>
        <member name="M:PDDLParser.Exp.Formula.TLPlan.DefinedObjectFunctionApplication.Simplify(PDDLParser.World.IReadOnlyOpenWorld,PDDLParser.Exp.LocalBindings)">
            <summary>
            Simplifies this term by evaluating its known expression parts.
            An object function application is simplified by first simplifying its arguments
            and then by attempting to evaluate the corresponding defined function's body (if all
            its arguments are ground).
            </summary>
            <param name="world">The evaluation world.</param>
            <param name="bindings">A set of variable bindings.</param>
            <returns>Undefined, or the term (possibly a constant) resulting from 
            the simplification.</returns>
        </member>
        <member name="M:PDDLParser.Exp.Formula.TLPlan.DefinedObjectFunctionApplication.Evaluate(PDDLParser.World.IReadOnlyClosedWorld,PDDLParser.Exp.LocalBindings)">
            <summary>
            Evaluates this term in the specified open world.
            An object function application is evaluated by first evaluating its arguments 
            and then evaluating the corresponding defined function's body with the appropriate bindings.
            </summary>
            <param name="world">The evaluation world.</param>
            <param name="bindings">A set of variable bindings.</param>
            <returns>Undefined, or the constant resulting from the evaluation.</returns>
        </member>
        <member name="M:PDDLParser.Exp.Formula.TLPlan.DefinedObjectFunctionApplication.GetTypeSet">
            <summary>
            Return the typeset of the value returned by this object function application.
            </summary>
            <returns>The typeset of the value returned by this object function
            application.</returns>
        </member>
        <member name="M:PDDLParser.Exp.Formula.TLPlan.DefinedObjectFunctionApplication.CanBeAssignedFrom(PDDLParser.Exp.ITerm)">
            <summary>
            Verifies whether the specified term can be assigned to this term, 
            i.e. if the other term's domain is a subset of this term's domain.
            </summary>
            <param name="term">The other term.</param>
            <returns>True if the types are compatible, false otherwise.</returns>
        </member>
        <member name="M:PDDLParser.Exp.Formula.TLPlan.DefinedObjectFunctionApplication.IsComparableTo(PDDLParser.Exp.ITerm)">
            <summary>
            Verifies whether the specified term can be compared to this term,
            i.e. if their domain overlap.
            </summary>
            <param name="term">The other term</param>
            <returns>True if the types can be compared, false otherwise.</returns>
        </member>
        <member name="T:PDDLParser.Exp.Formula.DerivedPredicate">
            <summary>
            A derived predicate is a special defined predicate present in the PDDL specification.
            There are two differences between a derived predicate and a TLPlan defined predicate:
            1- A derived predicate is evaluated by performing a regular evaluation of its body
            (a first order formula), as opposed to the evaluation of a defined predicate's body,
            which is done using shortcircuits.
            2- A derived predicate cannot use local variables.
            </summary>
        </member>
        <member name="M:PDDLParser.Exp.Formula.DerivedPredicate.#ctor(System.String,System.Collections.Generic.List{PDDLParser.Exp.Term.ObjectParameterVariable})">
            <summary>
            Creates a new derived predicate with a specified name and list of arguments.
            </summary>
            <param name="name">The name of this derived predicate.</param>
            <param name="arguments">The arguments of this derived predicate.</param>
        </member>
        <member name="M:PDDLParser.Exp.Formula.DerivedPredicate.Evaluate(PDDLParser.World.IReadOnlyOpenWorld,PDDLParser.Exp.Formula.TLPlan.DefinedPredicateApplication)">
            <summary>
            Evaluates this derived predicate in the specified open world.
            A derived predicate is evaluated by binding its body's free variables to the
            corresponding arguments of the function application, and then performing a 
            regular evaluation of its body.
            The defined predicate's return value corresponds to the boolean value obtained
            when evaluating its body.
            </summary>
            <param name="world">The evaluation world.</param>
            <param name="formula">A function application with ground (constant) arguments.</param>
            <returns>True, false, undefined, or unknown.</returns>
        </member>
        <member name="M:PDDLParser.Exp.Formula.DerivedPredicate.Evaluate(PDDLParser.World.IReadOnlyClosedWorld,PDDLParser.Exp.Formula.TLPlan.DefinedPredicateApplication)">
            <summary>
            Evaluates this derived predicate in the specified closed world.
            A derived predicate is evaluated by binding its body's free variables to the
            corresponding arguments of the function application, and then performing a 
            regular evaluation of its body.
            The defined predicate's return value corresponds to the boolean value obtained
            when evaluating its body.
            </summary>
            <param name="world">The evaluation world.</param>
            <param name="formula">A function application with ground (constant) arguments.</param>
            <returns>True, false, or undefined.</returns>
        </member>
        <member name="T:PDDLParser.Exp.Constraint.HoldDuringExp">
            <summary>
            Represents the "hold-during" constraint expression of the PDDL language.
            This constraint expression uses timestamps relative to the first time it is progressed.
            </summary>
            <remarks>
            This is implemented using TLPlan's "<see cref="T:PDDLParser.Exp.Constraint.TLPlan.TAlwaysExp">t-always</see>" constraint expression, using a closed
            lower time interval bound and an open upper bound.
            </remarks>
            <seealso cref="T:PDDLParser.Exp.Constraint.TLPlan.TAlwaysExp"/>
            <seealso cref="T:PDDLParser.Exp.Constraint.TLPlan.AbsoluteTAlwaysExp"/>
        </member>
        <member name="T:PDDLParser.Exp.Constraint.TLPlan.TAlwaysExp">
            <summary>
            Represents the "t-always" constraint expression. This is a time-bounded version of
            the <see cref="T:PDDLParser.Exp.Constraint.AlwaysExp"/> constraint expression. This is not part of the PDDL language;
            it was rather added for TLPlan.
            This constraint expression uses timestamps relative to the first time it is progressed.
            </summary>
            <seealso cref="T:PDDLParser.Exp.Constraint.AlwaysExp"/>
            <seealso cref="T:PDDLParser.Exp.Constraint.HoldDuringExp"/>
        </member>
        <member name="T:PDDLParser.Exp.Constraint.TLPlan.IntervalConstraintExp">
            <summary>
            Represents the base class for time-bounded constraint expression, such as "t-always" and "t-eventually"
            .the "t-always" constraint expression. This is not part of the PDDL language;
            it was rather added for TLPlan.
            This constraint expression uses timestamps relative to the first time it is progressed.
            </summary>
            <seealso cref="T:PDDLParser.Exp.Constraint.TLPlan.TAlwaysExp"/>
            <seealso cref="T:PDDLParser.Exp.Constraint.TLPlan.TEventuallyExp"/>
        </member>
        <member name="T:PDDLParser.Exp.Constraint.UnaryConstraintExp">
            <summary>
            Represents a unary constraint expression of the PDDL language.
            </summary>
        </member>
        <member name="F:PDDLParser.Exp.Constraint.UnaryConstraintExp.m_exp">
            <summary>
            The body of the unary constraint expression.
            </summary>
        </member>
        <member name="M:PDDLParser.Exp.Constraint.UnaryConstraintExp.#ctor(PDDLParser.Exp.IConstraintExp)">
            <summary>
            Creates a new unary constraint expression with a specified body.
            </summary>
            <param name="exp">The body of the unary constraint expression.</param>
        </member>
        <member name="M:PDDLParser.Exp.Constraint.UnaryConstraintExp.Apply(PDDLParser.Exp.ParameterBindings)">
            <summary>
            Substitutes all occurrences of the variables that occur in this
            expression by their corresponding bindings.
            The base implementation is to simply clone the object.
            </summary>
            <param name="bindings">The bindings.</param>
            <returns>A substituted copy of this expression.</returns>
        </member>
        <member name="M:PDDLParser.Exp.Constraint.UnaryConstraintExp.Standardize(System.Collections.Generic.IDictionary{System.String,System.String})">
            <summary>
            Standardizes all occurrences of the variables that occur in this
            expression. Remember that free variables are existentially quantified.
            </summary>
            <param name="images">The object that maps old variable images to the standardize
            image.</param>
            <returns>A standardized copy of this expression.</returns>
        </member>
        <member name="M:PDDLParser.Exp.Constraint.UnaryConstraintExp.GetFreeVariables">
            <summary>
            Returns the free variables in this expression.
            </summary>
            <returns>The free variables in this expression.</returns>
        </member>
        <member name="M:PDDLParser.Exp.Constraint.UnaryConstraintExp.IsGround">
            <summary>
            Returns true if the expression is ground, i.e. it does not contain any variables.
            </summary>
            <returns>Whether the expression is ground.</returns>
        </member>
        <member name="M:PDDLParser.Exp.Constraint.UnaryConstraintExp.Equals(System.Object)">
            <summary>
            Returns true if this expression is equal to a specified object.
            </summary>
            <param name="obj">Object to test for equality.</param>
            <returns>True if this expression is equal to the specified objet.</returns>
        </member>
        <member name="M:PDDLParser.Exp.Constraint.UnaryConstraintExp.GetHashCode">
            <summary>
            Returns the hash code of this expression.
            </summary>
            <returns>The hash code of this expression.</returns>
        </member>
        <member name="M:PDDLParser.Exp.Constraint.UnaryConstraintExp.CompareTo(PDDLParser.Exp.IExp)">
            <summary>
            Compares this expression with another expression.
            </summary>
            <param name="other">The other expression to compare this expression to.</param>
            <returns>An integer representing the total order relation between the two expressions.</returns>
        </member>
        <member name="P:PDDLParser.Exp.Constraint.UnaryConstraintExp.Exp">
            <summary>
            Returns the body of the unary constraint expression.
            </summary>
            <returns>The body of the unary constraint expression.</returns>
        </member>
        <member name="F:PDDLParser.Exp.Constraint.TLPlan.IntervalConstraintExp.m_relativeTimeInterval">
            <summary>
            The relative time interval.
            </summary>
        </member>
        <member name="F:PDDLParser.Exp.Constraint.TLPlan.IntervalConstraintExp.m_name">
            <summary>
            The name of the timed-bounded constraint expression.
            </summary>
        </member>
        <member name="M:PDDLParser.Exp.Constraint.TLPlan.IntervalConstraintExp.#ctor(System.String,PDDLParser.Exp.Struct.TimeInterval,PDDLParser.Exp.IConstraintExp)">
            <summary>
            Creates a new "t-always" constraint expression.
            </summary>
            <param name="name">The name of the time-bounded constraint expression.</param>
            <param name="interval">The relative time interal to when the expression is first progressed.</param>
            <param name="exp">The body of the constraint expression.</param>
        </member>
        <member name="M:PDDLParser.Exp.Constraint.TLPlan.IntervalConstraintExp.Progress(PDDLParser.World.IReadOnlyDurativeClosedWorld,PDDLParser.Exp.LocalBindings)">
            <summary>
            Evaluates the progression of this constraint expression in the next worlds.
            </summary>
            <param name="world">The current world.</param>
            <param name="bindings">A set of variable bindings.</param>
            <returns>True, false, undefined, or a progressed expression.</returns>
            <exception cref="T:PDDLParser.Exception.BindingException">A BindingException is thrown if an attempt
            is made to evaluate an unbound variable.</exception>
            <seealso cref="M:PDDLParser.Exp.IConstraintExp.Progress(PDDLParser.World.IReadOnlyDurativeClosedWorld,PDDLParser.Exp.LocalBindings)"/>
        </member>
        <member name="M:PDDLParser.Exp.Constraint.TLPlan.IntervalConstraintExp.EvaluateIdle(PDDLParser.World.IReadOnlyDurativeClosedWorld,PDDLParser.Exp.LocalBindings)">
            <summary>
            Evaluates this constraint expression in an idle world, i.e. a world which
            won't be modified by further updates.
            </summary>
            <param name="idleWorld">The (idle) evaluation world.</param>
            <param name="bindings">A set of variable bindings.</param>
            <returns>True, false, or undefined.</returns>
            <exception cref="T:PDDLParser.Exception.BindingException">A BindingException is thrown if an attempt
            is made to evaluate an unbound variable.</exception>
            <seealso cref="M:PDDLParser.Exp.IConstraintExp.EvaluateIdle(PDDLParser.World.IReadOnlyDurativeClosedWorld,PDDLParser.Exp.LocalBindings)"/>
        </member>
        <member name="M:PDDLParser.Exp.Constraint.TLPlan.IntervalConstraintExp.Equals(System.Object)">
            <summary>
            Returns true if this expression is equal to a specified object.
            </summary>
            <param name="obj">Object to test for equality.</param>
            <returns>True if this expression is equal to the specified objet.</returns>
        </member>
        <member name="M:PDDLParser.Exp.Constraint.TLPlan.IntervalConstraintExp.GetHashCode">
            <summary>
            Returns the hash code of this expression.
            </summary>
            <returns>The hash code of this expression.</returns>
        </member>
        <member name="M:PDDLParser.Exp.Constraint.TLPlan.IntervalConstraintExp.ToString">
            <summary>
            Returns a string representation of this expression.
            </summary>
            <returns>A string representation of this expression.</returns>
        </member>
        <member name="M:PDDLParser.Exp.Constraint.TLPlan.IntervalConstraintExp.ToTypedString">
            <summary>
            Returns a typed string of this expression.
            </summary>
            <returns>A typed string representation of this expression.</returns>
        </member>
        <member name="M:PDDLParser.Exp.Constraint.TLPlan.IntervalConstraintExp.CompareTo(PDDLParser.Exp.IExp)">
            <summary>
            Compares this expression with another expression.
            </summary>
            <param name="other">The other expression to compare this abstract expression to.</param>
            <returns>An integer representing the total order relation between the two expressions.</returns>
        </member>
        <member name="P:PDDLParser.Exp.Constraint.TLPlan.IntervalConstraintExp.RelativeTimeInterval">
            <summary>
            Gets the relative time interval.
            </summary>
        </member>
        <member name="M:PDDLParser.Exp.Constraint.TLPlan.TAlwaysExp.#ctor(PDDLParser.Exp.Struct.TimeInterval,PDDLParser.Exp.IConstraintExp)">
            <summary>
            Creates a new "t-always" constraint expression.
            </summary>
            <param name="interval">The relative time interal to when the expression is first progressed.</param>
            <param name="arg">The body of the constraint expression.</param>
        </member>
        <member name="M:PDDLParser.Exp.Constraint.TLPlan.TAlwaysExp.Progress(PDDLParser.World.IReadOnlyDurativeClosedWorld,PDDLParser.Exp.LocalBindings)">
            <summary>
            Evaluates the progression of this constraint expression in the next worlds.
            This creates an instance of <see cref="T:PDDLParser.Exp.Constraint.TLPlan.AbsoluteTAlwaysExp"/> for progression.
            </summary>
            <param name="world">The current world.</param>
            <param name="bindings">A set of variable bindings.</param>
            <returns>True, false, undefined, or a progressed expression.</returns>
            <exception cref="T:PDDLParser.Exception.BindingException">A BindingException is thrown if an attempt
            is made to evaluate an unbound variable.</exception>
            <seealso cref="M:PDDLParser.Exp.IConstraintExp.Progress(PDDLParser.World.IReadOnlyDurativeClosedWorld,PDDLParser.Exp.LocalBindings)"/>
            <seealso cref="T:PDDLParser.Exp.Constraint.TLPlan.AbsoluteTAlwaysExp"/>
        </member>
        <member name="M:PDDLParser.Exp.Constraint.TLPlan.TAlwaysExp.EvaluateIdle(PDDLParser.World.IReadOnlyDurativeClosedWorld,PDDLParser.Exp.LocalBindings)">
            <summary>
            Evaluates this constraint expression in an idle world, i.e. a world which
            won't be modified by further updates.
            This creates an instance of <see cref="T:PDDLParser.Exp.Constraint.TLPlan.AbsoluteTAlwaysExp"/> for evaluation.
            </summary>
            <param name="idleWorld">The (idle) evaluation world.</param>
            <param name="bindings">A set of variable bindings.</param>
            <returns>True, false, or undefined.</returns>
            <exception cref="T:PDDLParser.Exception.BindingException">A BindingException is thrown if an attempt
            is made to evaluate an unbound variable.</exception>
            <seealso cref="M:PDDLParser.Exp.IConstraintExp.EvaluateIdle(PDDLParser.World.IReadOnlyDurativeClosedWorld,PDDLParser.Exp.LocalBindings)"/>
            <seealso cref="T:PDDLParser.Exp.Constraint.TLPlan.AbsoluteTAlwaysExp"/>
        </member>
        <member name="M:PDDLParser.Exp.Constraint.HoldDuringExp.#ctor(System.Double,System.Double,PDDLParser.Exp.IConstraintExp)">
            <summary>
            Creates a new "hold-during" constraint expression.
            </summary>
            <param name="lowerRelativeTimestamp">The lower bound of the time interval, relatively to when the expression is progressed.</param>
            <param name="upperRelativeTimestamp">The upper bound of the time interval, relatively to when the expression is progressed.</param>
            <param name="arg">The body of the constraint expression.</param>
        </member>
        <member name="M:PDDLParser.Exp.Constraint.HoldDuringExp.ToString">
            <summary>
            Returns a string representation of this expression.
            </summary>
            <returns>A string representation of this expression.</returns>
        </member>
        <member name="M:PDDLParser.Exp.Constraint.HoldDuringExp.ToTypedString">
            <summary>
            Returns a typed string of this expression.
            </summary>
            <returns>A typed string representation of this expression.</returns>
        </member>
        <member name="T:PDDLParser.Exp.Constraint.ExistsConstraintExp">
            <summary>
            Represents an existential quantification of a constraint expression.
            </summary>
        </member>
        <member name="M:PDDLParser.Exp.Constraint.ExistsConstraintExp.#ctor(System.Collections.Generic.HashSet{PDDLParser.Exp.Term.ObjectParameterVariable},PDDLParser.Exp.IConstraintExp)">
            <summary>
            Creates a new existential expression with the given quantified variables and
            constraint expression.
            </summary>
            <param name="vars">The quantified variables.</param>
            <param name="exp">The constraint expression.</param>
        </member>
        <member name="M:PDDLParser.Exp.Constraint.ExistsConstraintExp.GenerateEquivalentExp">
            <summary>
            Creates a new ground expression equivalent to this quantified expression.
            </summary>
            <returns>A new ground expression equivalent to this quantified expression.</returns>
        </member>
        <member name="M:PDDLParser.Exp.Constraint.ExistsConstraintExp.Progress(PDDLParser.World.IReadOnlyDurativeClosedWorld,PDDLParser.Exp.LocalBindings)">
            <summary>
            Evaluates the progression of this constraint expression in the next worlds.
            </summary>
            <param name="world">The current world.</param>
            <param name="bindings">A set of variable bindings.</param>
            <returns>True, false, undefined, or a progressed expression.</returns>
            <exception cref="T:PDDLParser.Exception.BindingException">A BindingException is thrown if an attempt
            is made to evaluate an unbound variable.</exception>
            <seealso cref="M:PDDLParser.Exp.IConstraintExp.Progress(PDDLParser.World.IReadOnlyDurativeClosedWorld,PDDLParser.Exp.LocalBindings)"/>
        </member>
        <member name="M:PDDLParser.Exp.Constraint.ExistsConstraintExp.EvaluateIdle(PDDLParser.World.IReadOnlyDurativeClosedWorld,PDDLParser.Exp.LocalBindings)">
            <summary>
            Evaluates this constraint expression in an idle world, i.e. a world which
            won't be modified by further updates.
            </summary>
            <param name="idleWorld">The (idle) evaluation world.</param>
            <param name="bindings">A set of variable bindings.</param>
            <returns>True, false, or undefined.</returns>
            <exception cref="T:PDDLParser.Exception.BindingException">A BindingException is thrown if an attempt
            is made to evaluate an unbound variable.</exception>
            <seealso cref="M:PDDLParser.Exp.IConstraintExp.EvaluateIdle(PDDLParser.World.IReadOnlyDurativeClosedWorld,PDDLParser.Exp.LocalBindings)"/>
        </member>
        <member name="T:PDDLParser.Exp.Comparison.LessComp">
            <summary>
            This class implements the less numeric comparison.
            </summary>
        </member>
        <member name="M:PDDLParser.Exp.Comparison.LessComp.#ctor(PDDLParser.Exp.INumericExp,PDDLParser.Exp.INumericExp)">
            <summary>
            Creates a new less numeric comparison.
            </summary>
            <param name="arg1">The first argument.</param>
            <param name="arg2">The second argument.</param>
        </member>
        <member name="M:PDDLParser.Exp.Comparison.LessComp.Compare(PDDLParser.Exp.Struct.Double,PDDLParser.Exp.Struct.Double)">
            <summary>
            Compares the two arguments. This comparison should return undefined if at least
            one of the two arguments is undefined.
            </summary>
            <param name="arg1">The first argument.</param>
            <param name="arg2">The second argument.</param>
            <returns>True, false, or undefined.</returns>
        </member>
        <member name="M:PDDLParser.Exp.Comparison.LessComp.Compare(PDDLParser.Exp.Struct.FuzzyDouble,PDDLParser.Exp.Struct.FuzzyDouble)">
            <summary>
            Compares the two arguments. This comparison should return undefined if at least one 
            of the two arguments is undefined, or unknown if at least one of the two arguments is 
            unknown.
            </summary>
            <param name="arg1">The first argument.</param>
            <param name="arg2">The second argument.</param>
            <returns>True, false, undefined, or unknown.</returns>
        </member>
        <member name="T:PDDLParser.World.PartialWorld">
            <summary>
            A partial world is a (partial) world implementation used to describe the set of worlds which
            satisfy a given logical formula, i.e. ILogicalExp.EnumerateAllSatisfyingWorlds()
            </summary>
        </member>
        <member name="F:PDDLParser.World.PartialWorld.m_hashCode">
            <summary>
            The hash code of this partial world.
            </summary>
        </member>
        <member name="F:PDDLParser.World.PartialWorld.m_facts">
            <summary>
            The set of predicates having a fixed value. All predicates which do not appear
            in this set may have arbitrary values.
            </summary>
        </member>
        <member name="M:PDDLParser.World.PartialWorld.#ctor">
            <summary>
            Creates a new partial world within which all predicates have arbitrary values.
            </summary>
        </member>
        <member name="M:PDDLParser.World.PartialWorld.IsSet(PDDLParser.Exp.Formula.AtomicFormulaApplication)">
            <summary>
            Checks whether the specified described atomic formula holds in this world.
            Any predicate not contained in the facts dictionary is unknown.
            </summary>
            <param name="formula">A described (and ground) atomic formula.</param>
            <returns>True, false, undefined, or unknown.</returns>
        </member>
        <member name="M:PDDLParser.World.PartialWorld.Set(PDDLParser.Exp.Formula.AtomicFormulaApplication)">
            <summary>
            Sets the specified described atomic formula to true.
            </summary>
            <param name="formula">A described (and ground) atomic formula.</param>
        </member>
        <member name="M:PDDLParser.World.PartialWorld.Unset(PDDLParser.Exp.Formula.AtomicFormulaApplication)">
            <summary>
            Sets the specified described atomic formula to false.
            </summary>
            <param name="formula">A described (and ground) atomic formula.</param>
        </member>
        <member name="M:PDDLParser.World.PartialWorld.GetEvaluation(PDDLParser.Exp.Formula.TLPlan.DefinedPredicateApplication,System.Boolean@)">
            <summary>
            Returns a new unfinished evaluation record.
            </summary>
            <param name="pred">The defined predicate application.</param>
            <param name="existing">This flag is set to true if the defined predicate is already in the
            process of (or has finished) being evaluated.</param>
            <returns>An unfinished evaluation record.</returns>
        </member>
        <member name="M:PDDLParser.World.PartialWorld.GetNumericFluent(PDDLParser.Exp.Formula.NumericFluentApplication)">
            <summary>
            This function is not supported.
            </summary>
            <param name="fluent">A described (and ground) numeric fluent.</param>
            <returns>Throws an exception.</returns>
            <exception cref="T:System.NotSupportedException">A NotSupportedException is always thrown since 
            fluents are not supported.</exception>
        </member>
        <member name="M:PDDLParser.World.PartialWorld.SetNumericFluent(PDDLParser.Exp.Formula.NumericFluentApplication,System.Double)">
            <summary>
            This function is not supported.
            </summary>
            <param name="fluent">A numeric fluent with constant arguments.</param>
            <param name="value">The new value of the numeric fluent.</param>
            <returns>Throws an exception.</returns>
            <exception cref="T:System.NotSupportedException">A NotSupportedException is always thrown since 
            fluents are not supported.</exception>
        </member>
        <member name="M:PDDLParser.World.PartialWorld.GetEvaluation(PDDLParser.Exp.Formula.TLPlan.DefinedNumericFunctionApplication,System.Boolean@)">
            <summary>
            Returns a new unfinished evaluation record.
            </summary>
            <param name="pred">The defined function application.</param>
            <param name="existing">This flag is set to true if the defined function is already in the
            process of (or has finished) being evaluated.</param>
            <returns>An unfinished evaluation record.</returns>
        </member>
        <member name="M:PDDLParser.World.PartialWorld.GetObjectFluent(PDDLParser.Exp.Formula.ObjectFluentApplication)">
            <summary>
            This function is not supported.
            </summary>
            <param name="fluent">A described (and ground) object fluent.</param>
            <returns>Throws an exception.</returns>
            <exception cref="T:System.NotSupportedException">A NotSupportedException is always thrown since 
            fluents are not supported.</exception>
        </member>
        <member name="M:PDDLParser.World.PartialWorld.SetObjectFluent(PDDLParser.Exp.Formula.ObjectFluentApplication,PDDLParser.Exp.Term.Constant)">
            <summary>
            This function is not supported.
            </summary>
            <param name="fluent">A object fluent with constant arguments.</param>
            <param name="value">The constant representing the new value of the object fluent.</param>
            <returns>Throws an exception.</returns>
            <exception cref="T:System.NotSupportedException">A NotSupportedException is always thrown since 
            fluents are not supported.</exception>
        </member>
        <member name="M:PDDLParser.World.PartialWorld.UndefineObjectFluent(PDDLParser.Exp.Formula.ObjectFluentApplication)">
            <summary>
            This function is not supported.
            </summary>
            <param name="fluent">A object fluent with constant arguments.</param>
            <exception cref="T:System.NotSupportedException">A NotSupportedException is always thrown since 
            fluents are not supported.</exception>
        </member>
        <member name="M:PDDLParser.World.PartialWorld.GetEvaluation(PDDLParser.Exp.Formula.TLPlan.DefinedObjectFunctionApplication,System.Boolean@)">
            <summary>
            Returns a new unfinished evaluation record.
            </summary>
            <param name="pred">The defined function application.</param>
            <param name="existing">This flag is set to true if the defined function is already in the
            process of (or has finished) being evaluated.</param>
            <returns>An unfinished evaluation record.</returns>
        </member>
        <member name="M:PDDLParser.World.PartialWorld.Negate">
            <summary>
            Returns the negation of this world, which is achieved by negating all
            its facts.
            </summary>
            <returns>The negation of this world.</returns>
        </member>
        <member name="M:PDDLParser.World.PartialWorld.Join(PDDLParser.World.PartialWorld)">
            <summary>
            Joins this world with another partial world, resulting in a world where all facts are
            merged.
            Note that this function does not modify the current world, and it returns null if some 
            facts are inconsistent between the two worlds, for example (on a b) and (not (on a b)).
            </summary>
            <param name="other">Other world to join this world with.</param>
            <returns>A new world in which the facts are merged.</returns>
        </member>
        <member name="M:PDDLParser.World.PartialWorld.GetAllPredicates">
            <summary>
            Returns the list of all atomic formula applications whose value are known inside
            this world.
            </summary>
            <returns>The list of all atomic formula applications whose value are known inside
            this world.</returns>
        </member>
        <member name="M:PDDLParser.World.PartialWorld.GetHashCode">
            <summary>
            Returns the hash code of this partial world.
            </summary>
            <returns>The hash code of this partial world.</returns>
        </member>
        <member name="M:PDDLParser.World.PartialWorld.Equals(System.Object)">
            <summary>
            Returns whether this quantified expression is equal to another object.
            Two quantified expressions are equal if they are defined over the same quantified variables
            and their body is equal.
            </summary>
            <param name="obj">The other object to test for equality.</param>
            <returns>True if this quantified expression is equal to another object.</returns>
        </member>
        <member name="M:PDDLParser.World.PartialWorld.Clone">
            <summary>
            Returns a clone of this expression.
            The default implementation simply returns a memberwise clone.
            </summary>
            <returns>A clone of this expression.</returns>
        </member>
        <member name="T:PDDLParser.Exp.ReservedNumericExp">
            <summary>
            Represents a reserved numeric expression, such as the duration variable ("?duration"), the continuous variable ("#t"),
            the total time expression ("total-time"), and the is-violated expressions ("is-violated preference-name").
            </summary>
        </member>
        <member name="F:PDDLParser.Exp.ReservedNumericExp.m_image">
            <summary>
            The image of the numeric expression.
            </summary>
        </member>
        <member name="M:PDDLParser.Exp.ReservedNumericExp.#ctor(System.String)">
            <summary>
            Creates an instance of a reserved numeric expression, with a given image.
            </summary>
            <param name="image">The image of the numeric expression.</param>
        </member>
        <member name="M:PDDLParser.Exp.ReservedNumericExp.Evaluate(PDDLParser.World.IReadOnlyClosedWorld,PDDLParser.Exp.LocalBindings)">
            <summary>
            Evaluates this numeric expression in the specified closed world.
            The bindings should not be modified by this call.
            </summary>
            <param name="world">The evaluation world.</param>
            <param name="bindings">A set of variable bindings.</param>
            <returns>Undefined, or the resulting numeric value.</returns>
            <exception cref="T:PDDLParser.Exception.BindingException">A BindingException is thrown if an attempt
            is made to evaluate an unbound variable.</exception>
            <exception cref="T:PDDLParser.Exception.NumericException">A NumericException is thrown if an 
            illegal operation is performed (like a division by zero).</exception>
        </member>
        <member name="M:PDDLParser.Exp.ReservedNumericExp.Evaluate(PDDLParser.World.IReadOnlyOpenWorld,PDDLParser.Exp.LocalBindings)">
            <summary>
            Evaluates this numeric expression in the specified open world.
            The bindings should not be modified by this call.
            </summary>
            <param name="world">The evaluation world.</param>
            <param name="bindings">A set of variable bindings.</param>
            <returns>Undefined, unknown, or the resulting numeric value.</returns>
            <exception cref="T:PDDLParser.Exception.BindingException">A BindingException is thrown if an attempt
            is made to evaluate an unbound variable.</exception>
            <exception cref="T:PDDLParser.Exception.NumericException">A NumericException is thrown if an 
            illegal operation is performed (like a division by zero).</exception>
        </member>
        <member name="M:PDDLParser.Exp.ReservedNumericExp.Simplify(PDDLParser.World.IReadOnlyOpenWorld,PDDLParser.Exp.LocalBindings)">
            <summary>
            Simplifies this numeric expression by evaluating its known expression parts.
            The bindings should not be modified by this call.
            The resulting expression should not contain any unbound variables, since
            they are substituted according to the bindings supplied.
            </summary>
            <param name="world">The evaluation world.</param>
            <param name="bindings">A set of variable bindings.</param>
            <returns>Undefined, a numeric value, or the simplified expression.</returns>
            <exception cref="T:PDDLParser.Exception.BindingException">A BindingException is thrown if an attempt
            is made to evaluate an unbound variable.</exception>
            <exception cref="T:PDDLParser.Exception.NumericException">A NumericException is thrown if an 
            illegal operation is performed (like a division by zero).</exception>
        </member>
        <member name="M:PDDLParser.Exp.ReservedNumericExp.IsGround">
            <summary>
            Returns true if the expression is ground, i.e. it does not contain any variables.
            </summary>
            <returns>Whether the expression is ground.</returns>
        </member>
        <member name="M:PDDLParser.Exp.ReservedNumericExp.GetFreeVariables">
            <summary>
            Returns the free variables in this expression (none).
            </summary>
            <returns>The free variables in this expression.</returns>
        </member>
        <member name="M:PDDLParser.Exp.ReservedNumericExp.ToTypedString">
            <summary>
            Returns a typed string representation of this expression.
            </summary>
            <returns>A typed string representation of this expression.</returns>
        </member>
        <member name="M:PDDLParser.Exp.ReservedNumericExp.ToString">
            <summary>
            Returns a string representation of this expression.
            </summary>
            <returns>A string representation of this expression.</returns>
        </member>
        <member name="M:PDDLParser.Exp.ReservedNumericExp.Equals(System.Object)">
            <summary>
            Returns true if this expression is equal to a specified object.
            </summary>
            <param name="obj">Object to test for equality.</param>
            <returns>True if this expression is equal to the specified objet.</returns>
        </member>
        <member name="M:PDDLParser.Exp.ReservedNumericExp.GetHashCode">
            <summary>
            Returns the hash code of this expression.
            </summary>
            <returns>The hash code of this expression.</returns>
        </member>
        <member name="M:PDDLParser.Exp.ReservedNumericExp.CompareTo(PDDLParser.Exp.IExp)">
            <summary>
            Compares this abstract expression with another expression.
            </summary>
            <param name="other">The other expression to compare this abstract expression to.</param>
            <returns>An integer representing the total order relation between the two expressions.</returns>
        </member>
        <member name="T:PDDLParser.Exp.Numeric.TLPlan.UnaryNaturalLogarithm">
            <summary>
            This class implements the natural logarithm (ln) function.
            This is not part of PDDL; it was rather added for TLPlan.
            </summary>
        </member>
        <member name="M:PDDLParser.Exp.Numeric.TLPlan.UnaryNaturalLogarithm.#ctor(PDDLParser.Exp.INumericExp)">
            <summary>
            Creates a new natural logarithm function with the specified argument.
            </summary>
            <param name="arg">The argument of the new natural logarithm function.</param>
        </member>
        <member name="M:PDDLParser.Exp.Numeric.TLPlan.UnaryNaturalLogarithm.Calculate(System.Double)">
            <summary>
            Calculates the natural logarithm of the argument.
            </summary>
            <param name="arg">The number.</param>
            <returns>The natural logarithm of the argument.</returns>
            <exception cref="T:PDDLParser.Exception.NumericException">A NumericException is thrown if
            the number is less than or equal to 0.</exception>
        </member>
        <member name="T:PDDLParser.Exp.Logical.TLPlan.ExistsUniqueExp">
            <summary>
            This class represents a uniqueness quantification of a logical expression.
            This is not part of PDDL; it was rather added for TLPlan.
            </summary>
        </member>
        <member name="T:PDDLParser.Exp.Constraint.TLPlan.AbstractExistsUniqueExp`1">
            <summary>
            Represents a uniqueness quantification of an expression. This is not part 
            of PDDL; it was rather added for TLPlan.
            </summary>
            <typeparam name="T">The type of the quantified expression.</typeparam>
        </member>
        <member name="M:PDDLParser.Exp.Constraint.TLPlan.AbstractExistsUniqueExp`1.#ctor(System.Collections.Generic.HashSet{PDDLParser.Exp.Term.ObjectParameterVariable},`0)">
            <summary>
            Creates a new uniquely existential expression with the given quantified variables and
            expression.
            </summary>
            <param name="vars">The quantified variables.</param>
            <param name="exp">The quantified expression.</param>
        </member>
        <member name="M:PDDLParser.Exp.Logical.TLPlan.ExistsUniqueExp.#ctor(System.Collections.Generic.HashSet{PDDLParser.Exp.Term.ObjectParameterVariable},PDDLParser.Exp.ILogicalExp)">
            <summary>
            Creates a new uniquely existential expression with the given quantified variables and
            logical expression.
            </summary>
            <param name="vars">The quantified variables.</param>
            <param name="exp">The logical expression.</param>
        </member>
        <member name="M:PDDLParser.Exp.Logical.TLPlan.ExistsUniqueExp.GenerateEquivalentExp">
            <summary>
            Creates a new ground expression equivalent to this quantified expression.
            </summary>
            <returns>A new ground expression equivalent to this quantified expression.</returns>
        </member>
        <member name="M:PDDLParser.Exp.Logical.TLPlan.ExistsUniqueExp.Evaluate(PDDLParser.World.IReadOnlyOpenWorld,PDDLParser.Exp.LocalBindings)">
            <summary>
            Evaluates this logical expression in the specified open world.
            A uniquely existential expression is evaluated as the exclusive disjunction of all its 
            variable substitutions.
            </summary>
            <param name="world">The evaluation world.</param>
            <param name="bindings">A set of variable bindings.</param>
            <returns>True, false, undefined, or unknown.</returns>
        </member>
        <member name="M:PDDLParser.Exp.Logical.TLPlan.ExistsUniqueExp.EvaluateWithImmediateShortCircuit(PDDLParser.World.IReadOnlyOpenWorld,PDDLParser.Exp.LocalBindings)">
            <summary>
            Evaluates this logical expression in the specified open world.
            In addition to False, Undefined and Unknown also shortcircuit conjunctions.
            In addition to True, Unknown also shortcircuits disjunctions.
            A uniquely existential expression is evaluated as the exclusive disjunction of all its 
            variable substitutions.
            </summary>
            <param name="world">The evaluation world.</param>
            <param name="bindings">A set of variable bindings.</param>
            <returns>True, false, undefined, or unknown.</returns>
        </member>
        <member name="M:PDDLParser.Exp.Logical.TLPlan.ExistsUniqueExp.Simplify(PDDLParser.World.IReadOnlyOpenWorld,PDDLParser.Exp.LocalBindings)">
            <summary>
            Simplifies this logical expression by evaluating its known expression parts.
            A uniquely existential expression is simplified as an exclusive disjunction of its yet 
            unknown substitutions.
            </summary>
            <param name="world">The evaluation world.</param>
            <param name="bindings">A set of variable bindings.</param>
            <returns>True, false, undefined, or the simplified expression.</returns>
        </member>
        <member name="M:PDDLParser.Exp.Logical.TLPlan.ExistsUniqueExp.Evaluate(PDDLParser.World.IReadOnlyClosedWorld,PDDLParser.Exp.LocalBindings)">
            <summary>
            Evaluates this logical expression in the specified closed world.
            A uniquely existential expression is simplified as an exclusive disjunction of its yet 
            unknown members.
            </summary>
            <param name="world">The evaluation world.</param>
            <param name="bindings">A set of variable bindings.</param>
            <returns>True, false, or undefined.</returns>
        </member>
        <member name="M:PDDLParser.Exp.Logical.TLPlan.ExistsUniqueExp.EvaluateWithImmediateShortCircuit(PDDLParser.World.IReadOnlyClosedWorld,PDDLParser.Exp.LocalBindings)">
            <summary>
            Evaluates this logical expression in the specified closed world.
            In addition to False, Undefined also shortcircuit conjunctions.
            A uniquely existential expression is simplified as an exclusive disjunction of its yet 
            unknown members.
            </summary>
            <param name="world">The evaluation world.</param>
            <param name="bindings">A set of variable bindings.</param>
            <returns>True, false, or undefined.</returns>
        </member>
        <member name="M:PDDLParser.Exp.Logical.TLPlan.ExistsUniqueExp.EnumerateAllSatisfyingWorlds">
            <summary>
            Enumerates all the worlds within which this logical expression evaluates to true.
            This method is used to support the goal modality expressions.
            </summary>
            <returns>All the worlds satisfying this logical expression.</returns>
        </member>
        <member name="M:PDDLParser.Exp.Logical.TLPlan.ExistsUniqueExp.Progress(PDDLParser.World.IReadOnlyDurativeClosedWorld,PDDLParser.Exp.LocalBindings)">
            <summary>
            Evaluates the progression of this constraint expression in the next worlds.
            This function returns false if this constraint expression is not satisfied 
            in the given world;
            it returns true if the progression is always satisfied in the next worlds;
            else it returns the progressed expression.
            </summary>
            <param name="world">The current world.</param>
            <param name="bindings">A set of variable bindings.</param>
            <returns>True, false, undefined, or a progressed expression.</returns>
        </member>
        <member name="M:PDDLParser.Exp.Logical.TLPlan.ExistsUniqueExp.EvaluateIdle(PDDLParser.World.IReadOnlyDurativeClosedWorld,PDDLParser.Exp.LocalBindings)">
            <summary>
            Evaluates this constraint expression in an idle world, i.e. a world which
            won't be modified by further updates.
            </summary>
            <param name="idleWorld">The (idle) evaluation world.</param>
            <param name="bindings">A set of variable bindings.</param>
            <returns>True, false, or undefined.</returns>
        </member>
        <member name="T:PDDLParser.Exp.Formula.TLPlan.LocalVar.NumericVariable">
            <summary>
            A numeric variable is a variable bound to a numeric value.
            </summary>
        </member>
        <member name="T:PDDLParser.Exp.Variable">
            <summary>
            Base class for variables.
            </summary>
        </member>
        <member name="F:PDDLParser.Exp.Variable.m_name">
            <summary>
            The name of this variable.
            </summary>
        </member>
        <member name="M:PDDLParser.Exp.Variable.#ctor(System.String)">
            <summary>
            Creates a new variable with a specified name.
            </summary>
            <param name="name">The name of the new variable.</param>
        </member>
        <member name="M:PDDLParser.Exp.Variable.standardizeQuantifiedVariable(PDDLParser.Exp.Variable,System.Collections.Generic.IDictionary{System.String,System.String})">
            <summary>
            Standardizes a quantified variable.
            </summary>
            <param name="var">The quantified variable to standardize.</param>
            <param name="images">The object that maps old variable images to the standardize
            image.</param>
            <returns>A standardized copy of the variable.</returns>
        </member>
        <member name="M:PDDLParser.Exp.Variable.getStandardizedImage(System.String)">
            <summary>
            Returns the standardize name of a variable given its image.
            </summary>
            <param name="image">The variable's image.</param>
            <returns>The standardize name of the variable.</returns>
        </member>
        <member name="M:PDDLParser.Exp.Variable.Standardize(System.Collections.Generic.IDictionary{System.String,System.String})">
            <summary>
            Standardizes all occurrences of the variables that occur in this
            expression. The IDictionary argument is used to store the variable already
            standardized. Remember that free variables are existentially quantified.
            </summary>
            <param name="images">The object that maps old variable images to the standardize
            image.</param>
            <returns>A standardized copy of this expression.</returns>
        </member>
        <member name="M:PDDLParser.Exp.Variable.IsFree">
            <summary>
            Returns true if this variable is free, false it is bound.
            </summary>
            <returns>Whether this variable is free.</returns>
        </member>
        <member name="M:PDDLParser.Exp.Variable.IsGround">
            <summary>
            Returns true if the expression is ground, i.e. it does not contain any variables.
            A variable is not ground.
            </summary>
            <returns>False.</returns>
        </member>
        <member name="M:PDDLParser.Exp.Variable.GetFreeVariables">
            <summary>
            Returns the free variables in this expression.
            </summary>
            <returns>The free variables in this expression.</returns>
        </member>
        <member name="M:PDDLParser.Exp.Variable.CompareTo(PDDLParser.Exp.IExp)">
            <summary>
            Compares this variable with another expression.
            </summary>
            <param name="other">The other expression to compare this variable to.</param>
            <returns>An integer representing the total order relation between the two expressions.
            </returns>
        </member>
        <member name="M:PDDLParser.Exp.Variable.Equals(System.Object)">
            <summary>
            Returns whether this variable is equal to another object.
            </summary>
            <param name="obj">The other object to test for equality.</param>
            <returns>True if this variable is equal to the other object.</returns>
        </member>
        <member name="M:PDDLParser.Exp.Variable.GetHashCode">
            <summary>
            Returns the hash code of this variable.
            </summary>
            <returns>The hash code of this variable.</returns>
        </member>
        <member name="M:PDDLParser.Exp.Variable.ToString">
            <summary>
            Returns a string representation of this variable.
            </summary>
            <returns>A string representation of this variable.</returns>
        </member>
        <member name="M:PDDLParser.Exp.Variable.CompareTo(PDDLParser.Exp.IVariable)">
            <summary>
            Returns whether this variable is equal to another variable.
            </summary>
            <param name="other">The other variable to test for equality.</param>
            <returns>True if this variable is equal to the other variable.</returns>
        </member>
        <member name="P:PDDLParser.Exp.Variable.Name">
            <summary>
            Gets the name of this variable.
            </summary>
        </member>
        <member name="M:PDDLParser.Exp.Formula.TLPlan.LocalVar.NumericVariable.#ctor(System.String)">
            <summary>
            Creates a new numeric variable with the specified name.
            </summary>
            <param name="name">The name of the numeric variable.</param>
        </member>
        <member name="M:PDDLParser.Exp.Formula.TLPlan.LocalVar.NumericVariable.Evaluate(PDDLParser.World.IReadOnlyOpenWorld,PDDLParser.Exp.LocalBindings)">
            <summary>
            Evaluates this numeric expression in the specified open world.
            The bindings should not be modified by this call.
            </summary>
            <param name="world">The evaluation world.</param>
            <param name="bindings">A set of variable bindings.</param>
            <returns>Undefined, unknown, or the resulting numeric value.</returns>
            <exception cref="T:PDDLParser.Exception.BindingException">A BindingException is thrown if this
            variable is not bound.</exception>
        </member>
        <member name="M:PDDLParser.Exp.Formula.TLPlan.LocalVar.NumericVariable.Evaluate(PDDLParser.World.IReadOnlyClosedWorld,PDDLParser.Exp.LocalBindings)">
            <summary>
            Simplifies this numeric expression by evaluating its known expression parts.
            The bindings should not be modified by this call.
            The resulting expression should not contain any unbound variables, since
            they are substituted according to the bindings supplied.
            </summary>
            <param name="world">The evaluation world.</param>
            <param name="bindings">A set of variable bindings.</param>
            <returns>Undefined, a numeric value, or the simplified expression.</returns>
            <exception cref="T:PDDLParser.Exception.BindingException">A BindingException is thrown if this
            variable is not bound.</exception>
        </member>
        <member name="M:PDDLParser.Exp.Formula.TLPlan.LocalVar.NumericVariable.Simplify(PDDLParser.World.IReadOnlyOpenWorld,PDDLParser.Exp.LocalBindings)">
            <summary>
            Evaluates this numeric expression in the specified closed world.
            The bindings should not be modified by this call.
            </summary>
            <param name="world">The evaluation world.</param>
            <param name="bindings">A set of variable bindings.</param>
            <returns>Undefined, or the resulting numeric value.</returns>
            <exception cref="T:PDDLParser.Exception.BindingException">A BindingException is thrown if this
            variable is not bound.</exception>
        </member>
        <member name="M:PDDLParser.Exp.Formula.TLPlan.LocalVar.NumericVariable.ToTypedString">
            <summary>
            Returns a typed string representation of this expression.
            </summary>
            <returns>A typed string representation of this expressin.</returns>
        </member>
        <member name="T:PDDLParser.Exp.Formula.TLPlan.LocalVar.AssignBooleanLocalVar">
            <summary>
            A boolean variable assignement as an assignement of a boolean value to a boolean variable.
            </summary>
        </member>
        <member name="M:PDDLParser.Exp.Formula.TLPlan.LocalVar.AssignBooleanLocalVar.#ctor(PDDLParser.Exp.Formula.TLPlan.LocalVar.BooleanLocalVariable,PDDLParser.Exp.ILogicalExp)">
            <summary>
            Creates a new boolean variable assignement for the specified boolean local variable
            and assignation expression.
            </summary>
            <param name="localVariable">The boolean local variable to assign a value to.</param>
            <param name="body">The assignation expression.</param>
        </member>
        <member name="M:PDDLParser.Exp.Formula.TLPlan.LocalVar.AssignBooleanLocalVar.BindLocalVariable(PDDLParser.World.IReadOnlyClosedWorld,PDDLParser.Exp.LocalBindings)">
            <summary>
            Binds the local variable associated with this assignment to the evaluated assignation
            expression.
            </summary>
            <param name="world">The evaluation world.</param>
            <param name="bindings">A set of variable bindings.</param>
        </member>
        <member name="M:PDDLParser.Exp.Formula.TLPlan.LocalVar.AssignBooleanLocalVar.TryBindLocalVariable(PDDLParser.World.IReadOnlyOpenWorld,PDDLParser.Exp.LocalBindings)">
            <summary>
            Tries and binds the local variable associated with this assignment to the evaluated assignation
            expression.
            Note that this function returns false if the assignation expression could not be evaluated.
            </summary>
            <param name="world">The evaluation world.</param>
            <param name="bindings">A set of variable bindings.</param>
            <returns>True if the binding was successfully done.</returns>
        </member>
        <member name="T:PDDLParser.Exp.Effect.Assign.ObjectAssign">
            <summary>
            This class represents an object fluent assignment.
            </summary>
        </member>
        <member name="T:PDDLParser.Exp.Effect.Assign.AssignEffect">
            <summary>
            This class represents a fluent assignment.
            </summary>
        </member>
        <member name="F:PDDLParser.Exp.Effect.Assign.AssignEffect.m_head">
            <summary>
            The fluent application to assign the value to.
            </summary>
        </member>
        <member name="F:PDDLParser.Exp.Effect.Assign.AssignEffect.m_body">
            <summary>
            The value to assign to the fluent application.
            </summary>
        </member>
        <member name="F:PDDLParser.Exp.Effect.Assign.AssignEffect.m_image">
            <summary>
            The image of this fluent assignment.
            </summary>
        </member>
        <member name="M:PDDLParser.Exp.Effect.Assign.AssignEffect.#ctor(System.String,PDDLParser.Exp.Formula.FluentApplication,PDDLParser.Exp.IEvaluableExp)">
            <summary>
            Creates a new fluent assignment.
            </summary>
            <param name="image">The image of this fluent assignment.</param>
            <param name="head">The fluent application to assign the value to.</param>
            <param name="body">The value to assign to the fluent application.</param>
        </member>
        <member name="M:PDDLParser.Exp.Effect.Assign.AssignEffect.UpdateWorldWithAssignEffect(PDDLParser.Exp.Formula.FluentApplication,PDDLParser.World.IDurativeOpenWorld,PDDLParser.Exp.LocalBindings)">
            <summary>
            Updates the world with this fluent assignment.
            </summary>
            <param name="head">The evaluated fluent application to update.</param>
            <param name="updateWorld">The world to update.</param>
            <param name="bindings">A set of variable bindings.</param>
        </member>
        <member name="M:PDDLParser.Exp.Effect.Assign.AssignEffect.Update(PDDLParser.World.IReadOnlyOpenWorld,PDDLParser.World.IDurativeOpenWorld,PDDLParser.Exp.LocalBindings,PDDLParser.ActionContext)">
            <summary>
            Updates the specified world with this effect.
            A fluent assignment assigns a value to a fluent.
            </summary>
            <param name="evaluationWorld">The world to evaluate conditions against.</param>
            <param name="updateWorld">The world to update.</param>
            <param name="bindings">A set of variable bindings.</param>
            <param name="actionContext">The action evaluation context.</param>
        </member>
        <member name="M:PDDLParser.Exp.Effect.Assign.AssignEffect.GetModifiedDescribedFormulas">
            <summary>
            Retrieves all the described formulas modified by this effect.
            </summary>
            <returns>All the described formulas modified by this effect.</returns>
        </member>
        <member name="M:PDDLParser.Exp.Effect.Assign.AssignEffect.Apply(PDDLParser.Exp.ParameterBindings)">
            <summary>
            Substitutes all occurrences of the variables that occur in this
            expression by their corresponding bindings.
            </summary>
            <param name="bindings">The bindings.</param>
            <returns>A substituted copy of this expression.</returns>
        </member>
        <member name="M:PDDLParser.Exp.Effect.Assign.AssignEffect.Standardize(System.Collections.Generic.IDictionary{System.String,System.String})">
            <summary>
            Standardizes all occurrences of the variables that occur in this
            expression. The IDictionary argument is used to store the variable already
            standardized. Remember that free variables are existentially quantified.
            </summary>
            <param name="images">The object that maps old variable images to the standardize
            image.</param>
            <returns>A standardized copy of this expression.</returns>
        </member>
        <member name="M:PDDLParser.Exp.Effect.Assign.AssignEffect.IsGround">
            <summary>
            Returns true if the expression is ground, i.e. it does not contain any variables.
            </summary>
            <returns>Whether the expression is ground.</returns>
        </member>
        <member name="M:PDDLParser.Exp.Effect.Assign.AssignEffect.GetFreeVariables">
            <summary>
            Returns the free variables in this expression.
            </summary>
            <returns>The free variables in this expression.</returns>
        </member>
        <member name="M:PDDLParser.Exp.Effect.Assign.AssignEffect.Equals(System.Object)">
            <summary>
            Returns true if this expression is equal to a specified object.
            </summary>
            <param name="obj">Object to test for equality.</param>
            <returns>True if this expression is equal to the specified objet.</returns>
        </member>
        <member name="M:PDDLParser.Exp.Effect.Assign.AssignEffect.GetHashCode">
            <summary>
            Returns the hash code of this fluent assignment.
            </summary>
            <returns>The hash code of this fluent assignment.</returns>
        </member>
        <member name="M:PDDLParser.Exp.Effect.Assign.AssignEffect.ToString">
            <summary>
            Returns a string representation of this fluent assignment.
            </summary>
            <returns>A string representation of this fluent assignment.</returns>
        </member>
        <member name="M:PDDLParser.Exp.Effect.Assign.AssignEffect.ToTypedString">
            <summary>
            Returns a typed string representation of this fluent assignment.
            </summary>
            <returns>A typed string representation of this fluent assignment.</returns>
        </member>
        <member name="M:PDDLParser.Exp.Effect.Assign.AssignEffect.CompareTo(PDDLParser.Exp.IExp)">
            <summary>
            Compares this fluent assignment with another expression.
            </summary>
            <param name="other">The other expression to compare this expression to.</param>
            <returns>An integer representing the total order relation between the two expressions.</returns>
        </member>
        <member name="M:PDDLParser.Exp.Effect.Assign.ObjectAssign.#ctor(PDDLParser.Exp.Formula.ObjectFluentApplication,PDDLParser.Exp.ITerm)">
            <summary>
            Creates a new object fluent assignment.
            </summary>
            <param name="head">The object fluent to assign a value to.</param>
            <param name="body">The value to assign to the object fluent.</param>
        </member>
        <member name="M:PDDLParser.Exp.Effect.Assign.ObjectAssign.UpdateWorldWithAssignEffect(PDDLParser.Exp.Formula.FluentApplication,PDDLParser.World.IDurativeOpenWorld,PDDLParser.Exp.LocalBindings)">
            <summary>
            Updates the world with this fluent assignment.
            </summary>
            <param name="head">The evaluated fluent application to update.</param>
            <param name="updateWorld">The world to update.</param>
            <param name="bindings">A set of variable bindings.</param>
        </member>
        <member name="P:PDDLParser.Exp.Effect.Assign.ObjectAssign.Head">
            <summary>
            Gets the object fluent to assign a value to.
            </summary>
        </member>
        <member name="P:PDDLParser.Exp.Effect.Assign.ObjectAssign.Body">
            <summary>
            Gets the numeric value to assign to the fluent.
            </summary>
        </member>
        <member name="T:PDDLParser.Exp.Effect.Assign.NumericAssign">
            <summary>
            This class represents a numeric fluent direct assignment.
            </summary>
        </member>
        <member name="T:PDDLParser.Exp.Effect.Assign.NumericAssignEffect">
            <summary>
            This class represents a numeric fluent assignment.
            </summary>
        </member>
        <member name="M:PDDLParser.Exp.Effect.Assign.NumericAssignEffect.#ctor(System.String,PDDLParser.Exp.Formula.NumericFluentApplication,PDDLParser.Exp.INumericExp)">
            <summary>
            Creates a new numeric fluent assignment.
            </summary>
            <param name="image">The image of this fluent assignment.</param>
            <param name="head">The numeric fluent to assign a value to.</param>
            <param name="body">The value to assign to the numeric fluent.</param>
        </member>
        <member name="P:PDDLParser.Exp.Effect.Assign.NumericAssignEffect.Head">
            <summary>
            Gets the numeric fluent to assign a value to.
            </summary>
        </member>
        <member name="P:PDDLParser.Exp.Effect.Assign.NumericAssignEffect.Body">
            <summary>
            Gets the numeric value to assign to the fluent.
            </summary>
        </member>
        <member name="M:PDDLParser.Exp.Effect.Assign.NumericAssign.#ctor(PDDLParser.Exp.Formula.NumericFluentApplication,PDDLParser.Exp.INumericExp)">
            <summary>
            Creates a new numeric fluent direct assignment.
            </summary>
            <param name="head">The numeric fluent to assign a value to.</param>
            <param name="body">The value to assign to the numeric fluent.</param>
        </member>
        <member name="M:PDDLParser.Exp.Effect.Assign.NumericAssign.UpdateWorldWithAssignEffect(PDDLParser.Exp.Formula.FluentApplication,PDDLParser.World.IDurativeOpenWorld,PDDLParser.Exp.LocalBindings)">
            <summary>
            Updates the world with this fluent assignment.
            </summary>
            <param name="head">The evaluated fluent application to update.</param>
            <param name="updateWorld">The world to update.</param>
            <param name="bindings">A set of variable bindings.</param>
        </member>
        <member name="T:PDDLParser.Exp.Constraint.TLPlan.NextExp">
            <summary>
            Represents the "next" operator of the LTL language. This is not part of PDDL; it was rather added
            for TLPlan.
            </summary>
            <remarks>
            The next operator specifies that a given constraint must be satisfied in the next world generated.
            </remarks>
        </member>
        <member name="M:PDDLParser.Exp.Constraint.TLPlan.NextExp.#ctor(PDDLParser.Exp.IConstraintExp)">
            <summary>
            Creates a new "next" constraint expression.
            </summary>
            <param name="arg">The body of the constraint expression.</param>
        </member>
        <member name="M:PDDLParser.Exp.Constraint.TLPlan.NextExp.Progress(PDDLParser.World.IReadOnlyDurativeClosedWorld,PDDLParser.Exp.LocalBindings)">
            <summary>
            Evaluates the progression of this constraint expression in the next worlds.
            </summary>
            <param name="world">The current world.</param>
            <param name="bindings">A set of variable bindings.</param>
            <returns>True, false, undefined, or a progressed expression.</returns>
            <exception cref="T:PDDLParser.Exception.BindingException">A BindingException is thrown if an attempt
            is made to evaluate an unbound variable.</exception>
            <seealso cref="M:PDDLParser.Exp.IConstraintExp.Progress(PDDLParser.World.IReadOnlyDurativeClosedWorld,PDDLParser.Exp.LocalBindings)"/>
        </member>
        <member name="M:PDDLParser.Exp.Constraint.TLPlan.NextExp.EvaluateIdle(PDDLParser.World.IReadOnlyDurativeClosedWorld,PDDLParser.Exp.LocalBindings)">
            <summary>
            Evaluates this constraint expression in an idle world, i.e. a world which
            won't be modified by further updates.
            </summary>
            <param name="idleWorld">The (idle) evaluation world.</param>
            <param name="bindings">A set of variable bindings.</param>
            <returns>True, false, or undefined.</returns>
            <exception cref="T:PDDLParser.Exception.BindingException">A BindingException is thrown if an attempt
            is made to evaluate an unbound variable.</exception>
            <seealso cref="M:PDDLParser.Exp.IConstraintExp.EvaluateIdle(PDDLParser.World.IReadOnlyDurativeClosedWorld,PDDLParser.Exp.LocalBindings)"/>
        </member>
        <member name="M:PDDLParser.Exp.Constraint.TLPlan.NextExp.ToString">
            <summary>
            Returns a string representation of this expression.
            </summary>
            <returns>A string representation of this expression.</returns>
        </member>
        <member name="M:PDDLParser.Exp.Constraint.TLPlan.NextExp.ToTypedString">
            <summary>
            Returns a typed string of this expression.
            </summary>
            <returns>A typed string representation of this expression.</returns>
        </member>
        <member name="T:PDDLParser.Action.DurationVariable">
            <summary>
            Represents the duration variable of the PDDL language (i.e. the "?duration" symbol).
            </summary>
        </member>
        <member name="M:PDDLParser.Action.DurationVariable.#ctor">
            <summary>
            Creates an instance of the duration variable.
            </summary>
        </member>
        <member name="M:PDDLParser.Action.DurationVariable.Evaluate(PDDLParser.World.IReadOnlyOpenWorld,PDDLParser.Exp.LocalBindings)">
            <summary>
            Evaluates this numeric expression in the specified open world.
            The bindings should not be modified by this call.
            </summary>
            <param name="world">The evaluation world.</param>
            <param name="bindings">A set of variable bindings.</param>
            <returns>Undefined, unknown, or the resulting numeric value.</returns>
            <exception cref="T:PDDLParser.Exception.BindingException">A BindingException is thrown if an attempt
            is made to evaluate an unbound variable.</exception>
            <exception cref="T:PDDLParser.Exception.NumericException">A NumericException is thrown if an 
            illegal operation is performed (like a division by zero).</exception>
        </member>
        <member name="M:PDDLParser.Action.DurationVariable.Evaluate(PDDLParser.World.IReadOnlyClosedWorld,PDDLParser.Exp.LocalBindings)">
            <summary>
            Evaluates this numeric expression in the specified closed world.
            The bindings should not be modified by this call.
            </summary>
            <param name="world">The evaluation world.</param>
            <param name="bindings">A set of variable bindings.</param>
            <returns>Undefined, or the resulting numeric value.</returns>
            <exception cref="T:PDDLParser.Exception.BindingException">A BindingException is thrown if an attempt
            is made to evaluate an unbound variable.</exception>
            <exception cref="T:PDDLParser.Exception.NumericException">A NumericException is thrown if an 
            illegal operation is performed (like a division by zero).</exception>
        </member>
        <member name="T:PDDLParser.Exp.Numeric.NArityAdd">
            <summary>
            This class implements a n-ary addition.
            </summary>
        </member>
        <member name="M:PDDLParser.Exp.Numeric.NArityAdd.#ctor(System.Collections.Generic.List{PDDLParser.Exp.INumericExp})">
            <summary>
            Creates a new addition function with the specified arguments.
            </summary>
            <param name="args">The arguments of the new addition function.</param>
        </member>
        <member name="M:PDDLParser.Exp.Numeric.NArityAdd.Calculate(System.Double[])">
            <summary>
            Calculates the sum of all the arguments.
            </summary>
            <param name="args">The arguments to call the function with.</param>
            <returns>The sum of all the arguments.</returns>
        </member>
        <member name="T:PDDLParser.Exp.Metric.MinimizeExp">
            <summary>
            Represents the minimize expression used in metric specification of the PDDL language.
            </summary>
        </member>
        <member name="M:PDDLParser.Exp.Metric.MinimizeExp.#ctor(PDDLParser.Exp.INumericExp,PDDLParser.Exp.INumericExp)">
            <summary>
            Creates a minimize metric with the given expression.
            </summary>
            <param name="exp">The expression to minimize.</param>
            <param name="unnamedPrefs">The unnamed preferences.</param>
        </member>
        <member name="M:PDDLParser.Exp.Metric.MinimizeExp.EvaluateMinimizedMetric(PDDLParser.World.IReadOnlyOpenWorld,PDDLParser.Exp.LocalBindings)">
            <summary>
            Returns a minimized version of the metric evaluated on a given world.
            </summary>
            <param name="world">The evaluation world.</param>
            <param name="bindings">A set of variable bindings.</param>
            <returns>The minimized version of the metric.</returns>
        </member>
        <member name="M:PDDLParser.Exp.Metric.MinimizeExp.EvaluateMinimizedMetric(PDDLParser.World.IReadOnlyClosedWorld,PDDLParser.Exp.LocalBindings)">
            <summary>
            Returns a minimized version of the metric evaluated on a given world.
            </summary>
            <param name="world">The evaluation world.</param>
            <param name="bindings">A set of variable bindings.</param>
            <returns>The minimized version of the metric.</returns>
        </member>
        <member name="P:PDDLParser.Exp.Metric.MinimizeExp.TypeName">
            <summary>
            Gets a string representatin of the type of optimization required.
            </summary>
        </member>
        <member name="T:PDDLParser.Exp.Metric.IsViolatedExp">
            <summary>
            Represents the "is-violated" expression of the PDDL language.
            </summary>
        </member>
        <member name="F:PDDLParser.Exp.Metric.IsViolatedExp.m_prefName">
            <summary>
            The name of the preference to monitor.
            </summary>
        </member>
        <member name="F:PDDLParser.Exp.Metric.IsViolatedExp.m_counter">
            <summary>
            The preference counter which counts action condition preferences violations.
            </summary>
        </member>
        <member name="F:PDDLParser.Exp.Metric.IsViolatedExp.m_constraintPrefs">
            <summary>
            The list of <see cref="T:PDDLParser.Exp.Formula.AtomicFormulaApplication"/> 
            objects that track constraint preferences violations.
            </summary>
        </member>
        <member name="F:PDDLParser.Exp.Metric.IsViolatedExp.m_goalPrefs">
            <summary>
            The list of goal preferences.
            </summary>
        </member>
        <member name="M:PDDLParser.Exp.Metric.IsViolatedExp.#ctor(System.String,PDDLParser.Exp.Formula.NumericFluentApplication)">
            <summary>
            Creates a new "is-violated" expression.
            </summary>
            <param name="prefName">The name of the preference to monitor.</param>
            <param name="counter">The preference counter which counts action condition preferences violations. This can be <see langword="null"/>.</param>
        </member>
        <member name="M:PDDLParser.Exp.Metric.IsViolatedExp.SetGoalPreferences(System.Collections.Generic.IEnumerable{PDDLParser.Exp.ILogicalExp})">
            <summary>
            Sets the goal preferences.
            </summary>
            <param name="goalPrefs">The goal preferences.</param>
        </member>
        <member name="M:PDDLParser.Exp.Metric.IsViolatedExp.SetConstraintPreferences(System.Collections.Generic.IEnumerable{PDDLParser.Exp.Formula.AtomicFormulaApplication})">
            <summary>
            Sets the list of <see cref="T:PDDLParser.Exp.Formula.AtomicFormulaApplication"/> 
            objects that track constraint preferences violations.
            </summary>
            <param name="constraintPrefs">The list of <see cref="T:PDDLParser.Exp.Formula.AtomicFormulaApplication"/> 
            objects that track constraint preferences violations.</param>
        </member>
        <member name="M:PDDLParser.Exp.Metric.IsViolatedExp.Evaluate(PDDLParser.World.IReadOnlyOpenWorld,PDDLParser.Exp.LocalBindings)">
            <summary>
            Evaluates this "is-violated" expression in the specified open world.
            The bindings should not be modified by this call.
            </summary>
            <param name="world">The evaluation world.</param>
            <param name="bindings">A set of variable bindings.</param>
            <returns>Undefined, or the resulting numeric value.</returns>
        </member>
        <member name="M:PDDLParser.Exp.Metric.IsViolatedExp.Evaluate(PDDLParser.World.IReadOnlyClosedWorld,PDDLParser.Exp.LocalBindings)">
            <summary>
            Evaluates this "is-violated" expression in the specified closed world.
            The bindings should not be modified by this call.
            </summary>
            <param name="world">The evaluation world.</param>
            <param name="bindings">A set of variable bindings.</param>
            <returns>Undefined, or the resulting numeric value.</returns>
        </member>
        <member name="M:PDDLParser.Exp.Metric.IsViolatedExp.ToString">
            <summary>
            Returns a string representation of this expression.
            </summary>
            <returns>A string representation of this expression.</returns>
        </member>
        <member name="M:PDDLParser.Exp.Metric.IsViolatedExp.GetHashCode">
            <summary>
            Returns the hash code of this expression.
            </summary>
            <returns>The hash code of this expression.</returns>
        </member>
        <member name="P:PDDLParser.Exp.Metric.IsViolatedExp.PreferenceName">
            <summary>
            Gets the name of the preference to monitor.
            </summary>
        </member>
        <member name="T:PDDLParser.Exp.Metric.ForallConditionPrefExp">
            <summary>
            Represents a quantified conditional preference expression of the PDDL language, i.e. a
            quantified preference that lies in an action's conditions or in a goal.
            </summary>
        </member>
        <member name="T:PDDLParser.Exp.IConditionPrefExp">
            <summary>
            Represents a conditional preference, be it in an action's conditions, or in a goal.
            <remarks>
            Preferences in action conditions are transformed into counters which are incremented
            every time the action is used.
            </remarks>
            </summary>
        </member>
        <member name="M:PDDLParser.Exp.IConditionPrefExp.ConvertToEffect(PDDLParser.Exp.Formula.NumericFluentApplication)">
            <summary>
            Converts an action condition preference into the appropriate effect, which will increment the preference's
            counter every time the action is used.
            </summary>
            <param name="counter">The preference's counter</param>
            <returns>The effect to append to the action's effects.</returns>
        </member>
        <member name="M:PDDLParser.Exp.IConditionPrefExp.GetViolationCondition">
            <summary>
            Returns the violation condition of this preference. This is only to be used on goal preferences.
            The violation condition is true if the preference has been violated.
            </summary>
            <remarks>It is an error to call this on a quantified preference. Call <see cref="M:PDDLParser.Exp.IConditionPrefExp.GetAllSubstitutedConditionPreferences"/> first.</remarks>
            <returns>The violation condition of the preference.</returns>
        </member>
        <member name="M:PDDLParser.Exp.IConditionPrefExp.GetAllSubstitutedConditionPreferences">
            <summary>
            Returns all substituted preferences in their simplest form. This will therefore expand quantified expressions.
            </summary>
            <returns>All substituted and grounded (against the preference quantifiers) preferences.</returns>
            <remarks>An unquantified preference returns only itself.</remarks>
        </member>
        <member name="M:PDDLParser.Exp.IConditionPrefExp.GetCondition">
            <summary>
            Returns the original condition of the preference.
            </summary>
            <returns>The original condition of the preference.</returns>
        </member>
        <member name="P:PDDLParser.Exp.IConditionPrefExp.IsGoalPreference">
            <summary>
            Gets or sets whether this is a goal preference. Goal preferences are only evaluated on a goal world.
            </summary>
        </member>
        <member name="M:PDDLParser.Exp.Metric.ForallConditionPrefExp.#ctor(System.Collections.Generic.HashSet{PDDLParser.Exp.Term.ObjectParameterVariable},PDDLParser.Exp.IConditionPrefExp)">
            <summary>
            Creates a new quantified condition preference expression.
            </summary>
            <param name="vars">The set of variables quantifying the preference expression.</param>
            <param name="pref">The quantified preference expression.</param>
        </member>
        <member name="M:PDDLParser.Exp.Metric.ForallConditionPrefExp.ConvertToEffect(PDDLParser.Exp.Formula.NumericFluentApplication)">
            <summary>
            Converts an action condition preference into the appropriate effect, which will increment the preference's
            counter every time the action is used.
            </summary>
            <param name="counter">The preference's counter</param>
            <returns>The effect to append to the action's effects.</returns>
        </member>
        <member name="M:PDDLParser.Exp.Metric.ForallConditionPrefExp.GetViolationCondition">
            <summary>
            It is an error to call this on a quantified preference.
            Call <see cref="M:PDDLParser.Exp.Metric.ForallConditionPrefExp.GetAllSubstitutedConditionPreferences"/> first.
            </summary>
            <returns>Throws an exception.</returns>
            <exception cref="T:System.NotSupportedException">Thrown when this is called on a quantified expression.</exception>
        </member>
        <member name="M:PDDLParser.Exp.Metric.ForallConditionPrefExp.GetAllSubstitutedConditionPreferences">
            <summary>
            Returns all substituted preferences in their simplest form. This will therefore expand quantified expressions.
            </summary>
            <returns>All substituted and grounded (against the preference quantifiers) preferences.</returns>
        </member>
        <member name="M:PDDLParser.Exp.Metric.ForallConditionPrefExp.GetCondition">
            <summary>
            Returns the original condition of the preference.
            </summary>
            <returns>The original condition of the preference.</returns>
        </member>
        <member name="M:PDDLParser.Exp.Metric.ForallConditionPrefExp.GetPreference">
            <summary>
            Returns the wrapped conditional preference expression.
            </summary>
            <returns>The wrapped conditional preference expression.</returns>
        </member>
        <member name="P:PDDLParser.Exp.Metric.ForallConditionPrefExp.IsGoalPreference">
            <summary>
            Gets or sets whether this is a goal preference. Goal preferences are only evaluated on a goal world.
            </summary>
        </member>
        <member name="T:PDDLParser.Exp.Metric.AbstractPrefExp">
            <summary>
            Represents the common part of all preference expressions of the PDDL language.
            </summary>
        </member>
        <member name="F:PDDLParser.Exp.Metric.AbstractPrefExp.m_name">
            <summary>
            The name of this preference.
            </summary>
        </member>
        <member name="F:PDDLParser.Exp.Metric.AbstractPrefExp.m_exp">
            <summary>
            The expression that this preference could violate.
            </summary>
        </member>
        <member name="F:PDDLParser.Exp.Metric.AbstractPrefExp.m_unnamed">
            <summary>
            Whether this preference is unnamed.
            </summary>
        </member>
        <member name="M:PDDLParser.Exp.Metric.AbstractPrefExp.#ctor(System.String,PDDLParser.Exp.IExp,System.Boolean)">
            <summary>
            Creates a new preference expression.
            </summary>
            <param name="name">The name of this preference.</param>
            <param name="exp">The preference's body.</param>
            <param name="unnamed">Whether this preference is unnamed.</param>
        </member>
        <member name="M:PDDLParser.Exp.Metric.AbstractPrefExp.#ctor(System.String,PDDLParser.Exp.IExp)">
            <summary>
            Creates a new, named preference expression.
            </summary>
            <param name="name">The name of this preference.</param>
            <param name="exp">The preference's body.</param>
        </member>
        <member name="M:PDDLParser.Exp.Metric.AbstractPrefExp.GetOriginalExp">
            <summary>
            Returns the original expression that this preference could violate.
            </summary>
            <returns>The original expression that this preference could violate.</returns>
        </member>
        <member name="M:PDDLParser.Exp.Metric.AbstractPrefExp.Apply(PDDLParser.Exp.ParameterBindings)">
            <summary>
            Substitutes all occurrences of the variables that occur in this
            preference by their corresponding bindings.
            </summary>
            <param name="bindings">The bindings.</param>
            <returns>A substituted copy of this preference.</returns>
        </member>
        <member name="M:PDDLParser.Exp.Metric.AbstractPrefExp.Standardize(System.Collections.Generic.IDictionary{System.String,System.String})">
            <summary>
            Standardizes all occurrences of the variables that occur in this
            preference. The IDictionary argument is used to store the variable already
            standardized. Remember that free variables are existentially quantified.
            </summary>
            <param name="images">The object that maps old variable images to the standardize
            image.</param>
            <returns>A standardized copy of this preference.</returns>
        </member>
        <member name="M:PDDLParser.Exp.Metric.AbstractPrefExp.IsGround">
            <summary>
            Returns true if the preference is ground, i.e. it does not contain any variables.
            </summary>
            <returns>Whether the preference is ground.</returns>
        </member>
        <member name="M:PDDLParser.Exp.Metric.AbstractPrefExp.Equals(System.Object)">
            <summary>
            Returns true if this preference is equal to a specified object.
            </summary>
            <param name="obj">Object to test for equality.</param>
            <returns>True if this preference is equal to the specified objet.</returns>
        </member>
        <member name="M:PDDLParser.Exp.Metric.AbstractPrefExp.GetHashCode">
            <summary>
            Returns the hash code of this preference.
            </summary>
            <returns>The hash code of this preference.</returns>
        </member>
        <member name="M:PDDLParser.Exp.Metric.AbstractPrefExp.GetFreeVariables">
            <summary>
            Returns the free variables in this preference.
            </summary>
            <returns>The free variables in this preference.</returns>
        </member>
        <member name="M:PDDLParser.Exp.Metric.AbstractPrefExp.ToString">
            <summary>
            Returns a string representation of this preference.
            </summary>
            <returns>A string representation of this preference.</returns>
        </member>
        <member name="M:PDDLParser.Exp.Metric.AbstractPrefExp.ToTypedString">
            <summary>
            Returns a typed string of this preference.
            </summary>
            <returns>A typed string representation of this preference.</returns>
        </member>
        <member name="M:PDDLParser.Exp.Metric.AbstractPrefExp.CompareTo(PDDLParser.Exp.IExp)">
            <summary>
            Compares this preference with another expression.
            </summary>
            <param name="other">The other expression to compare this preference to.</param>
            <returns>An integer representing the total order relation between the two expressions.</returns>
        </member>
        <member name="P:PDDLParser.Exp.Metric.AbstractPrefExp.Unnamed">
            <summary>
            Gets whether this preference is unnamed.
            </summary>
            <remarks>
            Even if a preference is unnamed, it still has a name. This name, however,
            is not parsable; therefore, a user cannot produce a preference with the same
            name as an unnamed preference.
            </remarks>
        </member>
        <member name="P:PDDLParser.Exp.Metric.AbstractPrefExp.Name">
            <summary>
            Returns the name of this preference.
            </summary>
            <seealso cref="P:PDDLParser.Exp.Metric.AbstractPrefExp.Unnamed"/>
        </member>
        <member name="T:PDDLParser.Exp.Formula.AtomicFormula">
            <summary>
            An atomic formula is a boolean described formula (a described predicate).
            </summary>
        </member>
        <member name="M:PDDLParser.Exp.Formula.AtomicFormula.#ctor(System.String,System.Collections.Generic.List{PDDLParser.Exp.Term.ObjectParameterVariable},PDDLParser.Exp.Formula.DescribedFormula.Attributes)">
            <summary>
            Creates a new atomic formula with the specified name and arguments.
            </summary>
            <param name="name">The name of this atomic formula.</param>
            <param name="arguments">The arguments of this atomic formula.</param>
            <param name="attributes">The new atomic formula's attributes.</param>
        </member>
        <member name="M:PDDLParser.Exp.Formula.AtomicFormula.Instantiate(System.Collections.Generic.List{PDDLParser.Exp.ITerm})">
            <summary>
            Instantiates a formula application associated with this atomic formula.
            </summary>
            <param name="arguments">Arguments of the formula application to instantiate.</param>
            <returns>A new atomic formula application associated with this atomic formula.</returns>
        </member>
        <member name="T:PDDLParser.Exp.Constraint.TLPlan.TEventuallyExp">
            <summary>
            Represents the "t-eventually" constraint expression. This is a time-bounded version of
            TLPlan's "eventually" constraint expression, which is equivalent to the  <see cref="T:PDDLParser.Exp.Constraint.SometimeExp"/>
            constraint expression. This is not part of the PDDL language; it was rather added for TLPlan.
            This constraint expression uses timestamps relative to the first time it is progressed.
            </summary>
            <seealso cref="T:PDDLParser.Exp.Constraint.SometimeExp"/>
        </member>
        <member name="M:PDDLParser.Exp.Constraint.TLPlan.TEventuallyExp.#ctor(PDDLParser.Exp.Struct.TimeInterval,PDDLParser.Exp.IConstraintExp)">
            <summary>
            Creates a new "t-eventually" constraint expression.
            </summary>
            <param name="interval">The relative time interal to when the expression is first progressed.</param>
            <param name="exp">The body of the constraint expression.</param>
        </member>
        <member name="M:PDDLParser.Exp.Constraint.TLPlan.TEventuallyExp.Progress(PDDLParser.World.IReadOnlyDurativeClosedWorld,PDDLParser.Exp.LocalBindings)">
            <summary>
            Evaluates the progression of this constraint expression in the next worlds.
            This creates an instance of <see cref="T:PDDLParser.Exp.Constraint.TLPlan.AbsoluteTEventuallyExp"/> for progression.
            </summary>
            <param name="world">The current world.</param>
            <param name="bindings">A set of variable bindings.</param>
            <returns>True, false, undefined, or a progressed expression.</returns>
            <exception cref="T:PDDLParser.Exception.BindingException">A BindingException is thrown if an attempt
            is made to evaluate an unbound variable.</exception>
            <seealso cref="M:PDDLParser.Exp.IConstraintExp.Progress(PDDLParser.World.IReadOnlyDurativeClosedWorld,PDDLParser.Exp.LocalBindings)"/>
            <seealso cref="T:PDDLParser.Exp.Constraint.TLPlan.AbsoluteTEventuallyExp"/>
        </member>
        <member name="M:PDDLParser.Exp.Constraint.TLPlan.TEventuallyExp.EvaluateIdle(PDDLParser.World.IReadOnlyDurativeClosedWorld,PDDLParser.Exp.LocalBindings)">
            <summary>
            Evaluates this constraint expression in an idle world, i.e. a world which
            won't be modified by further updates.
            This creates an instance of <see cref="T:PDDLParser.Exp.Constraint.TLPlan.AbsoluteTEventuallyExp"/> for evaluation.
            </summary>
            <param name="idleWorld">The (idle) evaluation world.</param>
            <param name="bindings">A set of variable bindings.</param>
            <returns>True, false, or undefined.</returns>
            <exception cref="T:PDDLParser.Exception.BindingException">A BindingException is thrown if an attempt
            is made to evaluate an unbound variable.</exception>
            <seealso cref="M:PDDLParser.Exp.IConstraintExp.EvaluateIdle(PDDLParser.World.IReadOnlyDurativeClosedWorld,PDDLParser.Exp.LocalBindings)"/>
            <seealso cref="T:PDDLParser.Exp.Constraint.TLPlan.AbsoluteTEventuallyExp"/>
        </member>
        <member name="T:PDDLParser.Exp.Constraint.SometimeExp">
            <summary>
            Represents the "sometime" constraint expression of the PDDL language.
            Note that this is equivalent to the TLPlan "eventually" constraint.
            </summary>
        </member>
        <member name="M:PDDLParser.Exp.Constraint.SometimeExp.#ctor(PDDLParser.Exp.IConstraintExp)">
            <summary>
            Creates a new "sometime" constraint expression.
            </summary>
            <param name="arg">The body of the constraint expression.</param>
        </member>
        <member name="M:PDDLParser.Exp.Constraint.SometimeExp.Progress(PDDLParser.World.IReadOnlyDurativeClosedWorld,PDDLParser.Exp.LocalBindings)">
            <summary>
            Evaluates the progression of this constraint expression in the next worlds.
            </summary>
            <param name="world">The current world.</param>
            <param name="bindings">A set of variable bindings.</param>
            <returns>True, false, undefined, or a progressed expression.</returns>
            <exception cref="T:PDDLParser.Exception.BindingException">A BindingException is thrown if an attempt
            is made to evaluate an unbound variable.</exception>
            <seealso cref="M:PDDLParser.Exp.IConstraintExp.Progress(PDDLParser.World.IReadOnlyDurativeClosedWorld,PDDLParser.Exp.LocalBindings)"/>
        </member>
        <member name="M:PDDLParser.Exp.Constraint.SometimeExp.EvaluateIdle(PDDLParser.World.IReadOnlyDurativeClosedWorld,PDDLParser.Exp.LocalBindings)">
            <summary>
            Evaluates this constraint expression in an idle world, i.e. a world which
            won't be modified by further updates.
            </summary>
            <param name="idleWorld">The (idle) evaluation world.</param>
            <param name="bindings">A set of variable bindings.</param>
            <returns>True, false, or undefined.</returns>
            <exception cref="T:PDDLParser.Exception.BindingException">A BindingException is thrown if an attempt
            is made to evaluate an unbound variable.</exception>
            <seealso cref="M:PDDLParser.Exp.IConstraintExp.EvaluateIdle(PDDLParser.World.IReadOnlyDurativeClosedWorld,PDDLParser.Exp.LocalBindings)"/>
        </member>
        <member name="M:PDDLParser.Exp.Constraint.SometimeExp.ToString">
            <summary>
            Returns a string representation of this expression.
            </summary>
            <returns>A string representation of this expression.</returns>
        </member>
        <member name="M:PDDLParser.Exp.Constraint.SometimeExp.ToTypedString">
            <summary>
            Returns a typed string of this expression.
            </summary>
            <returns>A typed string representation of this expression.</returns>
        </member>
        <member name="T:PDDLParser.Exp.Constraint.AbstractNotExp`1">
            <summary>
            Base class for negation expressions.
            </summary>
            <typeparam name="T">The type of the expression to negate.</typeparam>
        </member>
        <member name="F:PDDLParser.Exp.Constraint.AbstractNotExp`1.m_exp">
            <summary>
            The expression to negate.
            </summary>
        </member>
        <member name="M:PDDLParser.Exp.Constraint.AbstractNotExp`1.#ctor(`0)">
            <summary>
            Creates a new negative expression.
            </summary>
            <param name="exp">The expression to negate.</param>
        </member>
        <member name="M:PDDLParser.Exp.Constraint.AbstractNotExp`1.Apply(PDDLParser.Exp.ParameterBindings)">
            <summary>
            Substitutes all occurrences of the variables that occur in this
            expression by their corresponding bindings.
            </summary>
            <param name="bindings">A set of variable bindings.</param>
            <returns>A substituted copy of this expression.</returns>
        </member>
        <member name="M:PDDLParser.Exp.Constraint.AbstractNotExp`1.Standardize(System.Collections.Generic.IDictionary{System.String,System.String})">
            <summary>
            Standardizes all occurrences of the variables that occur in this
            expression. Remember that free variables are existentially quantified.
            </summary>
            <param name="images">The object that maps old variable images to the standardize
            image.</param>
            <returns>A standardized copy of this expression.</returns>
        </member>
        <member name="M:PDDLParser.Exp.Constraint.AbstractNotExp`1.IsGround">
            <summary>
            Returns true if the expression is ground, i.e. it does not contain any variables.
            </summary>
            <returns>Whether the expression is ground.</returns>
        </member>
        <member name="M:PDDLParser.Exp.Constraint.AbstractNotExp`1.Equals(System.Object)">
            <summary>
            Returns true if this expression is equal to a specified object.
            </summary>
            <param name="obj">Object to test for equality.</param>
            <returns>True if this expression is equal to the specified objet.</returns>
        </member>
        <member name="M:PDDLParser.Exp.Constraint.AbstractNotExp`1.GetHashCode">
            <summary>
            Returns the hash code of this expression.
            </summary>
            <returns>The hash code of this expression.</returns>
        </member>
        <member name="M:PDDLParser.Exp.Constraint.AbstractNotExp`1.GetFreeVariables">
            <summary>
            Returns the free variables in this expression.
            </summary>
            <returns>The free variables in this expression.</returns>
        </member>
        <member name="M:PDDLParser.Exp.Constraint.AbstractNotExp`1.ToString">
            <summary>
            Returns a string representation of this expression.
            </summary>
            <returns>A string representation of this expression.</returns>
        </member>
        <member name="M:PDDLParser.Exp.Constraint.AbstractNotExp`1.ToTypedString">
            <summary>
            Returns a typed string representation of this expression.
            </summary>
            <returns>A typed string representation of this expression.</returns>
        </member>
        <member name="M:PDDLParser.Exp.Constraint.AbstractNotExp`1.CompareTo(PDDLParser.Exp.IExp)">
            <summary>
            Compares this expression with another expression.
            </summary>
            <param name="other">The other expression to compare this expression to.</param>
            <returns>An integer representing the total order relation between the two expressions.</returns>
        </member>
        <member name="P:PDDLParser.Exp.Constraint.AbstractNotExp`1.Exp">
            <summary>
            Gets the negated expression.
            </summary>
        </member>
        <member name="T:PDDLParser.Exp.Constraint.NotConstraintExp">
            <summary>
            Represents the negation of a constraint expression.
            </summary>
        </member>
        <member name="M:PDDLParser.Exp.Constraint.NotConstraintExp.#ctor(PDDLParser.Exp.IConstraintExp)">
            <summary>
            Creates a new negative expression.
            </summary>
            <param name="exp">The constraint expression to negate.</param>
        </member>
        <member name="M:PDDLParser.Exp.Constraint.NotConstraintExp.Progress(PDDLParser.World.IReadOnlyDurativeClosedWorld,PDDLParser.Exp.LocalBindings)">
            <summary>
            Evaluates the progression of this constraint expression in the next worlds.
            The algorithm is: Progress(not formula1) =&gt; (not Progress(formula1))
            </summary>
            <param name="world">The current world.</param>
            <param name="bindings">A set of variable bindings.</param>
            <returns>True, false, undefined, or a progressed expression.</returns>
            <exception cref="T:PDDLParser.Exception.BindingException">A BindingException is thrown if an attempt
            is made to evaluate an unbound variable.</exception>
            <seealso cref="M:PDDLParser.Exp.IConstraintExp.Progress(PDDLParser.World.IReadOnlyDurativeClosedWorld,PDDLParser.Exp.LocalBindings)"/>
        </member>
        <member name="M:PDDLParser.Exp.Constraint.NotConstraintExp.EvaluateIdle(PDDLParser.World.IReadOnlyDurativeClosedWorld,PDDLParser.Exp.LocalBindings)">
            <summary>
            Evaluates this constraint expression in an idle world, i.e. a world which
            won't be modified by further updates.
            </summary>
            <param name="idleWorld">The (idle) evaluation world.</param>
            <param name="bindings">A set of variable bindings.</param>
            <returns>True, false, or undefined.</returns>
            <exception cref="T:PDDLParser.Exception.BindingException">A BindingException is thrown if an attempt
            is made to evaluate an unbound variable.</exception>
            <seealso cref="M:PDDLParser.Exp.IConstraintExp.EvaluateIdle(PDDLParser.World.IReadOnlyDurativeClosedWorld,PDDLParser.Exp.LocalBindings)"/>
        </member>
        <member name="T:PDDLParser.Parser.RequireKey">
            <summary>
            A require key indicates the specific functionality needed by a planner to attempt 
            to solve a PDDL domain or problem.
            </summary>
        </member>
        <member name="F:PDDLParser.Parser.RequireKey.STRIPS">
            <summary>
            The PDDL :strips requirement.
            </summary>
        </member>
        <member name="F:PDDLParser.Parser.RequireKey.TYPING">
            <summary>
            The PDDL :typing requirement.
            </summary>
        </member>
        <member name="F:PDDLParser.Parser.RequireKey.NEGATIVE_PRECONDITIONS">
            <summary>
            The PDDL :negative-preconditions requirement.
            </summary>
        </member>
        <member name="F:PDDLParser.Parser.RequireKey.DISJUNCTIVE_PRECONDITIONS">
            <summary>
            The PDDL :disjunctive-preconditions requirement.
            </summary>
        </member>
        <member name="F:PDDLParser.Parser.RequireKey.EQUALITY">
            <summary>
            The PDDL :equality requirement.
            </summary>
        </member>
        <member name="F:PDDLParser.Parser.RequireKey.EXISTENTIAL_PRECONDITIONS">
            <summary>
            The PDDL :existential-preconditions requirement.
            </summary>
        </member>
        <member name="F:PDDLParser.Parser.RequireKey.UNIVERSAL_PRECONDITIONS">
            <summary>
            The PDDL :universal-preconditions requirement.
            </summary>
        </member>
        <member name="F:PDDLParser.Parser.RequireKey.QUANTIFIED_PRECONDITIONS">
            <summary>
            The PDDL :quantified-preconditions requirement.
            </summary>
        </member>
        <member name="F:PDDLParser.Parser.RequireKey.CONDITIONAL_EFFECTS">
            <summary>
            The PDDL :conditional-effects requirement.
            </summary>
        </member>
        <member name="F:PDDLParser.Parser.RequireKey.NUMERIC_FLUENTS">
            <summary>
            The PDDL :numeric-fluents requirement.
            </summary>
        </member>
        <member name="F:PDDLParser.Parser.RequireKey.OBJECT_FLUENTS">
            <summary>
            The PDDL :object-fluents requirement.
            </summary>
        </member>
        <member name="F:PDDLParser.Parser.RequireKey.FLUENTS">
            <summary>
            The PDDL :fluents requirement.
            </summary>
        </member>
        <member name="F:PDDLParser.Parser.RequireKey.ADL">
            <summary>
            The PDDL :adl requirement.
            </summary>
        </member>
        <member name="F:PDDLParser.Parser.RequireKey.DURATIVE_ACTIONS">
            <summary>
            The PDDL :durative-actions requirement.
            </summary>
        </member>
        <member name="F:PDDLParser.Parser.RequireKey.DERIVED_PREDICATES">
            <summary>
            The PDDL :derived-predicates requirement.
            </summary>
        </member>
        <member name="F:PDDLParser.Parser.RequireKey.TIMED_INITIAL_LITERALS">
            <summary>
            The PDDL :timed-initial-literals requirement.
            </summary>
        </member>
        <member name="F:PDDLParser.Parser.RequireKey.PREFERENCES">
            <summary>
            The PDDL :preferences requirement.
            </summary>
        </member>
        <member name="F:PDDLParser.Parser.RequireKey.CONSTRAINTS">
            <summary>
            The PDDL :constraints requirement.
            </summary>
        </member>
        <member name="F:PDDLParser.Parser.RequireKey.CONTINOUS_EFFECTS">
            <summary>
            The PDDL :continuous-effects requirement.
            </summary>
        </member>
        <member name="F:PDDLParser.Parser.RequireKey.DURATION_INEQUALITIES">
            <summary>
            The PDDL :duration-inequalities requirement.
            </summary>
        </member>
        <member name="F:PDDLParser.Parser.RequireKey.TLPLAN">
            <summary>
            The TLPlan requirement (TLPlan-specific constructs).
            </summary>
        </member>
        <member name="F:PDDLParser.Parser.RequireKey.AllKeys">
            <summary>
            The set of all require keys.
            </summary>
        </member>
        <member name="F:PDDLParser.Parser.RequireKey.image">
            <summary>
            The image associated with this require key.
            </summary>
        </member>
        <member name="M:PDDLParser.Parser.RequireKey.#ctor(System.String)">
            <summary>
            Creates a new require key with a specific image.
            </summary>
            <param name="image">The image of the new require key.</param>
        </member>
        <member name="M:PDDLParser.Parser.RequireKey.GetRequireKey(System.String)">
            <summary>
            Returns the require key that corresponds to the specified image.
            </summary>
            <param name="image">The image of the require key to find.</param>
            <returns>The require key that corresponds to the specified image.</returns>
        </member>
        <member name="M:PDDLParser.Parser.RequireKey.GetImage">
            <summary>
            Returns the image of this require key.
            </summary>
            <returns>The image of this require key.</returns>
        </member>
        <member name="M:PDDLParser.Parser.RequireKey.ToString">
            <summary>
            Returns a string representation of this require key.
            </summary>
            <returns>A string representation of this require key.</returns>
        </member>
        <member name="T:PDDLParser.Exp.Term.Type.TypeSet">
            <summary>
            Represents a set of primitives types. This set can contain one or multiple types.
            </summary>
            <remarks>
            All primitive types (see <see cref="T:PDDLParser.Exp.Term.Type.Type"/>) 
            have their own <see cref="T:PDDLParser.Exp.Term.Type.TypeSet"/>.
            Typesets containing more than one type can be constructed using the <c>either</c> PDDL keyword.
            </remarks>
        </member>
        <member name="F:PDDLParser.Exp.Term.Type.TypeSet.m_types">
            <summary>
            The set on types in this typeset.
            </summary>
        </member>
        <member name="F:PDDLParser.Exp.Term.Type.TypeSet.m_subTypes">
            <summary>
            The direct subtypes of the types contained in this typeset.
            </summary>
        </member>
        <member name="F:PDDLParser.Exp.Term.Type.TypeSet.m_superTypes">
            <summary>
            The direct supertypes of the types contained in this typeset.
            </summary>
        </member>
        <member name="F:PDDLParser.Exp.Term.Type.TypeSet.m_allSubTypes">
            <summary>
            All the direct and indirect subtypes of the types contained in this typeset.
            </summary>
        </member>
        <member name="F:PDDLParser.Exp.Term.Type.TypeSet.m_allSuperTypes">
            <summary>
            All the direct and indirect supertypes of the types contained in this typeset.
            </summary>
        </member>
        <member name="F:PDDLParser.Exp.Term.Type.TypeSet.m_domainCache">
            <summary>
            This typeset's domain cache.
            </summary>
        </member>
        <member name="M:PDDLParser.Exp.Term.Type.TypeSet.CreateTypeSets(System.Collections.Generic.IDictionary{System.String,PDDLParser.Exp.Term.Type.Type})">
            <summary>
            Creates the original typesets containing only a single primitive type from the hierarchy of primitive types.
            </summary>
            <param name="types">The hierarchy of primitive types.</param>
            <returns>A dictionary that maps typeset names to their corresponding typeset.</returns>
        </member>
        <member name="M:PDDLParser.Exp.Term.Type.TypeSet.#ctor(PDDLParser.Exp.Term.Type.Type)">
            <summary>
            Creates a new typeset, containing only the given type.
            </summary>
            <param name="type">The single type in the typeset.</param>
        </member>
        <member name="M:PDDLParser.Exp.Term.Type.TypeSet.#ctor">
            <summary>
            Creates an empty typeset.
            </summary>
            <remarks>
            This is only to be used by <see cref="T:PDDLParser.Exp.Term.Type.TypeSet"/> and <see cref="T:PDDLParser.Exp.Term.Type.TypeSetSet"/>.
            Unfortunately, there was no way in C# to restrain the use of this method to those classes.
            </remarks>
        </member>
        <member name="M:PDDLParser.Exp.Term.Type.TypeSet.CanBeAssignedFrom(PDDLParser.Exp.Term.Type.TypeSet)">
            <summary>
            Returns whether this typeset can be assigned from another typeset.
            </summary>
            <remarks>
            A typeset is considered assignable from another one if the set of all its direct and indirect
            subtypes, along with the typeset itself, is a superset of the set of all the other typeset's
            direct and indirect subtypes.
            </remarks>
            <param name="other">The typeset from which we want to assign to this one.</param>
            <returns>True if this typeset can be assigned from the other typeset; false otherwise.</returns>
        </member>
        <member name="M:PDDLParser.Exp.Term.Type.TypeSet.IsComparableTo(PDDLParser.Exp.Term.Type.TypeSet)">
            <summary>
            Returns whether this typeset is comparable to another typeset.
            </summary>
            <remarks>
            A typeset is considered comparable to another one if the set of all its direct and indirect
            subtypes, along with the typeset itself, overlaps the set of all the other typeset's
            direct and indirect subtypes.
            </remarks>
            <param name="other">The other typeset to which this one is to be compared.</param>
            <returns>True if this typeset is comparable to the other typeset; false otherwise.</returns>
        </member>
        <member name="M:PDDLParser.Exp.Term.Type.TypeSet.Preprocess">
            <summary>
            Preprocesses this typeset, creating the domain cache and updating its constants IDs.
            </summary>
            <remarks>
            This has to be called before any call to <see cref="P:PDDLParser.Exp.Term.Type.TypeSet.Domain"/> is made.
            </remarks>
        </member>
        <member name="M:PDDLParser.Exp.Term.Type.TypeSet.GetConstant(System.Int32)">
            <summary>
            Returns the <see cref="T:PDDLParser.Exp.Term.Constant"/> whose ID is the given one.
            </summary>
            <param name="constantID">The constant ID.</param>
            <returns>The <see cref="T:PDDLParser.Exp.Term.Constant"/> corresponding to the ID.</returns>
            <exception cref="T:System.ArgumentOutOfRangeException">Thrown if the ID does not
            correspond to any <see cref="T:PDDLParser.Exp.Term.Constant"/>.</exception>
        </member>
        <member name="M:PDDLParser.Exp.Term.Type.TypeSet.Merge(PDDLParser.Exp.Term.Type.TypeSet)">
            <summary>
            Merges this typeset with another one, invalidating the domain cache.
            </summary>
            <remarks>
            This is only to be used by <see cref="T:PDDLParser.Exp.Term.Type.TypeSetSet"/>.
            Unfortunately, there was no way in C# to restrain the use of this method to the aforementionned class.
            </remarks>
            <param name="typeSet">The other typeset which is to be merged in this one.</param>
        </member>
        <member name="M:PDDLParser.Exp.Term.Type.TypeSet.Type_TypeDomainChanged(PDDLParser.Exp.Term.Type.Type)">
            <summary>
            This is the event handler for the <see cref="E:PDDLParser.Exp.Term.Type.Type.TypeDomainChanged"/> event.
            This invalidates the domain cache and forwards the event to registered objects.
            </summary>
            <param name="type">The primitive type whose domain has changed.</param>
        </member>
        <member name="M:PDDLParser.Exp.Term.Type.TypeSet.TypeSet_TypeDomainChanged(PDDLParser.Exp.Term.Type.TypeSet)">
            <summary>
            This is the event handler for the <see cref="E:PDDLParser.Exp.Term.Type.TypeSet.TypeDomainChanged"/> event.
            This invalidates the domain cache and forwards the event to registered objects.
            </summary>
            <param name="typeset">The typeset whose domain has changed.</param>
        </member>
        <member name="M:PDDLParser.Exp.Term.Type.TypeSet.FireTypeDomainChanged">
            <summary>
            Fires the <see cref="E:PDDLParser.Exp.Term.Type.TypeSet.TypeDomainChanged"/> event, using this typeset as the argument.
            </summary>
        </member>
        <member name="M:PDDLParser.Exp.Term.Type.TypeSet.GetEnumerator">
            <summary>
            Returns an enumerator over the primitive types forming this typeset.
            </summary>
            <returns>An enumerator over the primitive types forming this typeset.</returns>
        </member>
        <member name="M:PDDLParser.Exp.Term.Type.TypeSet.System#Collections#IEnumerable#GetEnumerator">
            <summary>
            Returns an enumerator over the primitive types forming this typeset.
            </summary>
            <returns>An enumerator over the primitive types forming this typeset.</returns>
        </member>
        <member name="M:PDDLParser.Exp.Term.Type.TypeSet.Equals(System.Object)">
            <summary>
            Returns true if this typeset is equal to a specified object.
            Two typesets are equal if they contain the same types.
            </summary>
            <param name="obj">Object to test for equality.</param>
            <returns>True if this typeset is equal to the specified objet.</returns>
        </member>
        <member name="M:PDDLParser.Exp.Term.Type.TypeSet.GetHashCode">
            <summary>
            Returns the hash code of this typeset.
            </summary>
            <returns>The hash code of this typeset.</returns>
        </member>
        <member name="M:PDDLParser.Exp.Term.Type.TypeSet.ToString">
            <summary>
            Returns a string representation of typeset.
            </summary>
            <returns>A string representation of typeset.</returns>
        </member>
        <member name="P:PDDLParser.Exp.Term.Type.TypeSet.Name">
            <summary>
            Gets the name of this typeset.
            </summary>
        </member>
        <member name="P:PDDLParser.Exp.Term.Type.TypeSet.SubTypes">
            <summary>
            Gets the direct subtypes of the types contained in this typeset.
            </summary>
        </member>
        <member name="P:PDDLParser.Exp.Term.Type.TypeSet.SuperTypes">
            <summary>
            Gets the direct supertypes of the types contained in this typeset.
            </summary>
        </member>
        <member name="P:PDDLParser.Exp.Term.Type.TypeSet.AllSubTypes">
            <summary>
            Gets all the direct and indirect subtypes of the types contained in this typeset.
            </summary>
        </member>
        <member name="P:PDDLParser.Exp.Term.Type.TypeSet.AllSuperTypes">
            <summary>
            Gets all the direct and indirect supertypes of the types contained in this typeset.
            </summary>
        </member>
        <member name="P:PDDLParser.Exp.Term.Type.TypeSet.Domain">
            <summary>
            Retrieves this typeset's domain.
            </summary>
            <remarks>
            A call to <see cref="M:PDDLParser.Exp.Term.Type.TypeSet.Preprocess"/> is required to cache the typeset's domain.
            </remarks>
        </member>
        <member name="E:PDDLParser.Exp.Term.Type.TypeSet.TypeDomainChanged">
            <summary>
            This event is triggered whenever the typeset's domain changes. This is used to clear cached domains.
            </summary>
            <seealso cref="T:PDDLParser.Exp.Term.Type.Type"/>
        </member>
        <member name="T:PDDLParser.Exp.Term.Type.TypeSet.TypeSetEventHandler">
            <summary>
            A delegate used with the <see cref="T:PDDLParser.Exp.Term.Type.TypeSet.TypeSetEventHandler"/> event.
            </summary>
            <param name="sender">Teh typeset whose domain has changed.</param>
        </member>
        <member name="T:PDDLParser.Exp.Term.Type.UndefinedTypeSet">
            <summary>
            Represents the <see cref="T:PDDLParser.Exp.Term.Type.TypeSet"/> of the <c>Undefined</c> constant.
            </summary>
            <remarks>
            The <see cref="T:PDDLParser.Exp.Term.Type.UndefinedTypeSet"/> class was created so that the <see cref="M:PDDLParser.Exp.Term.Type.TypeSet.CanBeAssignedFrom(PDDLParser.Exp.Term.Type.TypeSet)"/>
            and <see cref="M:PDDLParser.Exp.Term.Type.TypeSet.IsComparableTo(PDDLParser.Exp.Term.Type.TypeSet)"/> methods can work properly with <c>Undefined</c> values.
            </remarks>
        </member>
        <member name="F:PDDLParser.Exp.Term.Type.UndefinedTypeSet.s_instance">
            <summary>
            This is the only instance of <see cref="T:PDDLParser.Exp.Term.Type.UndefinedTypeSet"/>.
            </summary>
        </member>
        <member name="M:PDDLParser.Exp.Term.Type.UndefinedTypeSet.#cctor">
            <summary>
            Initializes the static fields of this class.
            </summary>
        </member>
        <member name="M:PDDLParser.Exp.Term.Type.UndefinedTypeSet.#ctor">
            <summary>
            Creates an empty typeset, representing the <c>Undefined</c> constant.
            </summary>
        </member>
        <member name="M:PDDLParser.Exp.Term.Type.UndefinedTypeSet.CanBeAssignedFrom(PDDLParser.Exp.Term.Type.TypeSet)">
            <summary>
            Returns whether this typeset can be assigned from another typeset.
            </summary>
            <param name="other">The typeset from which we want to assign to this one.</param>
            <returns>False.</returns>
            <seealso cref="M:PDDLParser.Exp.Term.Type.TypeSet.CanBeAssignedFrom(PDDLParser.Exp.Term.Type.TypeSet)"/>
        </member>
        <member name="M:PDDLParser.Exp.Term.Type.UndefinedTypeSet.IsComparableTo(PDDLParser.Exp.Term.Type.TypeSet)">
            <summary>
            Returns whether this typeset is comparable to another typeset.
            </summary>
            <param name="other">The other typeset to which this one is to be compared.</param>
            <returns>False.</returns>
            <seealso cref="M:PDDLParser.Exp.Term.Type.TypeSet.IsComparableTo(PDDLParser.Exp.Term.Type.TypeSet)"/>
        </member>
        <member name="P:PDDLParser.Exp.Term.Type.UndefinedTypeSet.Instance">
            <summary>
            Gets the only instance of <see cref="T:PDDLParser.Exp.Term.Type.UndefinedTypeSet"/>.
            </summary>
        </member>
        <member name="T:PDDLParser.Exp.Term.Constant">
            <summary>
            A constant is an object of a specific type defined in either the domain or problem.
            </summary>
        </member>
        <member name="F:PDDLParser.Exp.Term.Constant.m_name">
            <summary>
            The name of this constant.
            </summary>
        </member>
        <member name="F:PDDLParser.Exp.Term.Constant.m_typesetToConstantIDs">
            <summary>
            The mappings from each typeset to the specified constant ID. For example,
            the constant "robot1" may be the 12th "object" but the 1st "robot".
            </summary>
        </member>
        <member name="M:PDDLParser.Exp.Term.Constant.#ctor(System.String,PDDLParser.Exp.Term.Type.TypeSet)">
            <summary>
            Creates a new constant with the specified name and typeset.
            </summary>
            <param name="name">The name of the new constant.</param>
            <param name="typeSet">The typeset of the new constant.</param>
        </member>
        <member name="M:PDDLParser.Exp.Term.Constant.SetTypeSet(PDDLParser.Exp.Term.Type.TypeSet)">
            <summary>
            Sets the typeset of this constant. This function should only be used internally.
            </summary>
            <param name="typeSet">The typeset of this constant.</param>
        </member>
        <member name="M:PDDLParser.Exp.Term.Constant.GetConstantID(PDDLParser.Exp.Term.Type.TypeSet)">
            <summary>
            Returns the constant ID corresponding to the given typeset.
            </summary>
            <param name="typeSet">A typeset this constant is member of.</param>
            <returns>The constant ID corresponding to the given typeset.</returns>
        </member>
        <member name="M:PDDLParser.Exp.Term.Constant.SetConstantID(PDDLParser.Exp.Term.Type.TypeSet,System.Int32)">
            <summary>
            Sets the constant ID corresponding to the given typeset.
            </summary>
            <param name="typeSet">A typeset this constant is member of.</param>
            <param name="constantID">The constant ID corresponding to this typeset.</param>
        </member>
        <member name="M:PDDLParser.Exp.Term.Constant.Evaluate(PDDLParser.World.IReadOnlyOpenWorld,PDDLParser.Exp.LocalBindings)">
            <summary>
            Evaluates this term in the specified open world.
            A constant expression evaluates to itself.
            </summary>
            <param name="world">The evaluation world.</param>
            <param name="bindings">A set of variable bindings.</param>
            <returns>This constant expression.</returns>
        </member>
        <member name="M:PDDLParser.Exp.Term.Constant.Simplify(PDDLParser.World.IReadOnlyOpenWorld,PDDLParser.Exp.LocalBindings)">
            <summary>
            Simplifies this term by evaluating its known expression parts.
            A constant expression simplifies to itself.
            </summary>
            <param name="world">The evaluation world.</param>
            <param name="bindings">A set of variable bindings.</param>
            <returns>This constant expression.</returns>
        </member>
        <member name="M:PDDLParser.Exp.Term.Constant.Evaluate(PDDLParser.World.IReadOnlyClosedWorld,PDDLParser.Exp.LocalBindings)">
            <summary>
            Evaluates this term in the specified closed world.
            A constant expression evaluates to itself.
            </summary>
            <param name="world">The evaluation world.</param>
            <param name="bindings">A set of variable bindings.</param>
            <returns>This constant expression.</returns>
        </member>
        <member name="M:PDDLParser.Exp.Term.Constant.IsGround">
            <summary>
            Returns true if the expression is ground, i.e. it does not contain any variables.
            A constant expression is ground.
            </summary>
            <returns>True.</returns>
        </member>
        <member name="M:PDDLParser.Exp.Term.Constant.GetFreeVariables">
            <summary>
            Returns the free variables in this expression.
            A constant expression holds no free variables.
            </summary>
            <returns>The empty set.</returns>
        </member>
        <member name="M:PDDLParser.Exp.Term.Constant.Equals(System.Object)">
            <summary>
            Returns whether this constant is equal to another object.
            </summary>
            <param name="obj">The other object to test for equality.</param>
            <returns>True if this constant is equal to another object.</returns>
        </member>
        <member name="M:PDDLParser.Exp.Term.Constant.GetHashCode">
            <summary>
            Returns the hash code of this constant.
            </summary>
            <returns>The hash code of this constant.</returns>
        </member>
        <member name="M:PDDLParser.Exp.Term.Constant.ToString">
            <summary>
            Returns a string representation of this constant.
            </summary>
            <returns>A string representation of this constant.</returns>
        </member>
        <member name="M:PDDLParser.Exp.Term.Constant.ToTypedString">
            <summary>
            Returns a typed string representation of this constant.
            </summary>
            <returns>A typed string representation of this constant.</returns>
        </member>
        <member name="M:PDDLParser.Exp.Term.Constant.CompareTo(PDDLParser.Exp.IExp)">
            <summary>
            Compares this constant with another expression.
            </summary>
            <param name="other">The other expression to compare this constant to.</param>
            <returns>An integer representing the total order relation between the two expressions.
            </returns>
        </member>
        <member name="M:PDDLParser.Exp.Term.Constant.CompareTo(PDDLParser.Exp.Term.Constant)">
            <summary>
            Compares this constant with another constant.
            </summary>
            <param name="other">The other constant to compare this constant to.</param>
            <returns>An integer representing the total order relation between the two constants.
            </returns>
        </member>
        <member name="P:PDDLParser.Exp.Term.Constant.Name">
            <summary>
            Gets the name of this constant.
            </summary>
        </member>
        <member name="T:PDDLParser.Exp.Struct.FuzzyBoolValue">
            <summary>
            All possible FuzzyBool values.
            </summary>
        </member>
        <member name="F:PDDLParser.Exp.Struct.FuzzyBoolValue.False">
            <summary>
            The false FuzzyBool value.
            </summary>
        </member>
        <member name="F:PDDLParser.Exp.Struct.FuzzyBoolValue.Undefined">
            <summary>
            The undefined FuzzyBool value.
            </summary>
        </member>
        <member name="F:PDDLParser.Exp.Struct.FuzzyBoolValue.Unknown">
            <summary>
            The unknown FuzzyBool value.
            </summary>
        </member>
        <member name="F:PDDLParser.Exp.Struct.FuzzyBoolValue.True">
            <summary>
            The true FuzzyBool value.
            </summary>
        </member>
        <member name="T:PDDLParser.Exp.Struct.FuzzyBool">
            <summary>
            A FuzzyBool represents a fuzzy boolean value possibly undefined or unknown.
            It wraps a FuzzyBoolValue.
            Hence its domain is { False, Undefined, Unknown, True }.
            
            Note that ¬Undefined = Undefined and ¬Unknown = Unknown.
            FuzzyBool.False shortcircuits conjunctions and FuzzyBool.True shortcircuits disjunctions.
            FuzzyBool.Undefined and FuzzyBool.Unknown do not shortcircuit the evaluation.
            </summary>
        </member>
        <member name="F:PDDLParser.Exp.Struct.FuzzyBool.False">
            <summary>
            FuzzyBool false value.
            </summary>
        </member>
        <member name="F:PDDLParser.Exp.Struct.FuzzyBool.Undefined">
            <summary>
            FuzzyBool undefined value.
            </summary>
        </member>
        <member name="F:PDDLParser.Exp.Struct.FuzzyBool.Unknown">
            <summary>
            FuzzyBool unknown value.
            </summary>
        </member>
        <member name="F:PDDLParser.Exp.Struct.FuzzyBool.True">
            <summary>
            FuzzyBool true value.
            </summary>
        </member>
        <member name="F:PDDLParser.Exp.Struct.FuzzyBool.m_value">
            <summary>
            The corresponding FuzzyBoolValue of this FuzzyBool value.
            </summary>
        </member>
        <member name="M:PDDLParser.Exp.Struct.FuzzyBool.#ctor(System.Boolean)">
            <summary>
            Creates a new FuzzyBool from a specified boolean value.
            </summary>
            <param name="value">A boolean value.</param>
        </member>
        <member name="M:PDDLParser.Exp.Struct.FuzzyBool.#ctor(PDDLParser.Exp.Struct.FuzzyBoolValue)">
            <summary>
            Creates a new FuzzyBool from a specified FuzzyBoolValue.
            This constructor should stay private.
            </summary>
            <param name="value">A FuzzyBoolValue.</param>
        </member>
        <member name="M:PDDLParser.Exp.Struct.FuzzyBool.#ctor(PDDLParser.Exp.Struct.BoolValue)">
            <summary>
            Creates a new FuzzyBool from a specified BoolValue.
            </summary>
            <param name="value">A BoolValue.</param>
        </member>
        <member name="M:PDDLParser.Exp.Struct.FuzzyBool.BoolValueToFuzzyBoolValue(PDDLParser.Exp.Struct.BoolValue)">
            <summary>
            Returns the FuzzyBoolValue corresponding to a BoolValue.
            </summary>
            <param name="value">A BoolValue.</param>
            <returns>The FuzzyBoolValue corresponding to the BoolValue.</returns>
        </member>
        <member name="M:PDDLParser.Exp.Struct.FuzzyBool.FuzzyBoolValueToBoolValue(PDDLParser.Exp.Struct.FuzzyBoolValue)">
            <summary>
            Returns the BoolValue value corresponding to a FuzzyBoolValue.
            Note that FuzzyBoolValue.Unknown cannot be converted to BoolValue and thus throws
            and UnknownEvaluationResultException.
            </summary>
            <param name="value">A FuzzyBoolValue.</param>
            <returns>The FuzzyBoolValue corresponding to the BoolValue.</returns>
        </member>
        <member name="M:PDDLParser.Exp.Struct.FuzzyBool.ToBoolValue">
            <summary>
            Returns the corresponding Bool value of this FuzzyBool.
            Note that FuzzyBool.Unknown cannot be converted to boolean and thus 
            throws an UnknownEvaluationResultException.
            </summary>
            <returns>The corresponding Bool value of this FuzzyBool.</returns>
        </member>
        <member name="M:PDDLParser.Exp.Struct.FuzzyBool.ToBool">
            <summary>
            Returns the corresponding boolean value of this FuzzyBool.
            FuzzyBool.True yields true,
            FuzzyBool.False and FuzzyBool.Undefined both yield false.
            FuzzyBool.Unknown cannot be converted to boolean and thus 
            throws an UnknownEvaluationResultException.
            </summary>
            <returns>The boolean value of this FuzzyBool.</returns>
        </member>
        <member name="M:PDDLParser.Exp.Struct.FuzzyBool.op_Equality(PDDLParser.Exp.Struct.FuzzyBool,PDDLParser.Exp.Struct.FuzzyBool)">
            <summary>
            Checks whether the two FuzzyBool values are equivalent.
            </summary>
            <param name="x">The first FuzzyBool value.</param>
            <param name="y">The second FuzzyBool value.</param>
            <returns>True if the two FuzzyBool values are equivalent.</returns>
        </member>
        <member name="M:PDDLParser.Exp.Struct.FuzzyBool.op_Inequality(PDDLParser.Exp.Struct.FuzzyBool,PDDLParser.Exp.Struct.FuzzyBool)">
            <summary>
            Checks whether the two FuzzyBool values are different.
            </summary>
            <param name="x">The first FuzzyBool value.</param>
            <param name="y">The second FuzzyBool value.</param>
            <returns>True if the two FuzzyBool values are different.</returns>
        </member>
        <member name="M:PDDLParser.Exp.Struct.FuzzyBool.op_OnesComplement(PDDLParser.Exp.Struct.FuzzyBool)">
            <summary>
            Returns the negation of this FuzzyBool value.
            ¬False = True
            ¬Undefined = Undefined
            ¬Unknown = Unknown
            ¬True = True
            </summary>
            <param name="x">The FuzzyBool value to negate.</param>
            <returns>The negation of this FuzzyBool value.</returns>
        </member>
        <member name="M:PDDLParser.Exp.Struct.FuzzyBool.op_LogicalNot(PDDLParser.Exp.Struct.FuzzyBool)">
            <summary>
            False shortcircuit operator.
            A FuzzyBool value is false if its inner value is FuzzyBool.False
            </summary>
            <param name="x">The FuzzyBool value to test.</param>
            <returns>True if the FuzzyBool value is FuzzyBool.False</returns>
        </member>
        <member name="M:PDDLParser.Exp.Struct.FuzzyBool.op_False(PDDLParser.Exp.Struct.FuzzyBool)">
            <summary>
            False shortcircuit operator.
            A FuzzyBool value is false if its inner value is FuzzyBool.False
            </summary>
            <param name="x">The FuzzyBool value to test.</param>
            <returns>True if the FuzzyBool value is FuzzyBool.False</returns>
        </member>
        <member name="M:PDDLParser.Exp.Struct.FuzzyBool.op_True(PDDLParser.Exp.Struct.FuzzyBool)">
            <summary>
            True shortcircuit operator.
            A FuzzyBool value is true if its inner value is FuzzyBool.True
            </summary>
            <param name="x">The FuzzyBool value to test.</param>
            <returns>True if the FuzzyBool value is FuzzyBool.True</returns>
        </member>
        <member name="M:PDDLParser.Exp.Struct.FuzzyBool.op_BitwiseOr(PDDLParser.Exp.Struct.FuzzyBool,PDDLParser.Exp.Struct.FuzzyBool)">
            <summary>
            Returns the disjunction of two FuzzyBool values.
            The resulting FuzzyBool value corresponds to the maximum FuzzyBoolValue 
            of the two operands.
            </summary>
            <param name="x">The first FuzzyBool value.</param>
            <param name="y">The second FuzzyBool value.</param>
            <returns>The disjunction of the two FuzzyBool values.</returns>
        </member>
        <member name="M:PDDLParser.Exp.Struct.FuzzyBool.op_BitwiseAnd(PDDLParser.Exp.Struct.FuzzyBool,PDDLParser.Exp.Struct.FuzzyBool)">
            <summary>
            Returns the conjunction of two FuzzyBool values.
            The resulting FuzzyBool value corresponds to the minimum FuzzyBoolValue
            of the two operands.
            </summary>
            <param name="x">The first FuzzyBool value.</param>
            <param name="y">The second FuzzyBool value.</param>
            <returns>The conjunction of the two FuzzyBool values.</returns>
        </member>
        <member name="M:PDDLParser.Exp.Struct.FuzzyBool.op_ExclusiveOr(PDDLParser.Exp.Struct.FuzzyBool,PDDLParser.Exp.Struct.FuzzyBool)">
            <summary>
            Returns the exclusive disjunction of two FuzzyBool values.
            </summary>
            <param name="x">The first FuzzyBool value.</param>
            <param name="y">The second FuzzyBool value.</param>
            <returns>The exclusive disjunction of the two FuzzyBool values.</returns>
        </member>
        <member name="M:PDDLParser.Exp.Struct.FuzzyBool.op_Implicit(PDDLParser.Exp.Struct.FuzzyBool)~PDDLParser.Exp.Struct.FuzzyBoolValue">
            <summary>
            Returns the FuzzyBoolValue associated with a FuzzyBool value.
            </summary>
            <param name="x">The FuzzyBool value.</param>
            <returns>The FuzzyBoolValue associated with the FuzzyBool value.</returns>
        </member>
        <member name="M:PDDLParser.Exp.Struct.FuzzyBool.Equals(System.Object)">
            <summary>
            Returns true if this FuzzyBool value is equal to another object.
            </summary>
            <param name="obj">The other object to test for equality.</param>
            <returns>True if this FuzzyBool value is equal to the other object.</returns>
        </member>
        <member name="M:PDDLParser.Exp.Struct.FuzzyBool.GetHashCode">
            <summary>
            Returns the hashcode of this FuzzyBool value.
            </summary>
            <returns>The hashcode of this FuzzyBool value.</returns>
        </member>
        <member name="M:PDDLParser.Exp.Struct.FuzzyBool.ToString">
            <summary>
            Returns a string representation of the FuzzyBool value.
            </summary>
            <returns>A string representation of the FuzzyBool value.</returns>
        </member>
        <member name="P:PDDLParser.Exp.Struct.FuzzyBool.Value">
            <summary>
            Returns the FuzzyBoolValue associated with this FuzzyBool.
            </summary>
        </member>
        <member name="T:PDDLParser.Exp.Numeric.TLPlan.NArityAbsoluteValue">
            <summary>
            This class implements the absolute value function, which generalizes to n arguments
            by computing the euclidean norm.
            This is not part of PDDL; it was rather added for TLPlan.
            </summary>
        </member>
        <member name="M:PDDLParser.Exp.Numeric.TLPlan.NArityAbsoluteValue.#ctor(System.Collections.Generic.List{PDDLParser.Exp.INumericExp})">
            <summary>
            Creates a new absolute value function with the specified arguments.
            </summary>
            <param name="args">The arguments of the new absolute value function.</param>
        </member>
        <member name="M:PDDLParser.Exp.Numeric.TLPlan.NArityAbsoluteValue.Calculate(System.Double[])">
            <summary>
            Calculates the euclidean norm of the given arguments (used as a vector).
            </summary>
            <param name="args">The arguments to call the function with.</param>
            <returns>The euclidean norm of the given arguments.</returns>
        </member>
        <member name="T:PDDLParser.Exp.Numeric.NArityDivide">
            <summary>
            This class implements a n-ary division.
            If only one argument is given, the result is the multiplicative inverse.
            </summary>
        </member>
        <member name="M:PDDLParser.Exp.Numeric.NArityDivide.#ctor(System.Collections.Generic.List{PDDLParser.Exp.INumericExp})">
            <summary>
            Creates a new division function with the specified arguments.
            </summary>
            <param name="args">The arguments of the new division function.</param>
        </member>
        <member name="M:PDDLParser.Exp.Numeric.NArityDivide.Calculate(System.Double[])">
            <summary>
            Calculates the left-associative quotient of the arguments.
            If only one argument is given, the result is the multiplicative inverse.
            </summary>
            <param name="args">The arguments to call the function with.</param>
            <returns>The left-associative quotient of the arguments.</returns>
            <exception cref="T:PDDLParser.Exception.NumericException">A NumericException is thrown if a division
            by 0 occurs.</exception>
        </member>
        <member name="T:PDDLParser.Exp.Metric.TotalTimeExp">
            <summary>
            Represents the "total-time" expression of the PDDL language.
            </summary>
        </member>
        <member name="M:PDDLParser.Exp.Metric.TotalTimeExp.#ctor">
            <summary>
            Creates a new "total-time" expression.
            </summary>
        </member>
        <member name="M:PDDLParser.Exp.Metric.TotalTimeExp.Evaluate(PDDLParser.World.IReadOnlyOpenWorld,PDDLParser.Exp.LocalBindings)">
            <summary>
            Evaluates this numeric expression in the specified open world.
            The bindings should not be modified by this call.
            </summary>
            <param name="world">The evaluation world.</param>
            <param name="bindings">A set of variable bindings.</param>
            <returns>Undefined, unknown, or the resulting numeric value.</returns>
            <exception cref="T:PDDLParser.Exception.BindingException">A BindingException is thrown if an attempt
            is made to evaluate an unbound variable.</exception>
            <exception cref="T:PDDLParser.Exception.NumericException">A NumericException is thrown if an 
            illegal operation is performed (like a division by zero).</exception>
        </member>
        <member name="M:PDDLParser.Exp.Metric.TotalTimeExp.Evaluate(PDDLParser.World.IReadOnlyClosedWorld,PDDLParser.Exp.LocalBindings)">
            <summary>
            Evaluates this numeric expression in the specified closed world.
            The bindings should not be modified by this call.
            </summary>
            <param name="world">The evaluation world.</param>
            <param name="bindings">A set of variable bindings.</param>
            <returns>Undefined, or the resulting numeric value.</returns>
            <exception cref="T:PDDLParser.Exception.BindingException">A BindingException is thrown if an attempt
            is made to evaluate an unbound variable.</exception>
            <exception cref="T:PDDLParser.Exception.NumericException">A NumericException is thrown if an 
            illegal operation is performed (like a division by zero).</exception>
        </member>
        <member name="T:PDDLParser.Exp.Metric.OverAllConditionPrefExp">
            <summary>
            Represents a conditional preference expression of the PDDL language occuring
            in an "over all" condition of a durative action.
            </summary>
            <remarks>
            This class wraps another <see cref="T:PDDLParser.Exp.IConditionPrefExp"/> preference.
            </remarks>
        </member>
        <member name="F:PDDLParser.Exp.Metric.OverAllConditionPrefExp.m_prefExp">
            <summary>
            The wrapped <see cref="T:PDDLParser.Exp.IConditionPrefExp"/> preference.
            </summary>
        </member>
        <member name="F:PDDLParser.Exp.Metric.OverAllConditionPrefExp.m_atom">
            <summary>
            The <see cref="T:PDDLParser.Exp.Formula.AtomicFormulaApplication"/> used in the 
            action context which tracks whether the preference has been violated.
            </summary>
        </member>
        <member name="F:PDDLParser.Exp.Metric.OverAllConditionPrefExp.m_action">
            <summary>
            The action in which this preference occurs.
            </summary>
        </member>
        <member name="M:PDDLParser.Exp.Metric.OverAllConditionPrefExp.#ctor(PDDLParser.Exp.IConditionPrefExp,PDDLParser.Action.DurativeAction)">
            <summary>
            Creates a new "over all" preference expression.
            </summary>
            <param name="pref">The wrapped preference.</param>
            <param name="action">The action in which this preference occurs.</param>
        </member>
        <member name="M:PDDLParser.Exp.Metric.OverAllConditionPrefExp.GetOverallEffect">
            <summary>
            Returns the effect that must be applied after the over all conditions have been asserted.
            </summary>
            <remarks>
            The over all effect is used to update, in the action context, whether the preference has been
            violated. It by no means modifies the world itself.
            </remarks>
            <returns>The effect that must be applied after the over all conditions have been asserted.</returns>
        </member>
        <member name="M:PDDLParser.Exp.Metric.OverAllConditionPrefExp.SetAtom(PDDLParser.Exp.Formula.AtomicFormulaApplication)">
            <summary>
            Sets the <see cref="T:PDDLParser.Exp.Formula.AtomicFormulaApplication"/> used 
            in the action context which tracks whether the preference has been violated.
            </summary>
            <param name="atom">The <see cref="T:PDDLParser.Exp.Formula.AtomicFormulaApplication"/> used 
            in the action context which tracks whether the preference has been violated.</param>
        </member>
        <member name="M:PDDLParser.Exp.Metric.OverAllConditionPrefExp.GetAction">
            <summary>
            Gets the durative action in which the preference occurs.
            </summary>
            <returns>The durative action which the preference occurs.</returns>
        </member>
        <member name="M:PDDLParser.Exp.Metric.OverAllConditionPrefExp.ConvertToEffect(PDDLParser.Exp.Formula.NumericFluentApplication)">
            <summary>
            Converts an action condition preference into the appropriate effect, which will increment the preference's
            counter every time the action is used.
            </summary>
            <param name="counter">The preference's counter</param>
            <returns>The effect to append to the action's effects.</returns>
            <remarks>The counter will be incremented only if the predicate <see cref="F:PDDLParser.Exp.Metric.OverAllConditionPrefExp.m_atom"/> is set in the action context.</remarks>
            <seealso cref="M:PDDLParser.Exp.IConditionPrefExp.ConvertToEffect(PDDLParser.Exp.Formula.NumericFluentApplication)"/>
        </member>
        <member name="M:PDDLParser.Exp.Metric.OverAllConditionPrefExp.GetAllSubstitutedConditionPreferences">
            <summary>
            Returns all substituted preferences in their simplest form. This will therefore expand quantified expressions.
            </summary>
            <returns>All substituted and grounded (against the preference quantifiers) preferences.</returns>
            <remarks>An unquantified preference returns only itself.</remarks>
        </member>
        <member name="M:PDDLParser.Exp.Metric.OverAllConditionPrefExp.GetViolationCondition">
            <summary>
            It is an error to call this method on <see cref="T:PDDLParser.Exp.Metric.OverAllConditionPrefExp"/>, as this is surely not a goal preference.
            See <see cref="M:PDDLParser.Exp.IConditionPrefExp.GetViolationCondition"/>.
            </summary>
            <returns>Nothing; throws an exception.</returns>
            <exception cref="T:System.NotSupportedException">Thrown when this is called on <see cref="T:PDDLParser.Exp.Metric.OverAllConditionPrefExp"/>.</exception>
            <seealso cref="M:PDDLParser.Exp.IConditionPrefExp.GetViolationCondition"/>
        </member>
        <member name="M:PDDLParser.Exp.Metric.OverAllConditionPrefExp.GetCondition">
            <summary>
            Returns the original condition of the preference.
            </summary>
            <returns>The original condition of the preference.</returns>
        </member>
        <member name="M:PDDLParser.Exp.Metric.OverAllConditionPrefExp.GetOriginalExp">
            <summary>
            Returns the body of the preference.
            </summary>
            <returns>The body of the preference.</returns>
        </member>
        <member name="M:PDDLParser.Exp.Metric.OverAllConditionPrefExp.IsGround">
            <summary>
            Returns true if the preference is ground, i.e. it does not contain any variables.
            </summary>
            <returns>Whether the preference is ground.</returns>
        </member>
        <member name="M:PDDLParser.Exp.Metric.OverAllConditionPrefExp.GetFreeVariables">
            <summary>
            Returns the free variables in this preference.
            </summary>
            <returns>The free variables in this preference.</returns>
        </member>
        <member name="M:PDDLParser.Exp.Metric.OverAllConditionPrefExp.Equals(System.Object)">
            <summary>
            Returns true if this preference is equal to a specified object.
            </summary>
            <param name="obj">Object to test for equality.</param>
            <returns>True if this preference is equal to the specified objet.</returns>
        </member>
        <member name="M:PDDLParser.Exp.Metric.OverAllConditionPrefExp.GetHashCode">
            <summary>
            Returns the hash code of this preference.
            </summary>
            <returns>The hash code of this preference.</returns>
        </member>
        <member name="M:PDDLParser.Exp.Metric.OverAllConditionPrefExp.ToTypedString">
            <summary>
            Returns a typed string of this preference.
            </summary>
            <returns>A typed string representation of this preference.</returns>
        </member>
        <member name="M:PDDLParser.Exp.Metric.OverAllConditionPrefExp.ToString">
            <summary>
            Returns a string representation of this preference.
            </summary>
            <returns>A string representation of this preference.</returns>
        </member>
        <member name="P:PDDLParser.Exp.Metric.OverAllConditionPrefExp.IsGoalPreference">
            <summary>
            Gets whether this is a goal preference. Always returns false for <see cref="T:PDDLParser.Exp.Metric.OverAllConditionPrefExp"/>.
            </summary>
            <remarks>It is an error to set a <see cref="T:PDDLParser.Exp.Metric.OverAllConditionPrefExp"/> as a goal preference.</remarks>
            <exception cref="T:System.NotSupportedException">Thrown when trying to set this property on <see cref="T:PDDLParser.Exp.Metric.OverAllConditionPrefExp"/>.</exception>
        </member>
        <member name="P:PDDLParser.Exp.Metric.OverAllConditionPrefExp.Unnamed">
            <summary>
            Gets whether this preference is unnamed.
            </summary>
            <seealso cref="P:PDDLParser.Exp.IPrefExp.Unnamed"/>
        </member>
        <member name="P:PDDLParser.Exp.Metric.OverAllConditionPrefExp.Name">
            <summary>
            Returns the name of the preferences.
            </summary>
            <seealso cref="P:PDDLParser.Exp.IPrefExp.Name"/>
        </member>
        <member name="T:PDDLParser.Exp.Constraint.HoldAfterExp">
            <summary>
            Represents the "hold-after" constraint expression of the PDDL language.
            This constraint expression uses timestamps relative to the first time it is progressed.
            </summary>
        </member>
        <member name="M:PDDLParser.Exp.Constraint.HoldAfterExp.#ctor(PDDLParser.Exp.IConstraintExp,System.Double)">
            <summary>
            Creates a new "hold-after" constraint expression.
            </summary>
            <param name="arg">The constraint that must hold after a given timestamp.</param>
            <param name="relativeTimestamp">The relative timestamp after which the constraint must hold.</param>
        </member>
        <member name="M:PDDLParser.Exp.Constraint.HoldAfterExp.ToString">
            <summary>
            Returns a string representation of this expression.
            </summary>
            <returns>A string representation of this expression.</returns>
        </member>
        <member name="M:PDDLParser.Exp.Constraint.HoldAfterExp.ToTypedString">
            <summary>
            Returns a typed string of this expression.
            </summary>
            <returns>A typed string representation of this expression.</returns>
        </member>
        <member name="T:PDDLParser.Exp.Comparison.GreaterComp">
            <summary>
            This class implements the greater numeric comparison.
            </summary>
        </member>
        <member name="M:PDDLParser.Exp.Comparison.GreaterComp.#ctor(PDDLParser.Exp.INumericExp,PDDLParser.Exp.INumericExp)">
            <summary>
            Creates a new greater numeric comparison.
            </summary>
            <param name="arg1">The first argument.</param>
            <param name="arg2">The second argument.</param>
        </member>
        <member name="M:PDDLParser.Exp.Comparison.GreaterComp.Compare(PDDLParser.Exp.Struct.Double,PDDLParser.Exp.Struct.Double)">
            <summary>
            Compares the two arguments. This comparison should return undefined if at least
            one of the two arguments is undefined.
            </summary>
            <param name="arg1">The first argument.</param>
            <param name="arg2">The second argument.</param>
            <returns>True, false, or undefined.</returns>
        </member>
        <member name="M:PDDLParser.Exp.Comparison.GreaterComp.Compare(PDDLParser.Exp.Struct.FuzzyDouble,PDDLParser.Exp.Struct.FuzzyDouble)">
            <summary>
            Compares the two arguments. This comparison should return undefined if at least one 
            of the two arguments is undefined, or unknown if at least one of the two arguments is 
            unknown.
            </summary>
            <param name="arg1">The first argument.</param>
            <param name="arg2">The second argument.</param>
            <returns>True, false, undefined, or unknown.</returns>
        </member>
        <member name="T:PDDLParser.Exp.Struct.NumericValue">
            <summary>
            A NumericValue represents a numeric expression, a double value, or an undefined value.
            </summary>
        </member>
        <member name="F:PDDLParser.Exp.Struct.NumericValue.Undefined">
            <summary>
            NumericValue undefined value.
            </summary>
        </member>
        <member name="F:PDDLParser.Exp.Struct.NumericValue.m_value">
            <summary>
            The Double value associated with this NumericValue.
            Note that this value is not defined if a corresponding expression is defined.
            </summary>
        </member>
        <member name="F:PDDLParser.Exp.Struct.NumericValue.m_exp">
            <summary>
            The numeric expression associated with this ExpressionValue.
            </summary>
        </member>
        <member name="M:PDDLParser.Exp.Struct.NumericValue.#ctor(PDDLParser.Exp.Struct.Double)">
            <summary>
            Creates a new NumericValue from a specified Double value.
            </summary>
            <param name="value">A Double value.</param>
        </member>
        <member name="M:PDDLParser.Exp.Struct.NumericValue.#ctor(System.Double)">
            <summary>
            Creates a new NumericValue from a specified double value.
            </summary>
            <param name="value">A double value.</param>
        </member>
        <member name="M:PDDLParser.Exp.Struct.NumericValue.#ctor(PDDLParser.Exp.INumericExp)">
            <summary>
            Creates a new NumericValue from a specified numeric expression.
            </summary>
            <param name="exp">A numeric expression.</param>
        </member>
        <member name="M:PDDLParser.Exp.Struct.NumericValue.GetEquivalentExp">
            <summary>
            Returns a numeric expression equivalent to this NumericValue.
            If this NumericValue corresponds to a Double value, an equivalent constant expression
            is returned (double -> Number, Undefined -> UndefinedExp).
            </summary>
            <returns>A numeric expression equivalent to this NumericValue.</returns>
        </member>
        <member name="M:PDDLParser.Exp.Struct.NumericValue.Equals(System.Object)">
            <summary>
            Returns true if this NumericValue is equal to another object.
            </summary>
            <param name="obj">The other object to test for equality.</param>
            <returns>True if this NumericValue is equal to the other object.</returns>
        </member>
        <member name="M:PDDLParser.Exp.Struct.NumericValue.GetHashCode">
            <summary>
            Returns the hashcode of this NumericValue.
            </summary>
            <returns>The hashcode of this NumericValue.</returns>
        </member>
        <member name="M:PDDLParser.Exp.Struct.NumericValue.ToString">
            <summary>
            Returns a string representation of this NumericValue.
            </summary>
            <returns>A string representation of this NumericValue.</returns>
        </member>
        <member name="P:PDDLParser.Exp.Struct.NumericValue.Exp">
            <summary>
            Returns the numeric expression stored in this NumericValue.
            Note that this numeric expression may be null.
            </summary>
        </member>
        <member name="P:PDDLParser.Exp.Struct.NumericValue.Value">
            <summary>
            Returns the Double value stored in this ExpressionValue.
            This value should only be accessed if the expression is null.
            </summary>
        </member>
        <member name="T:PDDLParser.Exp.Struct.Double">
            <summary>
            A Double represents a double value which may be undefined.
            Note that all arithmetic comparisons performed on an undefined Double value
            always yield an undefined (Bool.Undefined) result.
            </summary>
        </member>
        <member name="F:PDDLParser.Exp.Struct.Double.Undefined">
            <summary>
            Double undefined value.
            </summary>
        </member>
        <member name="F:PDDLParser.Exp.Struct.Double.m_value">
            <summary>
            The value of this Double.
            </summary>
        </member>
        <member name="F:PDDLParser.Exp.Struct.Double.m_status">
            <summary>
            The status of this Double.
            </summary>
        </member>
        <member name="M:PDDLParser.Exp.Struct.Double.#ctor(System.Double)">
            <summary>
            Creates a new Double with the specified double value.
            </summary>
            <param name="value">The new Double's value.</param>
        </member>
        <member name="M:PDDLParser.Exp.Struct.Double.#ctor(PDDLParser.Exp.Struct.Double.State,System.Double)">
            <summary>
            Creates a new Double with the specified status and double value.
            </summary>
            <param name="status">The new Double's status.</param>
            <param name="value">The new Double's value.</param>
        </member>
        <member name="M:PDDLParser.Exp.Struct.Double.op_LessThan(PDDLParser.Exp.Struct.Double,PDDLParser.Exp.Struct.Double)">
            <summary>
            Checks whether a given Double is strictly less than another given Double.
            This comparison returns Bool.Undefined if at least one of two operands is undefined.
            </summary>
            <param name="d1">The first operand.</param>
            <param name="d2">The second operand.</param>
            <returns>Bool.Undefined if at least one of two operands is undefined, else
            Bool.True if the first operand is strictly less than the second operand.</returns>
        </member>
        <member name="M:PDDLParser.Exp.Struct.Double.op_LessThanOrEqual(PDDLParser.Exp.Struct.Double,PDDLParser.Exp.Struct.Double)">
            <summary>
            Checks whether a given Double is less than or equal to another given Double.
            This comparison returns Bool.Undefined if at least one of two operands is undefined.
            </summary>
            <param name="d1">The first operand.</param>
            <param name="d2">The second operand.</param>
            <returns>Bool.Undefined if at least one of two operands is undefined, else
            Bool.True if the first operand is less than or equal to the second operand.</returns>
        </member>
        <member name="M:PDDLParser.Exp.Struct.Double.op_GreaterThan(PDDLParser.Exp.Struct.Double,PDDLParser.Exp.Struct.Double)">
            <summary>
            Checks whether a given Double is strictly greater than another given Double.
            This comparison returns Bool.Undefined if at least one of two operands is undefined.
            </summary>
            <param name="d1">The first operand.</param>
            <param name="d2">The second operand.</param>
            <returns>Bool.Undefined if at least one of two operands is undefined, else
            Bool.True if the first operand is strictly greater than the second operand.</returns>
        </member>
        <member name="M:PDDLParser.Exp.Struct.Double.op_GreaterThanOrEqual(PDDLParser.Exp.Struct.Double,PDDLParser.Exp.Struct.Double)">
            <summary>
            Checks whether a given Double is greater than or equal to another given Double.
            This comparison returns Bool.Undefined if at least one of two operands is undefined.
            </summary>
            <param name="d1">The first operand.</param>
            <param name="d2">The second operand.</param>
            <returns>Bool.Undefined if at least one of two operands is undefined, else
            Bool.True if the first operand is greater than or equal to the second operand.</returns>
        </member>
        <member name="M:PDDLParser.Exp.Struct.Double.op_Equality(PDDLParser.Exp.Struct.Double,PDDLParser.Exp.Struct.Double)">
            <summary>
            Checks whether a given Double is equal to another given Double.
            This comparison returns Bool.Undefined if at least one of two operands is undefined.
            </summary>
            <param name="d1">The first operand.</param>
            <param name="d2">The second operand.</param>
            <returns>Bool.Undefined if at least one of two operands is undefined, else
            Bool.True if the first operand is equal to the second operand.</returns>
        </member>
        <member name="M:PDDLParser.Exp.Struct.Double.op_Inequality(PDDLParser.Exp.Struct.Double,PDDLParser.Exp.Struct.Double)">
            <summary>
            Checks whether a given Double is different from another given Double.
            This comparison returns Bool.Undefined if at least one of two operands is undefined.
            </summary>
            <param name="d1">The first operand.</param>
            <param name="d2">The second operand.</param>
            <returns>Bool.Undefined if at least one of two operands is undefined, else
            Bool.True if the first operand is different from the second operand.</returns>
        </member>
        <member name="M:PDDLParser.Exp.Struct.Double.op_UnaryNegation(PDDLParser.Exp.Struct.Double)">
            <summary>
            Performs the negation of a given double.
            This operation returns an undefined value if the given Double is undefined.
            </summary>
            <param name="d">The value to negate.</param>
            <returns>Double.Undefined if the operand is undefined, or else the negated value.</returns>
        </member>
        <member name="M:PDDLParser.Exp.Struct.Double.op_Addition(PDDLParser.Exp.Struct.Double,PDDLParser.Exp.Struct.Double)">
            <summary>
            Adds two <see cref="T:PDDLParser.Exp.Struct.Double"/> instances together.
            </summary>
            <param name="d1">The first operand.</param>
            <param name="d2">The second operand.</param>
            <returns><see cref="F:PDDLParser.Exp.Struct.Double.Undefined"/> if one operand is undefined, or a new <see cref="T:PDDLParser.Exp.Struct.Double"/>
            whose value is the sum of the operands' values.</returns>
        </member>
        <member name="M:PDDLParser.Exp.Struct.Double.Equals(System.Object)">
            <summary>
            Returns true if this Double is equal to another object.
            </summary>
            <param name="obj">The other object to test for equality.</param>
            <returns>True if this Double is equal to the other object.</returns>
        </member>
        <member name="M:PDDLParser.Exp.Struct.Double.GetHashCode">
            <summary>
            Returns the hashcode of this Double.
            </summary>
            <returns>The hashcode of this Double.</returns>
        </member>
        <member name="M:PDDLParser.Exp.Struct.Double.ToString">
            <summary>
            Returns a string representation of this Double.
            </summary>
            <returns>A string representation of this Double.</returns>
        </member>
        <member name="M:PDDLParser.Exp.Struct.Double.CompareTo(PDDLParser.Exp.Struct.Double)">
            <summary>
            Compares this Double with another Double.
            </summary>
            <param name="other">The other Double to compare this Double to.
            </param>
            <returns>An integer representing the total order relation between the two Doubles.
            </returns>
        </member>
        <member name="P:PDDLParser.Exp.Struct.Double.Status">
            <summary>
            Returns the status of this Double.
            </summary>
        </member>
        <member name="P:PDDLParser.Exp.Struct.Double.Value">
            <summary>
            Returns the value of this Double.
            The value should only be accessed if this Double is defined.
            </summary>
        </member>
        <member name="T:PDDLParser.Exp.Struct.Double.State">
            <summary>
            Internal Double status, which indicates whether the Double is defined or not.
            </summary>
        </member>
        <member name="F:PDDLParser.Exp.Struct.Double.State.Defined">
            <summary>
            Indicates that this Double is defined, and thus its internal double value
            can be accessed.
            </summary>
        </member>
        <member name="F:PDDLParser.Exp.Struct.Double.State.Undefined">
            <summary>
            Indicates that this Double is undefined.
            </summary>
        </member>
        <member name="T:PDDLParser.Exp.Struct.BoolValue">
            <summary>
            All possible Bool values.
            </summary>
        </member>
        <member name="F:PDDLParser.Exp.Struct.BoolValue.False">
            <summary>
            The false BoolValue.
            </summary>
        </member>
        <member name="F:PDDLParser.Exp.Struct.BoolValue.Undefined">
            <summary>
            The undefined BoolValue.
            </summary>
        </member>
        <member name="F:PDDLParser.Exp.Struct.BoolValue.True">
            <summary>
            The true BoolValue.
            </summary>
        </member>
        <member name="T:PDDLParser.Exp.Struct.Bool">
            <summary>
            A Bool wraps a BoolValue and thus represents a possibly undefined boolean value.
            Its domain is { False, Undefined, True }.
            Note that ¬Undefined = Undefined.
            Bool.False shortcircuits conjunctions and Bool.True shortcircuits disjunctions.
            Bool.Undefined never shortcircuits the evaluation.
            </summary>
        </member>
        <member name="F:PDDLParser.Exp.Struct.Bool.False">
            <summary>
            Bool false value.
            </summary>
        </member>
        <member name="F:PDDLParser.Exp.Struct.Bool.Undefined">
            <summary>
            Bool undefined value.
            </summary>
        </member>
        <member name="F:PDDLParser.Exp.Struct.Bool.True">
            <summary>
             Bool true value.
            </summary>
        </member>
        <member name="F:PDDLParser.Exp.Struct.Bool.m_value">
            <summary>
            Inner BoolValue of this Bool.
            </summary>
        </member>
        <member name="M:PDDLParser.Exp.Struct.Bool.#ctor(System.Boolean)">
            <summary>
            Creates a new Bool from a specified boolean value.
            </summary>
            <param name="value">A boolean value.</param>
        </member>
        <member name="M:PDDLParser.Exp.Struct.Bool.#ctor(PDDLParser.Exp.Struct.BoolValue)">
            <summary>
            Creates a new Bool from a specified BoolValue.
            This constructor should stay private.
            </summary>
            <param name="value">A BoolValue.</param>
        </member>
        <member name="M:PDDLParser.Exp.Struct.Bool.ToBool">
            <summary>
            Returns the corresponding truth value of this Bool.
            Bool.True yields true,
            Bool.False and Bool.Undefined both yield false.
            </summary>
            <returns>The boolean value of this Bool.</returns>
        </member>
        <member name="M:PDDLParser.Exp.Struct.Bool.op_Equality(PDDLParser.Exp.Struct.Bool,PDDLParser.Exp.Struct.Bool)">
            <summary>
            Checks whether the two Bool values are equivalent.
            </summary>
            <param name="x">The first Bool value.</param>
            <param name="y">The second Bool value.</param>
            <returns>True if the two Bool values are equivalent.</returns>
        </member>
        <member name="M:PDDLParser.Exp.Struct.Bool.op_Inequality(PDDLParser.Exp.Struct.Bool,PDDLParser.Exp.Struct.Bool)">
            <summary>
            Checks whether the two Bool values are different.
            </summary>
            <param name="x">The first Bool value.</param>
            <param name="y">The second Bool value.</param>
            <returns>True if the two Bool values are different.</returns>
        </member>
        <member name="M:PDDLParser.Exp.Struct.Bool.op_OnesComplement(PDDLParser.Exp.Struct.Bool)">
            <summary>
            Returns the negation of this Bool value.
            ¬False = True
            ¬Undefined = Undefined
            ¬True = True
            </summary>
            <param name="x">The Bool value to negate.</param>
            <returns>The negation of this Bool value.</returns>
        </member>
        <member name="M:PDDLParser.Exp.Struct.Bool.op_LogicalNot(PDDLParser.Exp.Struct.Bool)">
            <summary>
            False shortcircuit operator.
            A Bool value is false if its inner value is Bool.False
            </summary>
            <param name="x">The Bool value to test.</param>
            <returns>True if the Bool value is Bool.False</returns>
        </member>
        <member name="M:PDDLParser.Exp.Struct.Bool.op_False(PDDLParser.Exp.Struct.Bool)">
            <summary>
            False shortcircuit operator.
            A Bool value is false if its inner value is Bool.False
            </summary>
            <param name="x">The Bool value to test.</param>
            <returns>True if the Bool value is Bool.False</returns>
        </member>
        <member name="M:PDDLParser.Exp.Struct.Bool.op_True(PDDLParser.Exp.Struct.Bool)">
            <summary>
            True shortcircuit operator.
            A Bool value is true if its inner value is Bool.True
            </summary>
            <param name="x">The Bool value to test.</param>
            <returns>True if the Bool value is Bool.True</returns>
        </member>
        <member name="M:PDDLParser.Exp.Struct.Bool.op_BitwiseOr(PDDLParser.Exp.Struct.Bool,PDDLParser.Exp.Struct.Bool)">
            <summary>
            Returns the disjunction of two Bool values.
            The resulting Bool value corresponds to the maximum BoolValue 
            of the two operands.
            </summary>
            <param name="x">The first Bool value.</param>
            <param name="y">The second Bool value.</param>
            <returns>The disjunction of the two Bool values.</returns>
        </member>
        <member name="M:PDDLParser.Exp.Struct.Bool.op_BitwiseAnd(PDDLParser.Exp.Struct.Bool,PDDLParser.Exp.Struct.Bool)">
            <summary>
            Returns the conjunction of two Bool values.
            The resulting Bool value corresponds to the minimum BoolValue 
            of the two operands.
            </summary>
            <param name="x">The first Bool value.</param>
            <param name="y">The second Bool value.</param>
            <returns>The conjunction of the two Bool values.</returns>
        </member>
        <member name="M:PDDLParser.Exp.Struct.Bool.op_ExclusiveOr(PDDLParser.Exp.Struct.Bool,PDDLParser.Exp.Struct.Bool)">
            <summary>
            Returns the exclusive disjunction of two Bool values.
            </summary>
            <param name="x">The first Bool value.</param>
            <param name="y">The second Bool value.</param>
            <returns>The exclusive disjunction of the two Bool values.</returns>
        </member>
        <member name="M:PDDLParser.Exp.Struct.Bool.op_Implicit(PDDLParser.Exp.Struct.Bool)~PDDLParser.Exp.Struct.BoolValue">
            <summary>
            Returns the BoolValue associated with a Bool.
            </summary>
            <param name="x">The Bool value.</param>
            <returns>The BoolValue associated with the Bool.</returns>
        </member>
        <member name="M:PDDLParser.Exp.Struct.Bool.Equals(System.Object)">
            <summary>
            Returns true if this Bool value is equal to another object.
            </summary>
            <param name="obj">The other object to test for equality.</param>
            <returns>True if this Bool value is equal to the other object.</returns>
        </member>
        <member name="M:PDDLParser.Exp.Struct.Bool.GetHashCode">
            <summary>
            Returns the hashcode of this Bool value.
            </summary>
            <returns>The hashcode of this Bool value.</returns>
        </member>
        <member name="M:PDDLParser.Exp.Struct.Bool.ToString">
            <summary>
            Returns a string representation of the Bool value.
            </summary>
            <returns>A string representation of the Bool value.</returns>
        </member>
        <member name="P:PDDLParser.Exp.Struct.Bool.Value">
            <summary>
            Returns the BoolValue associated with this Bool.
            </summary>
        </member>
        <member name="T:PDDLParser.Exp.Numeric.TLPlan.UnaryCeiling">
            <summary>
            This class implements the ceiling function.
            This is not part of PDDL; it was rather added for TLPlan.
            </summary>
        </member>
        <member name="M:PDDLParser.Exp.Numeric.TLPlan.UnaryCeiling.#ctor(PDDLParser.Exp.INumericExp)">
            <summary>
            Creates a new ceiling function with the specified argument.
            </summary>
            <param name="arg">The argument of the new ceiling function.</param>
        </member>
        <member name="M:PDDLParser.Exp.Numeric.TLPlan.UnaryCeiling.Calculate(System.Double)">
            <summary>
            Calculates the largest integer greater than or equal the argument.
            </summary>
            <param name="arg">The number.</param>
            <returns>The largest integer greater than or equal the argument.</returns>
        </member>
        <member name="T:PDDLParser.Exp.Formula.ObjectFluentApplication">
            <summary>
            An object fluent application is an application of an object fluent.
            Note that an object fluent application is undefined until its value has been set.
            It is also possible to undefine an object fluent application, for example in the context
            of durative actions where its value should not be accessed.
            </summary>
        </member>
        <member name="M:PDDLParser.Exp.Formula.ObjectFluentApplication.#ctor(PDDLParser.Exp.Formula.ObjectFluent,System.Collections.Generic.List{PDDLParser.Exp.ITerm})">
            <summary>
            Creates a new object fluent application of a specified object fluent with a given
            list of arguments.
            </summary>
            <param name="fluent">The object fluent to instantiate.</param>
            <param name="arguments">The arguments of this object fluent application.</param>
        </member>
        <member name="M:PDDLParser.Exp.Formula.ObjectFluentApplication.Apply(System.Collections.Generic.List{PDDLParser.Exp.ITerm})">
            <summary>
            Returns a copy of this object fluent application with the specified arguments.
            </summary>
            <param name="arguments">The arguments of the new fluent application.</param>
            <returns>A copy of this expression with the given arguments.</returns>
        </member>
        <member name="M:PDDLParser.Exp.Formula.ObjectFluentApplication.GetTypeSet">
            <summary>
            Returns the typeset of this objet fluent application.
            </summary>
            <returns>The typeset of this object fluent application.</returns>
        </member>
        <member name="M:PDDLParser.Exp.Formula.ObjectFluentApplication.Evaluate(PDDLParser.World.IReadOnlyOpenWorld,PDDLParser.Exp.LocalBindings)">
            <summary>
            Evaluates this term in the specified open world.
            An object fluent application is evaluated by first evaluating its arguments and then
            by retrieving its value in the specified world.
            </summary>
            <param name="world">The evaluation world.</param>
            <param name="bindings">A set of variable bindings.</param>
            <returns>Undefined, unknown, or the constant resulting from the evaluation.</returns>
        </member>
        <member name="M:PDDLParser.Exp.Formula.ObjectFluentApplication.Simplify(PDDLParser.World.IReadOnlyOpenWorld,PDDLParser.Exp.LocalBindings)">
            <summary>
            Simplifies this term by evaluating its known expression parts.
            An object fluent application is simplified by first simplifying its arguments and then
            by attempting to retrieve its value in the specified world (if it is ground).
            </summary>
            <param name="world">The evaluation world.</param>
            <param name="bindings">A set of variable bindings.</param>
            <returns>Undefined, or the term (possibly a constant) resulting from 
            the simplification.</returns>
        </member>
        <member name="M:PDDLParser.Exp.Formula.ObjectFluentApplication.Evaluate(PDDLParser.World.IReadOnlyClosedWorld,PDDLParser.Exp.LocalBindings)">
            <summary>
            Evaluates this term in the specified closed world.
            An object fluent application is evaluated by first evaluating its arguments and then
            by retrieving its value in the specified world.
            </summary>
            <param name="world">The evaluation world.</param>
            <param name="bindings">A set of variable bindings.</param>
            <returns>Undefined, or the constant resulting from the evaluation.</returns>
        </member>
        <member name="M:PDDLParser.Exp.Formula.ObjectFluentApplication.CanBeAssignedFrom(PDDLParser.Exp.ITerm)">
            <summary>
            Verifies whether the specified term can be assigned to this term, 
            i.e. if the other term's domain is a subset of this term's domain.
            </summary>
            <param name="term">The other term.</param>
            <returns>True if the types are compatible, false otherwise.</returns>
        </member>
        <member name="M:PDDLParser.Exp.Formula.ObjectFluentApplication.IsComparableTo(PDDLParser.Exp.ITerm)">
            <summary>
            Verifies whether the specified term can be compared to this term,
            i.e. if their domain overlap.
            </summary>
            <param name="term">The other term</param>
            <returns>True if the types can be compared, false otherwise.</returns>
        </member>
        <member name="M:PDDLParser.Exp.Formula.ObjectFluentApplication.CompareTo(PDDLParser.Exp.Formula.ObjectFluentApplication)">
            <summary>
            Compares two object fluent applications.
            </summary>
            <param name="other">The other object fluent application to compare this formula to.</param>
            <returns>An integer representing the total order relation between the two formulas.</returns>
        </member>
        <member name="P:PDDLParser.Exp.Formula.ObjectFluentApplication.RootObjectFluent">
            <summary>
            Gets the object fluent associated with this object fluent application.
            </summary>
        </member>
        <member name="T:PDDLParser.Exp.Formula.TLPlan.LocalVar.NumericLocalVariable">
            <summary>
            A numeric local variable is a local variable bound to a numeric value.
            </summary>
        </member>
        <member name="T:PDDLParser.Exp.ILocalVariable">
            <summary>
            A local variable is a bound variable which exists in the scope of a function.
            </summary>
        </member>
        <member name="M:PDDLParser.Exp.Formula.TLPlan.LocalVar.NumericLocalVariable.#ctor(System.String)">
            <summary>
            Creates a new numeric local variable with the specified name.
            </summary>
            <param name="name">The name of this numeric local variable.</param>
        </member>
        <member name="M:PDDLParser.Exp.Formula.TLPlan.LocalVar.NumericLocalVariable.Evaluate(PDDLParser.World.IReadOnlyOpenWorld,PDDLParser.Exp.LocalBindings)">
            <summary>
            Evaluates this numeric expression in the specified open world.
            A local variable is evaluated by retrieving its binding in the provided set of bindings.
            </summary>
            <param name="world">The evaluation world.</param>
            <param name="bindings">A set of variable bindings.</param>
            <returns>Undefined, unknown, or the resulting numeric value.</returns>
            <exception cref="T:PDDLParser.Exception.BindingException">A BindingException is thrown if this
            variable is not bound.</exception>
        </member>
        <member name="M:PDDLParser.Exp.Formula.TLPlan.LocalVar.NumericLocalVariable.Simplify(PDDLParser.World.IReadOnlyOpenWorld,PDDLParser.Exp.LocalBindings)">
            <summary>
            Simplifies this numeric expression by evaluating its known expression parts.
            A local variable is simplified by retrieving its corresponding binding, if accessible.
            </summary>
            <param name="world">The evaluation world.</param>
            <param name="bindings">A set of variable bindings.</param>
            <returns>Undefined, a numeric value, or the simplified expression.</returns>
            <exception cref="T:PDDLParser.Exception.BindingException">A BindingException is thrown if this
            variable is not bound.</exception>
        </member>
        <member name="M:PDDLParser.Exp.Formula.TLPlan.LocalVar.NumericLocalVariable.Evaluate(PDDLParser.World.IReadOnlyClosedWorld,PDDLParser.Exp.LocalBindings)">
            <summary>
            Evaluates this numeric expression in the specified closed world.
            A local variable is evaluated by retrieving its binding in the provided set of bindings.
            </summary>
            <param name="world">The evaluation world.</param>
            <param name="bindings">A set of variable bindings.</param>
            <returns>Undefined, or the resulting numeric value.</returns>
            <exception cref="T:PDDLParser.Exception.BindingException">A BindingException is thrown if this
            variable is not bound.</exception>
        </member>
        <member name="M:PDDLParser.Exp.Formula.TLPlan.LocalVar.NumericLocalVariable.Apply(PDDLParser.Exp.ParameterBindings)">
            <summary>
            Substitutes all occurrences of the variables that occur in this
            expression by their corresponding bindings.
            </summary>
            <param name="bindings">The bindings.</param>
            <returns>A substituted copy of this expression.</returns>
        </member>
        <member name="M:PDDLParser.Exp.Formula.TLPlan.LocalVar.NumericLocalVariable.IsFree">
            <summary>
            Returns true if this variable is free, false it is bound.
            A numeric local variable is bound.
            </summary>
            <returns>False.</returns>
        </member>
        <member name="T:PDDLParser.Exp.Formula.TLPlan.DefinedObjectFunction">
            <summary>
            A defined object function is a defined function which yields an object value
            (a constant from the domain) when evaluated.
            </summary>
        </member>
        <member name="T:PDDLParser.Exp.Formula.TLPlan.DefinedFunction">
            <summary>
            A defined function is a defined formula which yields a numeric or object value when
            evaluated. Its return value is set with a corresponding local variable having the
            same name as the function.
            </summary>
        </member>
        <member name="M:PDDLParser.Exp.Formula.TLPlan.DefinedFunction.#ctor(System.String,System.String,System.Collections.Generic.List{PDDLParser.Exp.Term.ObjectParameterVariable},System.Collections.Generic.List{PDDLParser.Exp.ILocalVariable})">
            <summary>
            Createsa a new defined function with the specified name, arguments, and local
            variables.
            </summary>
            <param name="image">The image of this defined function.</param>
            <param name="name">The name of this defined function.</param>
            <param name="arguments">The arguments of this defined function.</param>
            <param name="localVariables">The local variables used in the body of this
            defined function.</param>
        </member>
        <member name="P:PDDLParser.Exp.Formula.TLPlan.DefinedFunction.FunctionVariable">
            <summary>
            Gets the local variable corresponding to the function's return value.
            </summary>
        </member>
        <member name="F:PDDLParser.Exp.Formula.TLPlan.DefinedObjectFunction.m_typeSet">
            <summary>
            The typeset of the value returned by this defined object function.
            </summary>
        </member>
        <member name="F:PDDLParser.Exp.Formula.TLPlan.DefinedObjectFunction.m_functionVariable">
            <summary>
            The local variable corresponding to this function's return value.
            </summary>
        </member>
        <member name="M:PDDLParser.Exp.Formula.TLPlan.DefinedObjectFunction.#ctor(System.String,System.Collections.Generic.List{PDDLParser.Exp.Term.ObjectParameterVariable},PDDLParser.Exp.Term.Type.TypeSet,System.Collections.Generic.List{PDDLParser.Exp.ILocalVariable})">
            <summary>
            Creates a new defined object function with the specified name, arguments,
            typeset, and local variables.
            </summary>
            <param name="name">The name of this defined object function.</param>
            <param name="arguments">The arguments of this defined object function.</param>
            <param name="typeSet">The typeset of the value returned by this defined
            object function.</param>
            <param name="localVariables">The local variables used in the body of this
            defined object function.</param>
        </member>
        <member name="M:PDDLParser.Exp.Formula.TLPlan.DefinedObjectFunction.GetTypeSet">
            <summary>
            Returns the typeset of the value returned by this defined object function.
            </summary>
            <returns>The typeset of the value returned by this defined object function.</returns>
        </member>
        <member name="M:PDDLParser.Exp.Formula.TLPlan.DefinedObjectFunction.Evaluate(PDDLParser.World.IReadOnlyOpenWorld,PDDLParser.Exp.Formula.TLPlan.DefinedObjectFunctionApplication)">
            <summary>
            Evaluates this defined object function in the specified open world.
            A defined object function is evaluated by binding its body's free variables to the
            corresponding arguments of the function application, and then evaluating its
            body using immediate short-circuit.
            If its body evaluates to unknown, the evaluation returns unknown.
            If its body evaluates to undefined, the evaluation returns undefined.
            Else the evaluation returns the final binding of the function variable.
            </summary>
            <param name="world">The evaluation world.</param>
            <param name="formula">A function application with ground (constant) arguments.</param>
            <returns>Undefined, unknown, or the resulting constant value.</returns>
        </member>
        <member name="M:PDDLParser.Exp.Formula.TLPlan.DefinedObjectFunction.Evaluate(PDDLParser.World.IReadOnlyClosedWorld,PDDLParser.Exp.Formula.TLPlan.DefinedObjectFunctionApplication)">
            <summary>
            Evaluates this defined object function in the specified closed world.
            A defined object function is evaluated by binding its body's free variables to the
            corresponding arguments of the function application, and then evaluating its
            body using immediate short-circuit.
            If its body evaluates to undefined, the evaluation returns undefined.
            Else the evaluation returns the final binding of the function variable.
            </summary>
            <param name="world">The evaluation world.</param>
            <param name="formula">A function application with ground (constant) arguments.</param>
            <returns>Undefined, or the resulting constant value.</returns>
        </member>
        <member name="M:PDDLParser.Exp.Formula.TLPlan.DefinedObjectFunction.Instantiate(System.Collections.Generic.List{PDDLParser.Exp.ITerm})">
            <summary>
            Instantiates a formula application associated with this defined object function.
            </summary>
            <param name="arguments">Arguments of the formula application to instantiate.</param>
            <returns>A new formula application associated with this defined object function.</returns>
        </member>
        <member name="M:PDDLParser.Exp.Formula.TLPlan.DefinedObjectFunction.ToTypedString">
            <summary>
            Returns a typed string representation of this formula.
            </summary>
            <returns>A typed string representation of this formula.</returns>
        </member>
        <member name="P:PDDLParser.Exp.Formula.TLPlan.DefinedObjectFunction.FunctionVariable">
            <summary>
            Returns the local variable corresponding to the function's return value.
            </summary>
            <returns>The local variable corresponding to the functions' return value.</returns>
        </member>
        <member name="T:PDDLParser.Exp.Effect.DurativeWhenEffect">
            <summary>
            Represents a conditional effect in a durative action.
            </summary>
            <remarks>
            Durative conditional effects are transformed into simpler conditions, as described
            in section 8.1 of "PDDL2.1: An Extenstion to PDDL for Expressing Temporal Planning
            Domains", by Maria Fox and Derek Long.
            
            Note that conditional effects that have their condition and their effect at the
            same time (i.e. at start or at end) should be transformed into a simple
            <seealso cref="T:PDDLParser.Exp.Effect.WhenEffect"/>
            </remarks>
        </member>
        <member name="F:PDDLParser.Exp.Effect.DurativeWhenEffect.m_contextConditions">
            <summary>
            The action context specific conditions to satisfy.
            </summary>
        </member>
        <member name="F:PDDLParser.Exp.Effect.DurativeWhenEffect.m_contextEffects">
            <summary>
            The conditional effects in the action context.
            </summary>
        </member>
        <member name="M:PDDLParser.Exp.Effect.DurativeWhenEffect.#ctor(PDDLParser.Exp.ILogicalExp,System.Collections.Generic.IEnumerable{System.Collections.Generic.KeyValuePair{PDDLParser.Exp.Formula.AtomicFormulaApplication,System.Boolean}},PDDLParser.Exp.IEffect,System.Collections.Generic.IEnumerable{PDDLParser.Exp.Formula.AtomicFormulaApplication})">
            <summary>
            Creates a new durative conditional effect.
            </summary>
            <param name="condition">The condition to satifisy in the world. This can be null, in which case it always evaluates to true.</param>
            <param name="contextConditions">The conditions to satisfy in the action context.</param>
            <param name="effect">The conditional effect on the world. This can be null, in which case no effect will be applied.</param>
            <param name="contextEffects">The conditional effects on the action context.</param>
        </member>
        <member name="M:PDDLParser.Exp.Effect.DurativeWhenEffect.Update(PDDLParser.World.IReadOnlyOpenWorld,PDDLParser.World.IDurativeOpenWorld,PDDLParser.Exp.LocalBindings,PDDLParser.ActionContext)">
            <summary>
            Updates the specified world and action context with this effect.
            A conditional effect updates the world if all its (world- and action context-specific) conditions are satisfied.
            </summary>
            <param name="evaluationWorld">World to evaluate conditions against.</param>
            <param name="updateWorld">World to update.</param>
            <param name="bindings">A set of variable bindings.</param>
            <param name="actionContext">The action evaluation context to evaluate conditions against and to update.</param>
        </member>
        <member name="M:PDDLParser.Exp.Effect.DurativeWhenEffect.IsGround">
            <summary>
            Returns true if the expression is ground, i.e. it does not contain any variables.
            </summary>
            <returns>Whether the expression is ground.</returns>
        </member>
        <member name="M:PDDLParser.Exp.Effect.DurativeWhenEffect.Equals(System.Object)">
            <summary>
            Returns true if this expression is equal to a specified object.
            </summary>
            <param name="obj">Object to test for equality.</param>
            <returns>True if this expression is equal to the specified objet.</returns>
        </member>
        <member name="M:PDDLParser.Exp.Effect.DurativeWhenEffect.GetHashCode">
            <summary>
            Returns the hash code of this durative conditional effect.
            </summary>
            <returns>The hash code of this durative conditional effect.</returns>
        </member>
        <member name="M:PDDLParser.Exp.Effect.DurativeWhenEffect.ToString">
            <summary>
            Returns the hash code of this durative conditional effect.
            </summary>
            <returns>The hash code of this durative conditional effect.</returns>
        </member>
        <member name="M:PDDLParser.Exp.Effect.DurativeWhenEffect.ToTypedString">
            <summary>
            Returns a typed string representation of this durative conditional effect.
            </summary>
            <returns>A typed string representation of this durative conditional effect.</returns>
        </member>
        <member name="M:PDDLParser.Exp.Effect.DurativeWhenEffect.CompareTo(PDDLParser.Exp.IExp)">
            <summary>
            Compares this durative conditional effect with another expression.
            </summary>
            <param name="other">The other expression to compare this expression to.</param>
            <returns>An integer representing the total order relation between the two expressions.</returns>
        </member>
        <member name="T:PDDLParser.Exp.Constraint.DerivedConstraintExp">
            <summary>
            Represents a constraint expression which is converted into an equivalent
            form using other constraint expressions.
            </summary>
        </member>
        <member name="F:PDDLParser.Exp.Constraint.DerivedConstraintExp.m_equivalentExp">
            <summary>
            The equivalent constraint expression.
            </summary>
        </member>
        <member name="M:PDDLParser.Exp.Constraint.DerivedConstraintExp.#ctor">
            <summary>
            Creates a new derived constraint expression.
            </summary>
        </member>
        <member name="M:PDDLParser.Exp.Constraint.DerivedConstraintExp.Progress(PDDLParser.World.IReadOnlyDurativeClosedWorld,PDDLParser.Exp.LocalBindings)">
            <summary>
            Evaluates the progression of this constraint expression in the next worlds.
            </summary>
            <param name="world">The current world.</param>
            <param name="bindings">A set of variable bindings.</param>
            <returns>True, false, undefined, or a progressed expression.</returns>
            <exception cref="T:PDDLParser.Exception.BindingException">A BindingException is thrown if an attempt
            is made to evaluate an unbound variable.</exception>
            <seealso cref="M:PDDLParser.Exp.IConstraintExp.Progress(PDDLParser.World.IReadOnlyDurativeClosedWorld,PDDLParser.Exp.LocalBindings)"/>
        </member>
        <member name="M:PDDLParser.Exp.Constraint.DerivedConstraintExp.EvaluateIdle(PDDLParser.World.IReadOnlyDurativeClosedWorld,PDDLParser.Exp.LocalBindings)">
            <summary>
            Evaluates this constraint expression in an idle world, i.e. a world which
            won't be modified by further updates.
            </summary>
            <param name="idleWorld">The (idle) evaluation world.</param>
            <param name="bindings">A set of variable bindings.</param>
            <returns>True, false, or undefined.</returns>
            <exception cref="T:PDDLParser.Exception.BindingException">A BindingException is thrown if an attempt
            is made to evaluate an unbound variable.</exception>
            <seealso cref="M:PDDLParser.Exp.IConstraintExp.EvaluateIdle(PDDLParser.World.IReadOnlyDurativeClosedWorld,PDDLParser.Exp.LocalBindings)"/>
        </member>
        <member name="M:PDDLParser.Exp.Constraint.DerivedConstraintExp.IsGround">
            <summary>
            Returns true if the expression is ground, i.e. it does not contain any variables.
            </summary>
            <returns>Whether the expression is ground.</returns>
        </member>
        <member name="M:PDDLParser.Exp.Constraint.DerivedConstraintExp.GetFreeVariables">
            <summary>
            Returns the free variables in this expression.
            </summary>
            <returns>The free variables in this expression.</returns>
        </member>
        <member name="M:PDDLParser.Exp.Constraint.DerivedConstraintExp.GetEquivalentExp">
            <summary>
            Returns the equivalent compound constraint expression of this expression.
            </summary>
            <remarks>
            If the equivalent expression has not yet been generated, it is on the first call.
            The equivalent expression must be generated only when needed as some more processing
            may be performed after the creation of this expression (e.g. quantified expressions expansion)
            </remarks>
            <returns>An equivalent constraint expression to this expression.</returns>
        </member>
        <member name="M:PDDLParser.Exp.Constraint.DerivedConstraintExp.GenerateEquivalentExp">
            <summary>
            Generates and returns the compound constraint expression equivalent to this expression.
            </summary>
            <returns>An equivalent constraint expression to this expression.</returns>
        </member>
        <member name="M:PDDLParser.Exp.Constraint.DerivedConstraintExp.Equals(System.Object)">
            <summary>
            Returns true if this expression is equal to a specified object.
            </summary>
            <param name="obj">Object to test for equality.</param>
            <returns>True if this expression is equal to the specified objet.</returns>
        </member>
        <member name="M:PDDLParser.Exp.Constraint.DerivedConstraintExp.GetHashCode">
            <summary>
            Returns the hash code of this expression.
            </summary>
            <returns>The hash code of this expression.</returns>
        </member>
        <member name="T:PDDLParser.Exp.Constraint.AtMostOnceExp">
            <summary>
            Represents the "at-most-once" constraint expression of the PDDL language.
            </summary>
            <seealso cref="T:PDDLParser.Exp.Constraint.AlwaysExp"/>
            <seealso cref="T:PDDLParser.Exp.Constraint.ImplyConstraintExp"/>
            <seealso cref="T:PDDLParser.Exp.Constraint.TLPlan.UntilExp"/>
            <seealso cref="T:PDDLParser.Exp.Constraint.NotConstraintExp"/>
        </member>
        <member name="F:PDDLParser.Exp.Constraint.AtMostOnceExp.m_exp">
            <summary>
            The body of the constraint expression.
            </summary>
        </member>
        <member name="M:PDDLParser.Exp.Constraint.AtMostOnceExp.#ctor(PDDLParser.Exp.IConstraintExp)">
            <summary>
            Creates a new "at-most-once" constraint expression.
            </summary>
            <param name="exp">The body of the expression.</param>
        </member>
        <member name="M:PDDLParser.Exp.Constraint.AtMostOnceExp.GenerateEquivalentExp">
            <summary>
            Generates and returns the compound constraint expression equivalent to this expression.
            In this case, <c>(at-most-once a) = (always (imply a (weak-until a (always ¬a))))</c>.
            </summary>
            <remarks>
            This equivalence was adapated from the "Plan Constraints and Preferences in PDDL3" document,
            written by Alfonso Gerevini and Derek Long. The original definition was
            <c>(at-most-once a) = (always (imply a (until a (always ¬a))))</c>; the problem with this definition is
            that once the predicate <c>a</c> becomes true, it has to become false for this to progress to true.
            </remarks>
            <returns>An equivalent constraint expression to this expression.</returns>
            <seealso cref="T:PDDLParser.Exp.Constraint.AlwaysExp"/>
            <seealso cref="T:PDDLParser.Exp.Constraint.ImplyConstraintExp"/>
            <seealso cref="T:PDDLParser.Exp.Constraint.TLPlan.UntilExp"/>
            <seealso cref="T:PDDLParser.Exp.Constraint.NotConstraintExp"/>
        </member>
        <member name="M:PDDLParser.Exp.Constraint.AtMostOnceExp.Standardize(System.Collections.Generic.IDictionary{System.String,System.String})">
            <summary>
            Standardizes all occurrences of the variables that occur in this
            expression. The IDictionary argument is used to store the variable already
            standardized. Remember that free variables are existentially quantified.
            The base implementation is to simply clone the object.
            </summary>
            <param name="images">The object that maps old variable images to the standardize
            image.</param>
            <returns>A standardized copy of this expression.</returns>
        </member>
        <member name="M:PDDLParser.Exp.Constraint.AtMostOnceExp.Apply(PDDLParser.Exp.ParameterBindings)">
            <summary>
            Substitutes all occurrences of the variables that occur in this
            expression by their corresponding bindings.
            The base implementation is to simply clone the object.
            </summary>
            <param name="bindings">The bindings.</param>
            <returns>A substituted copy of this expression.</returns>
        </member>
        <member name="M:PDDLParser.Exp.Constraint.AtMostOnceExp.Equals(System.Object)">
            <summary>
            Returns true if this expression is equal to a specified object.
            </summary>
            <param name="obj">Object to test for equality.</param>
            <returns>True if this expression is equal to the specified objet.</returns>
        </member>
        <member name="M:PDDLParser.Exp.Constraint.AtMostOnceExp.GetHashCode">
            <summary>
            Returns the hash code of this expression.
            </summary>
            <returns>The hash code of this expression.</returns>
        </member>
        <member name="M:PDDLParser.Exp.Constraint.AtMostOnceExp.ToString">
            <summary>
            Returns a string representation of this expression.
            </summary>
            <returns>A string representation of this expression.</returns>
        </member>
        <member name="M:PDDLParser.Exp.Constraint.AtMostOnceExp.ToTypedString">
            <summary>
            Returns a typed string of this expression.
            </summary>
            <returns>A typed string representation of this expression.</returns>
        </member>
        <member name="M:PDDLParser.Exp.Constraint.AtMostOnceExp.CompareTo(PDDLParser.Exp.IExp)">
            <summary>
            Compares this abstract expression with another expression.
            </summary>
            <param name="other">The other expression to compare this abstract expression to.</param>
            <returns>An integer representing the total order relation between the two expressions.</returns>
        </member>
        <member name="T:PDDLParser.Exp.AbstractForallExp`1">
            <summary>
            Base class for quantified ForAll expressions.
            </summary>
        </member>
        <member name="M:PDDLParser.Exp.AbstractForallExp`1.#ctor(System.Collections.Generic.HashSet{PDDLParser.Exp.Term.ObjectParameterVariable},`0)">
            <summary>
            Creates a new ForAll expression with the specified vars and body.
            </summary>
            <param name="vars">The quantified variables.</param>
            <param name="body">The quantified expression's body.</param>
        </member>
        <member name="T:PDDLParser.Exception.UndefinedExpException">
            <summary>
            An UndefinedExpException is thrown if an attempt is made to set to retrieve the value
            of an undefined expression.
            </summary>
        </member>
        <member name="M:PDDLParser.Exception.UndefinedExpException.#ctor(System.String)">
            <summary>
            Creates a new UndefinedExpException with a specific message.
            </summary>
            <param name="message">The exception message.</param>
        </member>
        <member name="T:PDDLParser.World.IDurativeOpenWorld">
            <summary>
            Updatable durative open world supporting timed effects.
            </summary>
        </member>
        <member name="T:PDDLParser.World.IReadOnlyDurativeOpenWorld">
            <summary>
            Constant durative open world supporting timed read-only operations.
            </summary>
        </member>
        <member name="M:PDDLParser.World.IReadOnlyDurativeOpenWorld.GetTotalTime">
            <summary>
            Returns the total time it took to reach the current world.
            </summary>
            <returns>The total time of the plan up to this point.</returns>
        </member>
        <member name="M:PDDLParser.World.IReadOnlyDurativeOpenWorld.IsIdleGoalWorld">
            <summary>
            Returns whether the world is an idle goal world (whether it satisfies a goal
            and has been idled).
            </summary>
            <returns>True if the world is an idle goal world, false otherwise.</returns>
        </member>
        <member name="M:PDDLParser.World.IDurativeOpenWorld.AddEndEffect(System.Double,PDDLParser.Exp.IEffect)">
            <summary>
            Add an effect which will take place after a fixed duration.
            </summary>
            <param name="timeOffset">The relative time offset at which the effect takes place.</param>
            <param name="effect">The delayed effect.</param>
        </member>
        <member name="T:PDDLParser.World.IDurativeClosedWorld">
            <summary>
            Updatable durative closed world supporting timed effects.
            </summary>
        </member>
        <member name="T:PDDLParser.World.IReadOnlyDurativeClosedWorld">
            <summary>
            Constant durative closed world supporting timed read-only operations.
            </summary>
        </member>
        <member name="T:PDDLParser.ActionContext">
            <summary>
            A context containing private action-specific data. This is mostly used for durative "when" effects.
            </summary>
        </member>
        <member name="F:PDDLParser.ActionContext.m_facts">
            <summary>
            The set of all true atomic formulas.
            </summary>
        </member>
        <member name="F:PDDLParser.ActionContext.m_sortedFacts">
            <summary>
            The sorted list of all true atomic formulas. This is used in the <see cref="M:PDDLParser.ActionContext.CompareTo(PDDLParser.ActionContext)"/> method.
            </summary>
        </member>
        <member name="F:PDDLParser.ActionContext.m_hashcode">
            <summary>
            The cached hash code of this action context.
            </summary>
        </member>
        <member name="F:PDDLParser.ActionContext.s_emptyActionContext">
            <summary>
            The empty action context.
            </summary>
        </member>
        <member name="M:PDDLParser.ActionContext.#ctor">
            <summary>
            Creates an instance of the action context with no true atomic formulas.
            </summary>
        </member>
        <member name="M:PDDLParser.ActionContext.Set(PDDLParser.Exp.Formula.AtomicFormulaApplication)">
            <summary>
            Sets the specified atomic formula to true.
            </summary>
            <param name="formula">An atomic formula with constant arguments.</param>
        </member>
        <member name="M:PDDLParser.ActionContext.Unset(PDDLParser.Exp.Formula.AtomicFormulaApplication)">
            <summary>
            Sets the specified atomic formula to false.
            </summary>
            <param name="formula">An atomic formula with constant arguments.</param>
        </member>
        <member name="M:PDDLParser.ActionContext.IsSet(PDDLParser.Exp.Formula.AtomicFormulaApplication)">
            <summary>
            Checks whether the specified described atomic formula holds in this context.
            </summary>
            <param name="formula">A described (and ground) atomic formula.</param>
            <returns>True or false.</returns>
        </member>
        <member name="M:PDDLParser.ActionContext.Copy">
            <summary>
            Returns a copy the this action context, clearing the sorted cache.
            </summary>
            <returns>A copy of the action context.</returns>
        </member>
        <member name="M:PDDLParser.ActionContext.CompareTo(PDDLParser.ActionContext)">
            <summary>
            Compares this action context with another action context.
            </summary>
            <param name="other">The other action context to compare this action context to.</param>
            <returns>An integer representing the total order relation between the two action contexts.</returns>
        </member>
        <member name="M:PDDLParser.ActionContext.Equals(System.Object)">
            <summary>
            Returns true if this action context is equal to another object.
            </summary>
            <param name="obj">The other object to test for equality.</param>
            <returns>True if this action context is equal to the other object.</returns>
        </member>
        <member name="M:PDDLParser.ActionContext.GetHashCode">
            <summary>
            Returns the cached hashcode of this action context.
            </summary>
            <returns>The hashcode of this action context.</returns>
        </member>
        <member name="M:PDDLParser.ActionContext.ToString">
            <summary>
            Returns a string representation of this action context.
            </summary>
            <returns>A string representation of this action context.</returns>
        </member>
        <member name="P:PDDLParser.ActionContext.EmptyActionContext">
            <summary>
            Gets the empty action context.
            </summary>
        </member>
        <member name="P:PDDLParser.ActionContext.SortedFacts">
            <summary>
            Returns the sorted list of all true atomic formulas. This list is cached;
            it is assumed that the atomic formulas will not be modified once this
            property is called, unless a copy occurs.
            </summary>
        </member>
        <member name="T:PDDLParser.Parser.Parser">
             * Implements the <tt>Parser</tt> of PDD4L library. The parser can be
             * configured to accept only specified requirements of PDDL langage. The list of
             * requirements accepted are as follow:
             * <ul>
             * <li><tt>:strips</tt> - Basic STRIPS-style.</li>
             * <li><tt>:typing</tt> - Allows type names in declaration of variables</li>
             * <li><tt>:negative-preconditions</tt> - Allows <tt>not</tt> in goal and
             * preconditions descriptions.</li>
             * <li><tt>:disjunctive-preconditions</tt> - Allows <tt>or</tt> in goal
             * and preconditions descriptions.</li>
             * <li><tt>:equality</tt> - Supports <tt>=</tt> as built-in predicate.</li>
             * <li><tt>:existential-preconditions</tt> - Allows <tt>exists</tt> in goal
             * and preconditions descriptions.</li>
             * <li><tt>:universal-preconditions</tt> - Allows <tt>forall</tt> in goal
             * and preconditions descriptions.</li>
             * <li><tt>:quantified-preconditions</tt> - Is equivalent to <tt>:existential-preconditions</tt> +
             * <tt>:universal-preconditions</tt>.</li>
             * <li><tt>:conditional-effects</tt> - Allows <tt>when</tt> clause in
             * actionCtx effects.</li>
             * <li><tt>:fluents</tt> - Allows function definitions and use of effects
             * using assignement operators and numeric preconditions.</li>
             * <li><tt>:adl</tt> - Is equivalent to <tt>:strips</tt> + <tt>:typing</tt> +
             * <tt>:negative-preconditions</tt> + <tt>:disjunctive-preconditions</tt> +
             * <tt>:equality</tt> + <tt>:quantified-preconditions</tt> + <tt>:conditional-effects</tt>.</li>
             * <li><tt>:durative-actions</tt> - Allows durative actions. Note that this
             * does note imply <tt>:fluents</tt>.</li>
             * <li><tt>:derived-predicate</tt> - Allows predicates whose truth value is
             * defined by a formula.</li>
             * <li><tt>:time-initial-literals</tt> - Allows the initial state to specify
             * literals that will become true at a specified time point implies <tt>durative-actions</tt>.</li>
             * <li><tt>:preferences</tt> - Allows use of preferences in actionCtx
             * preconditions and goals.</li>
             * <li><tt>:constraints</tt> - Allows use of constraints fields in domain and
             * problem description. These may contain modal operator supporting trajectory
             * constraints.</li>
             * </ul>
            
             * @author Damien Pellier
             * @version 1.0, 14/01/03
        </member>
        <member name="F:PDDLParser.Parser.Parser.PDDL_EXTENTION">
            The pddl file extension.
        </member>
        <member name="F:PDDLParser.Parser.Parser.m_mgr">
            The error manager of the parser.
        </member>
        <member name="F:PDDLParser.Parser.Parser.m_file">
            The parser input file.
        </member>
        <member name="F:PDDLParser.Parser.Parser.m_obj">
            The PDDL object returned by the parser. 
        </member>
        <member name="F:PDDLParser.Parser.Parser.m_acceptedRequirements">
            The requirement accepted by the parser.
            @uml.property  name="options"
        </member>
        <member name="M:PDDLParser.Parser.Parser.#ctor">
            Create a new <tt>Parser</tt>.
        </member>
        <member name="M:PDDLParser.Parser.Parser.#ctor(System.Collections.Generic.HashSet{PDDLParser.Parser.RequireKey})">
            Create a new <tt>Parser</tt> with a specific errors manager.
            
            @param acceptedRequirements the accepted requirements
        </member>
        <member name="M:PDDLParser.Parser.Parser.#ctor(PDDLParser.Parser.ErrorManager)">
            Create a new <tt>Parser</tt> with a specific errors manager.
            
            @param mgr the error manager of the parser.
        </member>
        <member name="M:PDDLParser.Parser.Parser.#ctor(System.Collections.Generic.HashSet{PDDLParser.Parser.RequireKey},PDDLParser.Parser.ErrorManager)">
            Create a new <tt>Parser</tt> with a specific errors manager.
            
            @param acceptedRequirements the accepted requirements.
            @param mgr the error manager of the parser.
        </member>
        <member name="M:PDDLParser.Parser.Parser.parse(System.String)">
            Parses a PDDL file.
            
            @param file the file to parse.
            @return The PDDL object representing the PDDL file or null if the parsing fails.
            @throws FileNotFoundException if the file to parse does not exist.
            @throws NullReferenceException if <code>file == null</code>.
        </member>
        <member name="M:PDDLParser.Parser.Parser.parseEffect(System.String)">
            <summary>
            Parses an effect from the given string.
            </summary>
            <param name="input">The string representing a parsable effect.</param>
            <returns>The parsed effect.</returns>
            <seealso cref="M:PDDLParser.Parser.Parser.effect(PDDLParser.Parser.Lexer.SimpleNode)"/>
            <exception cref="T:System.Exception">Thrown when parsing fails.</exception>
        </member>
        <member name="M:PDDLParser.Parser.Parser.parseEffect(System.String,System.Collections.Generic.IEnumerable{PDDLParser.Exp.IVariable})">
            <summary>
            Parses an effect from the given string with the given context.
            </summary>
            <param name="input">The string representing a parsable effect.</param>
            <param name="context">An enumeration of variable that might be in the parsed effect.</param>
            <returns>The parsed effect.</returns>
            <seealso cref="M:PDDLParser.Parser.Parser.effect(PDDLParser.Parser.Lexer.SimpleNode)"/>
            <exception cref="T:System.Exception">Thrown when parsing fails.</exception>
        </member>
        <member name="M:PDDLParser.Parser.Parser.parseLogicalExp(System.String)">
            <summary>
            Parses a logical expression from the given string.
            </summary>
            <param name="input">The string representing a parsable logical expression.</param>
            <returns>The parsed logical expression.</returns>
            <seealso cref="M:PDDLParser.Parser.Parser.gd(PDDLParser.Parser.Lexer.SimpleNode)"/>
            <exception cref="T:System.Exception">Thrown when parsing fails.</exception>
        </member>
        <member name="M:PDDLParser.Parser.Parser.parseLogicalExp(System.String,System.Collections.Generic.IEnumerable{PDDLParser.Exp.IVariable})">
            <summary>
            Parses a logical expression from the given string with the given context.
            </summary>
            <param name="input">The string representing a parsable logical expression.</param>
            <param name="context">An enumeration of variable that might be in the parsed logical expression.</param>
            <returns>The parsed logical expression.</returns>
            <seealso cref="M:PDDLParser.Parser.Parser.gd(PDDLParser.Parser.Lexer.SimpleNode)"/>
            <exception cref="T:System.Exception">Thrown when parsing fails.</exception>
        </member>
        <member name="M:PDDLParser.Parser.Parser.parseNumericExp(System.String)">
            <summary>
            Parses a numeric expression from the given string.
            </summary>
            <param name="input">The string representing a parsable numeric expression.</param>
            <returns>The parsed numeric expression.</returns>
            <seealso cref="M:PDDLParser.Parser.Parser.f_exp(PDDLParser.Parser.Lexer.SimpleNode)"/>
            <exception cref="T:System.Exception">Thrown when parsing fails.</exception>
        </member>
        <member name="M:PDDLParser.Parser.Parser.parseNumericExp(System.String,System.Collections.Generic.IEnumerable{PDDLParser.Exp.IVariable})">
            <summary>
            Parses a numeric expression from the given string with the given context.
            </summary>
            <param name="input">The string representing a parsable numeric expression.</param>
            <param name="context">An enumeration of variable that might be in the parsed numeric expression.</param>
            <returns>The parsed numeric expression.</returns>
            <seealso cref="M:PDDLParser.Parser.Parser.f_exp(PDDLParser.Parser.Lexer.SimpleNode)"/>
            <exception cref="T:System.Exception">Thrown when parsing fails.</exception>
        </member>
        <member name="M:PDDLParser.Parser.Parser.parseTerm(System.String)">
            <summary>
            Parses a term from the given string.
            </summary>
            <param name="input">The string representing a parsable term.</param>
            <returns>The parsed term.</returns>
            <seealso cref="M:PDDLParser.Parser.Parser.term(PDDLParser.Parser.Lexer.SimpleNode)"/>
            <exception cref="T:System.Exception">Thrown when parsing fails.</exception>
        </member>
        <member name="M:PDDLParser.Parser.Parser.parseTerm(System.String,System.Collections.Generic.IEnumerable{PDDLParser.Exp.IVariable})">
            <summary>
            Parses a term from the given string with the given context.
            </summary>
            <param name="input">The string representing a parsable term.</param>
            <param name="context">An enumeration of variable that might be in the parsed term.</param>
            <returns>The parsed term.</returns>
            <seealso cref="M:PDDLParser.Parser.Parser.term(PDDLParser.Parser.Lexer.SimpleNode)"/>
            <exception cref="T:System.Exception">Thrown when parsing fails.</exception>
        </member>
        <member name="M:PDDLParser.Parser.Parser.parseConstraintExp(System.String)">
            <summary>
            Parses a constraint expression from the given string.
            </summary>
            <param name="input">The string representing a parsable constraint expression.</param>
            <returns>The parsed constraint expression.</returns>
            <seealso cref="M:PDDLParser.Parser.Parser.con_gd(PDDLParser.Parser.Lexer.SimpleNode)"/>
            <seealso cref="M:PDDLParser.Parser.Parser.sub_con_gd(PDDLParser.Parser.Lexer.SimpleNode)"/>
            <exception cref="T:System.Exception">Thrown when parsing fails.</exception>
        </member>
        <member name="M:PDDLParser.Parser.Parser.parseConstraintExp(System.String,System.Collections.Generic.IEnumerable{PDDLParser.Exp.IVariable})">
            <summary>
            Parses a constraint expression from the given string with the given context.
            </summary>
            <param name="input">The string representing a parsable constraint expression.</param>
            <param name="context">An enumeration of variable that might be in the parsed constraint expression.</param>
            <returns>The parsed constraint expression.</returns>
            <seealso cref="M:PDDLParser.Parser.Parser.con_gd(PDDLParser.Parser.Lexer.SimpleNode)"/>
            <seealso cref="M:PDDLParser.Parser.Parser.sub_con_gd(PDDLParser.Parser.Lexer.SimpleNode)"/>
            <exception cref="T:System.Exception">Thrown when parsing fails.</exception>
        </member>
        <member name="M:PDDLParser.Parser.Parser.parseEvaluableExp(System.String)">
            <summary>
            Parses an evaluable expression from the given string.
            </summary>
            <remarks>
            An evaluable expression is either a logical expression, a numeric expression, or a term.
            </remarks>
            <param name="input">The string representing a parsable evaluable expression.</param>
            <returns>The parsed evaluable expression.</returns>
            <seealso cref="M:PDDLParser.Parser.Parser.parseLogicalExp(System.String)"/>
            <seealso cref="M:PDDLParser.Parser.Parser.parseNumericExp(System.String)"/>
            <seealso cref="M:PDDLParser.Parser.Parser.parseTerm(System.String)"/>
            <exception cref="T:System.Exception">Thrown when parsing fails.</exception>
        </member>
        <member name="M:PDDLParser.Parser.Parser.parseEvaluableExp(System.String,System.Collections.Generic.IEnumerable{PDDLParser.Exp.IVariable})">
            <summary>
            Parses an evaluable expression from the given string with the given context.
            </summary>
            <remarks>
            An evaluable expression is either a logical expression, a numeric expression, or a term.
            </remarks>
            <param name="input">The string representing a parsable evaluable expression.</param>
            <param name="context">An enumeration of variable that might be in the parsed evaluable expression.</param>
            <returns>The parsed evaluable expression.</returns>
            <seealso cref="M:PDDLParser.Parser.Parser.parseLogicalExp(System.String)"/>
            <seealso cref="M:PDDLParser.Parser.Parser.parseNumericExp(System.String)"/>
            <seealso cref="M:PDDLParser.Parser.Parser.parseTerm(System.String)"/>
            <exception cref="T:System.Exception">Thrown when parsing fails.</exception>
        </member>
        <member name="M:PDDLParser.Parser.Parser.parseExp(System.String)">
            <summary>
            Parses an expression from the given string.
            </summary>
            <remarks>
            The expression parsed is either a logical expression, a numeric expression, a term,
            a constraint expression, an effect, or a metric.
            </remarks>
            <param name="input">The string representing a parsable expression.</param>
            <returns>The parsed expression.</returns>
            <seealso cref="M:PDDLParser.Parser.Parser.parseLogicalExp(System.String)"/>
            <seealso cref="M:PDDLParser.Parser.Parser.parseNumericExp(System.String)"/>
            <seealso cref="M:PDDLParser.Parser.Parser.parseTerm(System.String)"/>
            <seealso cref="M:PDDLParser.Parser.Parser.parseEffect(System.String)"/>
            <seealso cref="M:PDDLParser.Parser.Parser.parseConstraintExp(System.String)"/>
            <exception cref="T:System.Exception">Thrown when parsing fails.</exception>
        </member>
        <member name="M:PDDLParser.Parser.Parser.parseExp(System.String,System.Collections.Generic.IEnumerable{PDDLParser.Exp.IVariable})">
            <summary>
            Parses an expression from the given string with the given context.
            </summary>
            <remarks>
            The expression parsed is either a logical expression, a numeric expression, a term,
            a constraint expression, an effect, or a metric.
            </remarks>
            <param name="input">The string representing a parsable expression.</param>
            <param name="context">An enumeration of variable that might be in the parsed expression.</param>
            <returns>The parsed expression.</returns>
            <seealso cref="M:PDDLParser.Parser.Parser.parseLogicalExp(System.String)"/>
            <seealso cref="M:PDDLParser.Parser.Parser.parseNumericExp(System.String)"/>
            <seealso cref="M:PDDLParser.Parser.Parser.parseTerm(System.String)"/>
            <seealso cref="M:PDDLParser.Parser.Parser.parseEffect(System.String)"/>
            <seealso cref="M:PDDLParser.Parser.Parser.parseConstraintExp(System.String)"/>
            <exception cref="T:System.Exception">Thrown when parsing fails.</exception>
        </member>
        <member name="M:PDDLParser.Parser.Parser.parseAction(System.String)">
            <summary>
            Parses an action from the given string.
            </summary>
            <remarks>
            The parsed action may be a simple STRIPS-like action or a durative action.
            </remarks>
            <param name="input">The string representing a parsable action.</param>
            <returns>The parsed action.</returns>
            <seealso cref="M:PDDLParser.Parser.Parser.action_def(PDDLParser.Parser.Lexer.SimpleNode)"/>
            <seealso cref="M:PDDLParser.Parser.Parser.durative_action_def(PDDLParser.Parser.Lexer.SimpleNode)"/>
            <exception cref="T:System.Exception">Thrown when parsing fails.</exception>
        </member>
        <member name="M:PDDLParser.Parser.Parser.parseInitEl(System.String)">
            <summary>
            Parses an initial literal from the given string.
            </summary>
            <param name="input">The string representing a parsable initial literal.</param>
            <returns>The parsed initial literal.</returns>
            <seealso cref="M:PDDLParser.Parser.Parser.init_el(PDDLParser.Parser.Lexer.SimpleNode)"/>
            <exception cref="T:System.Exception">Thrown when parsing fails.</exception>
        </member>
        <member name="M:PDDLParser.Parser.Parser.parseStructure(System.String)">
            <summary>
            Parses the structure definition of a PDDL domain from the given string.
            </summary>
            <param name="input">The string representing a parsable structure definition of a PDDL domain.</param>
            <returns>The parsed structure definition of a PDDL domain.</returns>
            <seealso cref="M:PDDLParser.Parser.Parser.structure_def(PDDLParser.Parser.Lexer.SimpleNode)"/>
            <exception cref="T:System.Exception">Thrown when parsing fails.</exception>
        </member>
        <member name="M:PDDLParser.Parser.Parser.parseExpression``1(System.String,System.Collections.Generic.IEnumerable{PDDLParser.Exp.IVariable},PDDLParser.Parser.Parser.lexerFunctDelegate,PDDLParser.Parser.Parser.parserFunctDelegate{``0})">
            <summary>
            Parses an expression from a string and a context, using the provided lexer and parser functions.
            </summary>
            <typeparam name="T">The type of the returned expression.</typeparam>
            <param name="input">The string representing the parsable expression.</param>
            <param name="context">An enumeration of variable that might be in the parsed expression.</param>
            <param name="lexerFunct">The delegate used to provide the right lexer function to parse the wanted expression.</param>
            <param name="parserFunct">The delegate used to provide the right parser function to parse the wanted expression
            from the node issued by the lexer.</param>
            <returns>The parsed expression.</returns>
            <exception cref="T:System.Exception">Thrown when parsing fails.</exception>
        </member>
        <member name="M:PDDLParser.Parser.Parser.parseExpression``1(System.String,System.Collections.Generic.IEnumerable{PDDLParser.Exp.IVariable},System.Collections.Generic.KeyValuePair{PDDLParser.Parser.Parser.lexerFunctDelegate,PDDLParser.Parser.Parser.parserFunctDelegate{``0}}[])">
            <summary>
            Parses an expression from a string and a context, using the first of several provided 
            lexer and parser functions that manages to parse the input.
            </summary>
            <typeparam name="T">The type of the returned expression.</typeparam>
            <param name="input">The string representing the parsable expression.</param>
            <param name="context">An enumeration of variable that might be in the parsed expression.</param>
            <param name="functions">An array of lexer and parser functions used to parse the wanted expression.</param>
            <returns>The parsed expression.</returns>
            <exception cref="T:System.Exception">Thrown when parsing fails.</exception>
        </member>
        <member name="M:PDDLParser.Parser.Parser.printSyntaxicTree(System.String)">
            Prints the syntaxic tree of a specific pddl file.
            
            @param file the pddl file.
            @throws FileNotFoundException if the file to parse does not exist.
            @throws NullReferenceException if <code>file == null</code>.
        </member>
        <member name="M:PDDLParser.Parser.Parser.getErrorManager">
            Returns the error manager of the compiler.
            
            @return the error manager of the compiler.
        </member>
        <member name="M:PDDLParser.Parser.Parser.setErrorManager(PDDLParser.Parser.ErrorManager)">
            Sets a new error manager to the compiler.
            
            @param mgr the new error manager of the compiler.
        </member>
        <member name="M:PDDLParser.Parser.Parser.link(PDDLParser.Parser.IDomain,PDDLParser.Parser.IProblem)">
            Creates a new PDDL
            object containing also the domain informations. This method is usefull to
            check the symbol shared between domain and problem input files. 
            
            @param domain the domain. 
            @param problem the problem.
            @return a PDDL object containing all the information needed for planning.
            @throws NullReferenceException if <code>domain == null || problem == null</code>.
        </member>
        <member name="M:PDDLParser.Parser.Parser.root(PDDLParser.Parser.Lexer.SimpleNode)">
            Extracts the object structures from the <code>ROOT</code> node of the
            syntaxic tree and implements the semantic check.
            
            @param node the <code>ROOT</code> node.
            @return the domain extract.
            @throws ParserException if an error occurs while parsing.
        </member>
        <member name="M:PDDLParser.Parser.Parser.problem(PDDLParser.Parser.Lexer.SimpleNode)">
            Extracts the object structures from a <code>PROBLEM</code> node of the
            syntaxic tree and implements the semantic check.
            
            @param node the <code>PROBLEM</code> node.
            @return the problem structure built.
            @throws ParserException if an error occurs while parsing.
        </member>
        <member name="M:PDDLParser.Parser.Parser.metric_spec(PDDLParser.Parser.Lexer.SimpleNode)">
            Extracts the object structures from the <code>METRIC_SPEC</code> node
            of the syntaxic tree and implements the semantic check.
            
            @param node the <code>METRIC_SPEC</code> node.
            @return the metric expression built.
            @throws ParserException if an error occurs while parsing.
        </member>
        <member name="M:PDDLParser.Parser.Parser.maximize(PDDLParser.Parser.Lexer.SimpleNode,System.Collections.Generic.List{System.String}@)">
            Extracts the object structures from the <code>MAXIMIZE</code> node
            of the syntaxic tree and implements the semantic check.
            
            @param node the <code>MAXIMIZE</code> node.
            @return the maximize expression built.
            @throws ParserException if an error occurs while parsing.
        </member>
        <member name="M:PDDLParser.Parser.Parser.minimize(PDDLParser.Parser.Lexer.SimpleNode,System.Collections.Generic.List{System.String}@)">
            Extracts the object structures from the <code>MINIMIZE</code> node
            of the syntaxic tree and implements the semantic check.
            
            @param node the <code>MINIMIZE</code> node.
            @return the minimize expression built.
            @throws ParserException if an error occurs while parsing.
        </member>
        <member name="M:PDDLParser.Parser.Parser.metric_f_exp(PDDLParser.Parser.Lexer.SimpleNode,System.Collections.Generic.List{System.String}@)">
            Extracts the object structures from the <code>METRIC_F_EXP</code> node
            of the syntaxic tree and implements the semantic check.
            
            @param node the <code>METRIC_F_EXP</code> node.
            @return the metric function expression built.
            @throws ParserException if an error occurs while parsing.
        </member>
        <member name="M:PDDLParser.Parser.Parser.violated_pref_exp(PDDLParser.Parser.Lexer.SimpleNode,System.Collections.Generic.List{System.String}@)">
            Extracts the object structures from the <code>VIOLATED_PREF_EXP</code> node of
            the syntaxic tree and implements the semantic check.
            
            @param node the <code>VIOLATED_PREF_EXP</code> node.
            @return the violated preference expression built.
            @throws ParserException if an error occurs while parsing.
        </member>
        <member name="M:PDDLParser.Parser.Parser.constant_f_head(PDDLParser.Parser.Lexer.SimpleNode)">
            Extracts the object structures from the <code>CONSTANT_F_HEAD</code> node of the
            syntaxic tree and implements the semantic check.
            
            @param node the <code>CONSTANT_F_HEADF_HEAD</code> node.
            @return the function head structure built.
            @throws ParserException if an error occurs while parsing.
        </member>
        <member name="M:PDDLParser.Parser.Parser.multi_op_metric_f_exp(PDDLParser.Parser.Lexer.SimpleNode,System.Collections.Generic.List{System.String}@)">
            Extracts the object structures from the <code>MULTI_OP_METRIC_F_EXP</code>
            node of the syntaxic tree and implements the semantic check.
            
            @param node the <code>MULTI_OP_METRIC_F_EXP</code> node.
            @return the binray numeric operation structure built.
            @throws ParserException if an error occurs while parsing.
        </member>
        <member name="M:PDDLParser.Parser.Parser.add_narity_op_metric_f_exp(PDDLParser.Parser.Lexer.SimpleNode,System.Collections.Generic.List{System.String}@)">
            Extracts the object structures from the <code>ADD_NARITY_OP_METRIC_F_EXP</code> node of the
            syntaxic tree and implements the semantic check.
            
            @param node the <code>ADD_NARITY_OP_METRIC_F_EXP</code> node.
            @return the multi divide function expression build
            @throws ParserException if an error occurs while parsing.
        </member>
        <member name="M:PDDLParser.Parser.Parser.substract_narity_op_metric_f_exp(PDDLParser.Parser.Lexer.SimpleNode,System.Collections.Generic.List{System.String}@)">
            Extracts the object structures from the <code>SUBSTRACT_NARITY_OP_METRIC_F_EXP</code> node of the
            syntaxic tree and implements the semantic check.
            
            @param node the <code>SUBSTRACT_NARITY_OP_METRIC_F_EXP</code> node.
            @return the multi divide function expression build
            @throws ParserException if an error occurs while parsing.
        </member>
        <member name="M:PDDLParser.Parser.Parser.multiply_narity_op_metric_f_exp(PDDLParser.Parser.Lexer.SimpleNode,System.Collections.Generic.List{System.String}@)">
            Extracts the object structures from the <code>MULTIPLY_NARITY_OP_METRIC_F_EXP</code> node of the
            syntaxic tree and implements the semantic check.
            
            @param node the <code>MULTIPLY_NARITY_OP_METRIC_F_EXP</code> node.
            @return the multi divide function expression build
            @throws ParserException if an error occurs while parsing.
        </member>
        <member name="M:PDDLParser.Parser.Parser.divide_narity_op_metric_f_exp(PDDLParser.Parser.Lexer.SimpleNode,System.Collections.Generic.List{System.String}@)">
            Extracts the object structures from the <code>DIVIDE_NARITY_OP_METRIC_F_EXP</code> node of the
            syntaxic tree and implements the semantic check.
            
            @param node the <code>DIVIDE_NARITY_OP_METRIC_F_EXP</code> node.
            @return the multi divide function expression build
            @throws ParserException if an error occurs while parsing.
        </member>
        <member name="M:PDDLParser.Parser.Parser.goal(PDDLParser.Parser.Lexer.SimpleNode)">
            Extracts the object structures from the <code>INIT</code> node
            of the syntaxic tree and implements the semantic check.
            
            @param node the <code>INIT</code> node.
            @return the initial state structure built.
            @throws ParserException if an error occurs while parsing.
        </member>
        <member name="M:PDDLParser.Parser.Parser.init(PDDLParser.Parser.Lexer.SimpleNode)">
            Extracts the object structures from the <code>INIT</code> node
            of the syntaxic tree and implements the semantic check.
            
            @param node the <code>INIT</code> node.
            @return the initial state structure built.
            @throws ParserException if an error occurs while parsing.
        </member>
        <member name="M:PDDLParser.Parser.Parser.init_el(PDDLParser.Parser.Lexer.SimpleNode)">
            Extracts the object structures from the <code>INIT_EL</code> node
            of the syntaxic tree and implements the semantic check.
            
            @param node the <code>INIT_EL</code> node.
            @return initial state element.
            @throws ParserException if an error occurs while parsing.
        </member>
        <member name="M:PDDLParser.Parser.Parser.timed_literal(PDDLParser.Parser.Lexer.SimpleNode)">
            Extracts the object structures from the <code>INIT_EL</code> node
            of the syntaxic tree and implements the semantic check.
            
            @param node the <code>INIT_EL</code> node.
            @return initial state element.
            @throws ParserException if an error occurs while parsing.
        </member>
        <member name="M:PDDLParser.Parser.Parser.equal_init_el(PDDLParser.Parser.Lexer.SimpleNode)">
            Extracts the object structures from the <code>INIT_EL</code> node
            of the syntaxic tree and implements the semantic check.
            
            @param node the <code>INIT_EL</code> node.
            @return initial state element.
            @throws ParserException if an error occurs while parsing.
        </member>
        <member name="M:PDDLParser.Parser.Parser.object_declaration(PDDLParser.Parser.Lexer.SimpleNode)">
            Extracts the object structures from the <code>OBJECT_DECLARATION</code> node
            of the syntaxic tree and implements the semantic check.
            
            @param node the <code>OBJECT_DECLARATION</code> node.
            @return the object declartion structure built.
            @throws ParserException if an error occurs while parsing.
        </member>
        <member name="M:PDDLParser.Parser.Parser.domain(PDDLParser.Parser.Lexer.SimpleNode)">
            Extracts the object structures from a <code>DOMAIN</code> node of the
            syntaxic tree and implements the semantic check.
            
            @param node the <code>DOMAIN</code> node.
            @return the domain structure built.
            @throws ParserException if an error occurs while parsing.
        </member>
        <member name="M:PDDLParser.Parser.Parser.structure_def(PDDLParser.Parser.Lexer.SimpleNode)">
            Extracts the object structures from the <code>STRUCTURE_DEF</code> node
            of the syntaxic tree and implements the semantic check.
            
            @param node the <code>STRUCTURE_DEF</code> node.
            @throws ParserException if an error occurs while parsing.
        </member>
        <member name="M:PDDLParser.Parser.Parser.durative_action_def(PDDLParser.Parser.Lexer.SimpleNode)">
            Extracts the object structures from the <code>DURATIVE_ACTION</code> node
            of the syntaxic tree and implements the semantic check.
            
            @param node the <code>DURATIVE_ACTION</code> node.
            @return the durative actionCtx structure built. 
            @throws ParserException if an error occurs while parsing.
        </member>
        <member name="M:PDDLParser.Parser.Parser.da_def_body(PDDLParser.Parser.Lexer.SimpleNode,PDDLParser.Action.DurativeAction)">
            Extracts the object structures from the <code>DA_DEF_BODY</code> node
            of the syntaxic tree and implements the semantic check.
            
            @param node the <code>DA_DEF_BODY</code> node.
            @param action the duratiive actionCtx to initialize.
            @throws ParserException if an error occurs while parsing.
        </member>
        <member name="M:PDDLParser.Parser.Parser.da_effect(PDDLParser.Parser.Lexer.SimpleNode,System.Collections.Generic.IDictionary{PDDLParser.Parser.Parser.ConditionTime,System.Collections.Generic.List{PDDLParser.Exp.IEffect}}@)">
            Extracts the object structures from the <code>DA_EFFECT</code> node
            of the syntaxic tree and implements the semantic check.
            
            @param node the <code>DA_EFFECT</code> node.
            @return the durative actionCtx effect  expression built
            @throws ParserException if an error occurs while parsing.
        </member>
        <member name="M:PDDLParser.Parser.Parser.when_da_effect(PDDLParser.Parser.Lexer.SimpleNode,System.Collections.Generic.IDictionary{PDDLParser.Parser.Parser.ConditionTime,System.Collections.Generic.List{PDDLParser.Exp.IEffect}}@)">
            Extracts the object structures from the <code>WHEN_DA_EFFECT</code>
            node of the syntaxic tree and implements the semantic check.
            
            @param node the <code>WHEN_DA_EFFECT</code> node.
            @return the when duratve actionCtx effect expression built.
            @throws ParserException if an error occurs while parsing.
        </member>
        <member name="M:PDDLParser.Parser.Parser.forall_da_effect(PDDLParser.Parser.Lexer.SimpleNode,System.Collections.Generic.IDictionary{PDDLParser.Parser.Parser.ConditionTime,System.Collections.Generic.List{PDDLParser.Exp.IEffect}}@)">
            Extracts the object structures from the <code>FORALL_DA_EFFECT</code> node of
            the syntaxic tree and implements the semantic check.
            
            @param node the <code>FORALL_DA_EFFECT</code> node.
            @return the universal durative effect expression structure built.
            @throws ParserException if an error occurs while parsing.
        </member>
        <member name="M:PDDLParser.Parser.Parser.timed_effect(PDDLParser.Parser.Lexer.SimpleNode,System.Collections.Generic.IDictionary{PDDLParser.Parser.Parser.ConditionTime,System.Collections.Generic.List{PDDLParser.Exp.IEffect}}@)">
            Extracts the object structures from the <code>TIMED_EFFECT</code> node
            of the syntaxic tree and implements the semantic check.
            
            @param node the <code>TIMED_EFFECT</code> node.
            @return the timed effect expression built
            @throws ParserException if an error occurs while parsing.
        </member>
        <member name="M:PDDLParser.Parser.Parser.assign_op_t(PDDLParser.Parser.Lexer.SimpleNode)">
            Extracts the object structures from the <code>ASSIGN_OP_T</code>
            node of the syntaxic tree and implements the semantic check.
            
            @param node the <code>ASSIGN_OP_T</code> node.
            @return the durative assign operation expression built.
            @throws ParserException if an error occurs while parsing.
        </member>
        <member name="M:PDDLParser.Parser.Parser.increase_assign_op_t(PDDLParser.Parser.Lexer.SimpleNode)">
            Extracts the object structures from the <code>INCREASE_ASSIGN_OP_T</code>
            node of the syntaxic tree and implements the semantic check.
            
            @param node the <code>INCREASE_ASSIGN_OP_T</code> node.
            @return the durative assign operation expression built.
            @throws ParserException if an error occurs while parsing.
        </member>
        <member name="M:PDDLParser.Parser.Parser.decrease_assign_op_t(PDDLParser.Parser.Lexer.SimpleNode)">
            Extracts the object structures from the <code>DECREASE_ASSIGN_OP_T</code>
            node of the syntaxic tree and implements the semantic check.
            
            @param node the <code>DECREASE_ASSIGN_OP_T</code> node.
            @return the durative assign operation expression built.
            @throws ParserException if an error occurs while parsing.
        </member>
        <member name="M:PDDLParser.Parser.Parser.assign_op(PDDLParser.Parser.Lexer.SimpleNode)">
            Extracts the object structures from the <code>ASSIGN_OP</code>
            node of the syntaxic tree and implements the semantic check.
            
            @param node the <code>ASSIGN_OP</code> node.
            @return the durative assign operation expression built.
            @throws ParserException if an error occurs while parsing.
        </member>
        <member name="M:PDDLParser.Parser.Parser.assign(PDDLParser.Parser.Lexer.SimpleNode)">
            Extracts the object structures from the <code>ASSIGN</code>
            node of the syntaxic tree and implements the semantic check.
            
            @param node the <code>ASSIGN</code> node.
            @return the propositional effect expression built.
            @throws ParserException if an error occurs while parsing.
        </member>
        <member name="M:PDDLParser.Parser.Parser.scale_up(PDDLParser.Parser.Lexer.SimpleNode)">
            Extracts the object structures from the <code>SCALE_UP</code>
            node of the syntaxic tree and implements the semantic check.
            
            @param node the <code>SCALE_UP</code> node.
            @return the assign scale up expression built.
            @throws ParserException if an error occurs while parsing.
        </member>
        <member name="M:PDDLParser.Parser.Parser.scale_down(PDDLParser.Parser.Lexer.SimpleNode)">
            Extracts the object structures from the <code>SCALE_DOWN</code>
            node of the syntaxic tree and implements the semantic check.
            
            @param node the <code>SCALE_DOWN</code> node.
            @return the assign scale up expression built.
            @throws ParserException if an error occurs while parsing.
        </member>
        <member name="M:PDDLParser.Parser.Parser.increase(PDDLParser.Parser.Lexer.SimpleNode)">
            Extracts the object structures from the <code>INCREASE</code>
            node of the syntaxic tree and implements the semantic check.
            
            @param node the <code>INCREASE</code> node.
            @return the increase expression built.
            @throws ParserException if an error occurs while parsing.
        </member>
        <member name="M:PDDLParser.Parser.Parser.decrease(PDDLParser.Parser.Lexer.SimpleNode)">
            Extracts the object structures from the <code>DECREASE</code>
            node of the syntaxic tree and implements the semantic check.
            
            @param node the <code>DECREASE</code> node.
            @return the descrease expression built.
            @throws ParserException if an error occurs while parsing.
        </member>
        <member name="M:PDDLParser.Parser.Parser.f_exp_t(PDDLParser.Parser.Lexer.SimpleNode)">
            Extracts the object structures from the <code>F_EXP_T</code>
            node of the syntaxic tree and implements the semantic check.
            
            @param node the <code>F_EXP_T</code> node.
            @return the durative fonction expression built.
            @throws ParserException if an error occurs while parsing.
        </member>
        <member name="M:PDDLParser.Parser.Parser.at_f_assign_da_effect(PDDLParser.Parser.Lexer.SimpleNode,System.Collections.Generic.IDictionary{PDDLParser.Parser.Parser.ConditionTime,System.Collections.Generic.List{PDDLParser.Exp.IEffect}}@)">
            Extracts the object structures from the <code>AT_F_ASSIGN_DA_EFFECT</code> node
            of the syntaxic tree and implements the semantic check.
            
            @param node the <code>AT_F_ASSIGN_DA_EFFECT</code> node.
            @return the at durative actionCtx effect expression that Contains a fonction assign.
            @throws ParserException if an error occurs while parsing.
        </member>
        <member name="M:PDDLParser.Parser.Parser.at_start_f_assign_da_effect(PDDLParser.Parser.Lexer.SimpleNode)">
            Extracts the object structures from the <code>AT_START_F_ASSIGN_DA_EFFECT</code>
            node of the syntaxic tree and implements the semantic check.
            
            @param node the <code>AT_START_F_ASSIGN_DA_EFFECT</code> node.
            @return the at start durative actionCtx effect expression built.
            @throws ParserException if an error occurs while parsing.
        </member>
        <member name="M:PDDLParser.Parser.Parser.at_end_f_assign_da_effect(PDDLParser.Parser.Lexer.SimpleNode)">
            Extracts the object structures from the <code>AT_END_F_ASSIGN_DA_EFFECT</code>
            node of the syntaxic tree and implements the semantic check.
            
            @param node the <code>AT_END_F_ASSIGN_DA_EFFECT</code> node.
            @return the at start durative actionCtx effect expression built.
            @throws ParserException if an error occurs while parsing.
        </member>
        <member name="M:PDDLParser.Parser.Parser.da_scale_up(PDDLParser.Parser.Lexer.SimpleNode)">
            Extracts the object structures from the <code>DA_SCALE_UP</code>
            node of the syntaxic tree and implements the semantic check.
            
            @param node the <code>DA_SCALE_UP</code> node.
            @return the durative actionCtx assign scale up expression built.
            @throws ParserException if an error occurs while parsing.
        </member>
        <member name="M:PDDLParser.Parser.Parser.da_decrease(PDDLParser.Parser.Lexer.SimpleNode)">
            Extracts the object structures from the <code>DA_DECREASE</code>
            node of the syntaxic tree and implements the semantic check.
            
            @param node the <code>DA_DECREASE</code> node.
            @return the durative actionCtx descrease expression built.
            @throws ParserException if an error occurs while parsing.
        </member>
        <member name="M:PDDLParser.Parser.Parser.da_increase(PDDLParser.Parser.Lexer.SimpleNode)">
            Extracts the object structures from the <code>DA_INCREASE</code>
            node of the syntaxic tree and implements the semantic check.
            
            @param node the <code>DA_INCREASE</code> node.
            @return the durative actionCtx increase expression built.
            @throws ParserException if an error occurs while parsing.
        </member>
        <member name="M:PDDLParser.Parser.Parser.da_scale_down(PDDLParser.Parser.Lexer.SimpleNode)">
            Extracts the object structures from the <code>DA_SCALE_DOWN</code>
            node of the syntaxic tree and implements the semantic check.
            
            @param node the <code>DA_SCALE_DOWN</code> node.
            @return the surative actionCtx assign scale up expression built.
            @throws ParserException if an error occurs while parsing.
        </member>
        <member name="M:PDDLParser.Parser.Parser.da_assign(PDDLParser.Parser.Lexer.SimpleNode)">
            Extracts the object structures from the <code>DA_ASSIGN</code>
            node of the syntaxic tree and implements the semantic check.
            
            @param node the <code>DA_ASSIGN</code> node.
            @return the durative assign effect expression built.
            @throws ParserException if an error occurs while parsing.
        </member>
        <member name="M:PDDLParser.Parser.Parser.f_exp_da(PDDLParser.Parser.Lexer.SimpleNode)">
            Extracts the object structures from the <code>F_EXP_DA</code> node of the
            syntaxic tree and implements the semantic check.
            
            @param node the <code>F_EXP_DA</code> node.
            @return the durative fonction expression structure built.
            @throws ParserException if an error occurs while parsing.
        </member>
        <member name="M:PDDLParser.Parser.Parser.da_op(PDDLParser.Parser.Lexer.SimpleNode)">
            Extracts the object structures from the <code>DA_BINARY_OP</code>
            node of the syntaxic tree and implements the semantic check.
            
            @param node the <code>DA_BINARY_OP</code> node.
            @return the surative binary numeric operation structure built.
            @throws ParserException if an error occurs while parsing.
        </member>
        <member name="M:PDDLParser.Parser.Parser.da_add_op(PDDLParser.Parser.Lexer.SimpleNode)">
            Extracts the object structures from the <code>DA_ADD_OPERATION</code> node
            of the syntaxic tree and implements the semantic check.
            
            @param node the <code>DA_ADD_OPERATION</code> node.
            @return the add operation structure built.
            @throws ParserException if an error occurs while parsing.
        </member>
        <member name="M:PDDLParser.Parser.Parser.da_substract_op(PDDLParser.Parser.Lexer.SimpleNode)">
            Extracts the object structures from the <code>DA_SUBSTRACT_OP</code>
            node of the syntaxic tree and implements the semantic check.
            
            @param node the <code>DA_SUBSTRACT_OP</code> node.
            @return the substract operation structure built.
            @throws ParserException if an error occurs while parsing.
        </member>
        <member name="M:PDDLParser.Parser.Parser.da_multiply_op(PDDLParser.Parser.Lexer.SimpleNode)">
            Extracts the object structures from the <code>DA_MULTIPLY_OP</code>
            node of the syntaxic tree and implements the semantic check.
            
            @param node the <code>DA_MULTIPLY_OP</code> node.
            @return the durative multiply operation structure built.
            @throws ParserException if an error occurs while parsing.
        </member>
        <member name="M:PDDLParser.Parser.Parser.da_divide_op(PDDLParser.Parser.Lexer.SimpleNode)">
            Extracts the object structures from the <code>DA_DIVIDE_OP</code>
            node of the syntaxic tree and implements the semantic check.
            
            @param node the <code>DA_DIVIDE_OP</code> node.
            @return the durative divide operation structure built.
            @throws ParserException if an error occurs while parsing.
        </member>
        <member name="M:PDDLParser.Parser.Parser.at_da_effect(PDDLParser.Parser.Lexer.SimpleNode,System.Collections.Generic.IDictionary{PDDLParser.Parser.Parser.ConditionTime,System.Collections.Generic.List{PDDLParser.Exp.IEffect}}@)">
            Extracts the object structures from the <code>AT_DA_EFFECT</code> node
            of the syntaxic tree and implements the semantic check.
            
            @param node the <code>AT_DA_EFFECT</code> node.
            @return the at durative actionCtx effect expression built
            @throws ParserException if an error occurs while parsing.
        </member>
        <member name="M:PDDLParser.Parser.Parser.at_end_da_effect(PDDLParser.Parser.Lexer.SimpleNode)">
            Extracts the object structures from the <code>AT_END_DA_EFFECT</code>
            node of the syntaxic tree and implements the semantic check.
            
            @param node the <code>AT_END_DA_EFFECT</code> node.
            @return the at start durative actionCtx effect expression built.
            @throws ParserException if an error occurs while parsing.
        </member>
        <member name="M:PDDLParser.Parser.Parser.at_start_da_effect(PDDLParser.Parser.Lexer.SimpleNode)">
            Extracts the object structures from the <code>AT_START_DA_EFFECT</code>
            node of the syntaxic tree and implements the semantic check.
            
            @param node the <code>AT_START_DA_EFFECT</code> node.
            @return the at start durative actionCtx effect expression built.
            @throws ParserException if an error occurs while parsing.
        </member>
        <member name="M:PDDLParser.Parser.Parser.and_da_effect(PDDLParser.Parser.Lexer.SimpleNode,System.Collections.Generic.IDictionary{PDDLParser.Parser.Parser.ConditionTime,System.Collections.Generic.List{PDDLParser.Exp.IEffect}}@)">
            Extracts the object structures from the <code>AND_DA_EFFECT</code> node of the
            syntaxic tree and implements the semantic check.
            
            @param node the <code>AND_DA_EFFECT</code> node.
            @return the conjunctive durative actionCtx effect expression built.
            @throws ParserException if an error occurs while parsing.
        </member>
        <member name="M:PDDLParser.Parser.Parser.da_gd(PDDLParser.Parser.Lexer.SimpleNode,System.Collections.Generic.IDictionary{PDDLParser.Parser.Parser.ConditionTime,System.Collections.Generic.List{PDDLParser.Exp.ILogicalExp}}@,System.Collections.Generic.IDictionary{PDDLParser.Parser.Parser.ConditionTime,System.Collections.Generic.List{PDDLParser.Exp.IConditionPrefExp}}@)">
            Extracts the object structures from the <code>DA_GD</code> node
            of the syntaxic tree and implements the semantic check.
            
            @param node the <code>DA_GD</code> node.
            @return the durative actionCtx goal description expression built
            @throws ParserException if an error occurs while parsing.
        </member>
        <member name="M:PDDLParser.Parser.Parser.forall_da_gd(PDDLParser.Parser.Lexer.SimpleNode,System.Collections.Generic.IDictionary{PDDLParser.Parser.Parser.ConditionTime,System.Collections.Generic.List{PDDLParser.Exp.ILogicalExp}}@,System.Collections.Generic.IDictionary{PDDLParser.Parser.Parser.ConditionTime,System.Collections.Generic.List{PDDLParser.Exp.IConditionPrefExp}}@)">
            Extracts the object structures from the <code>FORALL_DA_GD</code> node of
            the syntaxic tree and implements the semantic check.
            
            @param node the <code>FORALL_DA_GD</code> node.
            @return the universal duartive actionCtx goal description structure built.
            @throws ParserException if an error occurs while parsing.
        </member>
        <member name="M:PDDLParser.Parser.Parser.and_da_gd(PDDLParser.Parser.Lexer.SimpleNode,System.Collections.Generic.IDictionary{PDDLParser.Parser.Parser.ConditionTime,System.Collections.Generic.List{PDDLParser.Exp.ILogicalExp}}@,System.Collections.Generic.IDictionary{PDDLParser.Parser.Parser.ConditionTime,System.Collections.Generic.List{PDDLParser.Exp.IConditionPrefExp}}@)">
            Extracts the object structures from the <code>AND_DA_GD</code> node of the
            syntaxic tree and implements the semantic check.
            
            @param node the <code>AND_DA_GD</code> node.
            @return the conjunctive durative actionCtx goal description structure built.
            @throws ParserException if an error occurs while parsing.
        </member>
        <member name="M:PDDLParser.Parser.Parser.pref_timed_gd(PDDLParser.Parser.Lexer.SimpleNode,System.Collections.Generic.IDictionary{PDDLParser.Parser.Parser.ConditionTime,System.Collections.Generic.List{PDDLParser.Exp.ILogicalExp}}@,System.Collections.Generic.IDictionary{PDDLParser.Parser.Parser.ConditionTime,System.Collections.Generic.List{PDDLParser.Exp.IConditionPrefExp}}@)">
            Extracts the object structures from the <code>PREF_TIMED_GD</code> node
            of the syntaxic tree and implements the semantic check.
            
            @param node the <code>PREF_TIMED_GD</code> node.
            @return the preference timed goal description expression built
            @throws ParserException if an error occurs while parsing.
        </member>
        <member name="M:PDDLParser.Parser.Parser.named_pref_timed_gd(PDDLParser.Parser.Lexer.SimpleNode,System.Collections.Generic.IDictionary{PDDLParser.Parser.Parser.ConditionTime,System.Collections.Generic.List{PDDLParser.Exp.ILogicalExp}}@,System.Collections.Generic.IDictionary{PDDLParser.Parser.Parser.ConditionTime,System.Collections.Generic.List{PDDLParser.Exp.IConditionPrefExp}}@)">
            Extracts the object structures from the <code>NAMED_PREF_TIMED_GD</code> node
            of the syntaxic tree and implements the semantic check.
            
            @param node the <code>NAMED_PREF_TIMED_GD</code> node.
            @return the name preference timed goal description expression built
            @throws ParserException if an error occurs while parsing.
        </member>
        <member name="M:PDDLParser.Parser.Parser.timed_gd(PDDLParser.Parser.Lexer.SimpleNode,System.Collections.Generic.IDictionary{PDDLParser.Parser.Parser.ConditionTime,System.Collections.Generic.List{PDDLParser.Exp.ILogicalExp}}@)">
            Extracts the object structures from the <code>TIMED_GD</code> node
            of the syntaxic tree and implements the semantic check.
            
            @param node the <code>TIMED_GD</code> node.
            @return the timed goal description expression built
            @throws ParserException if an error occurs while parsing.
        </member>
        <member name="M:PDDLParser.Parser.Parser.over_timed_gd(PDDLParser.Parser.Lexer.SimpleNode,System.Collections.Generic.IDictionary{PDDLParser.Parser.Parser.ConditionTime,System.Collections.Generic.List{PDDLParser.Exp.ILogicalExp}}@)">
            Extracts the object structures from the <code>OVER_TIMED_GD</code> node
            of the syntaxic tree and implements the semantic check.
            
            @param node the <code>OVER_TIMED_GD</code> node.
            @return the over timed goal description expression built
            @throws ParserException if an error occurs while parsing.
        </member>
        <member name="M:PDDLParser.Parser.Parser.over_all_timed_gd(PDDLParser.Parser.Lexer.SimpleNode)">
            Extracts the object structures from the <code>OVER_ALL_TIMED_GD</code> node
            of the syntaxic tree and implements the semantic check.
            
            @param node the <code>OVER_ALL_TIMED_GD</code> node.
            @return the over all timed goal description expression built
            @throws ParserException if an error occurs while parsing.
        </member>
        <member name="M:PDDLParser.Parser.Parser.at_timed_gd(PDDLParser.Parser.Lexer.SimpleNode,System.Collections.Generic.IDictionary{PDDLParser.Parser.Parser.ConditionTime,System.Collections.Generic.List{PDDLParser.Exp.ILogicalExp}}@)">
            Extracts the object structures from the <code>AT_TIMED_GD</code> node
            of the syntaxic tree and implements the semantic check.
            
            @param node the <code>AT_TIMED_GD</code> node.
            @return the at timed goal description expression built
            @throws ParserException if an error occurs while parsing.
        </member>
        <member name="M:PDDLParser.Parser.Parser.at_start_timed_gd(PDDLParser.Parser.Lexer.SimpleNode)">
            Extracts the object structures from the <code>AT_START_TIMED_GD</code>
            node of the syntaxic tree and implements the semantic check.
            
            @param node the <code>AT_START_TIMED_GD</code> node.
            @return the at start timed goal description expression built.
            @throws ParserException if an error occurs while parsing.
        </member>
        <member name="M:PDDLParser.Parser.Parser.at_end_timed_gd(PDDLParser.Parser.Lexer.SimpleNode)">
            Extracts the object structures from the <code>AT_END_TIMED_GD</code>
            node of the syntaxic tree and implements the semantic check.
            
            @param node the <code>AT_END_TIMED_GD</code> node.
            @return the at end timed goal description expression built.
            @throws ParserException if an error occurs while parsing.
        </member>
        <member name="M:PDDLParser.Parser.Parser.duration_constraint(PDDLParser.Parser.Lexer.SimpleNode,System.Collections.Generic.IDictionary{PDDLParser.Parser.Parser.DurationTime,System.Collections.Generic.List{PDDLParser.Exp.ILogicalExp}}@)">
            Extracts the object structures from the <code>DURATION_CONSTRAINT</code> node
            of the syntaxic tree and implements the semantic check.
            
            @param node the <code>DURATION_CONSTRAINT</code> node.
            @return the duration constraint expression built
            @throws ParserException if an error occurs while parsing.
        </member>
        <member name="M:PDDLParser.Parser.Parser.and_simple_duration_constraint(PDDLParser.Parser.Lexer.SimpleNode,PDDLParser.Parser.Parser.DurationTime,System.Collections.Generic.IDictionary{PDDLParser.Parser.Parser.DurationTime,System.Collections.Generic.List{PDDLParser.Exp.ILogicalExp}}@)">
            Extracts the object structures from the <code>AND_SIMPLE_DURATION_CONSTRAINT</code>
            node of the syntaxic tree and implements the semantic check.
            
            @param node the <code>AND_SIMPLE_DURATION_CONSTRAINT</code> node.
            @return the conjuncive simple duration constraint expression built.
            @throws ParserException if an error occurs while parsing.
        </member>
        <member name="M:PDDLParser.Parser.Parser.simple_duration_constraint(PDDLParser.Parser.Lexer.SimpleNode,PDDLParser.Parser.Parser.DurationTime,System.Collections.Generic.IDictionary{PDDLParser.Parser.Parser.DurationTime,System.Collections.Generic.List{PDDLParser.Exp.ILogicalExp}}@)">
            Extracts the object structures from the <code>SIMPLE_DURATION_CONSTRAINT</code> node
            of the syntaxic tree and implements the semantic check.
            
            @param node the <code>SIMPLE_DURATION_CONSTRAINT</code> node.
            @return the simple duration constraint expression built
            @throws ParserException if an error occurs while parsing.
        </member>
        <member name="M:PDDLParser.Parser.Parser.at_simple_duration_constraint(PDDLParser.Parser.Lexer.SimpleNode,PDDLParser.Parser.Parser.DurationTime,System.Collections.Generic.IDictionary{PDDLParser.Parser.Parser.DurationTime,System.Collections.Generic.List{PDDLParser.Exp.ILogicalExp}}@)">
            Extracts the object structures from the <code>AT_SIMPLE_DURATION_CONSTRAINT</code> node
            of the syntaxic tree and implements the semantic check.
            
            @param node the <code>AT_SIMPLE_DURATION_CONSTRAINT</code> node.
            @return the at simple duration constraint expression built.
            @throws ParserException if an error occurs while parsing.
        </member>
        <member name="M:PDDLParser.Parser.Parser.at_end_simple_duration_constraint(PDDLParser.Parser.Lexer.SimpleNode,PDDLParser.Parser.Parser.DurationTime,System.Collections.Generic.IDictionary{PDDLParser.Parser.Parser.DurationTime,System.Collections.Generic.List{PDDLParser.Exp.ILogicalExp}}@)">
            Extracts the object structures from the <code>AT_END_SIMPLE_DURATION_CONSTRAINT</code>
            node of the syntaxic tree and implements the semantic check.
            
            @param node the <code>AT_END_SIMPLE_DURATION_CONSTRAINT</code> node.
            @return the at end simple durative constraint expression built.
            @throws ParserException if an error occurs while parsing.
        </member>
        <member name="M:PDDLParser.Parser.Parser.at_start_simple_duration_constraint(PDDLParser.Parser.Lexer.SimpleNode,PDDLParser.Parser.Parser.DurationTime,System.Collections.Generic.IDictionary{PDDLParser.Parser.Parser.DurationTime,System.Collections.Generic.List{PDDLParser.Exp.ILogicalExp}}@)">
            Extracts the object structures from the <code>AT_START_SIMPLE_DURATION_CONSTRAINT</code> node
            of the syntaxic tree and implements the semantic check.
            
            @param node the <code>AT_START_SIMPLE_DURATION_CONSTRAINT</code> node.
            @return the at start simple durative constraint expression built.
            @throws ParserException if an error occurs while parsing.
        </member>
        <member name="M:PDDLParser.Parser.Parser.d_op(PDDLParser.Parser.Lexer.SimpleNode)">
            Extracts the object structures from the <code>D_OP</code> node
            of the syntaxic tree and implements the semantic check.
            
            @param node the <code>D_OP</code> node.
            @return the durative operation expression built
            @throws ParserException if an error occurs while parsing.
        </member>
        <member name="M:PDDLParser.Parser.Parser.equal_d_op(PDDLParser.Parser.Lexer.SimpleNode)">
            Extracts the object structures from the <code>EQUAL_D_OP</code> node
            of the syntaxic tree and implements the semantic check.
            
            @param node the <code>EQUAL_D_OP</code> node.
            @return the equal durative operation expression built
            @throws ParserException if an error occurs while parsing.
        </member>
        <member name="M:PDDLParser.Parser.Parser.lequal_d_op(PDDLParser.Parser.Lexer.SimpleNode)">
            Extracts the object structures from the <code>LEQUAL_D_OP</code> node
            of the syntaxic tree and implements the semantic check.
            
            @param node the <code>LEQUAL_D_OP</code> node.
            @return the less equal durative operation expression built
            @throws ParserException if an error occurs while parsing.
        </member>
        <member name="M:PDDLParser.Parser.Parser.gequal_d_op(PDDLParser.Parser.Lexer.SimpleNode)">
            Extracts the object structures from the <code>GEQUAL_D_OP</code> node
            of the syntaxic tree and implements the semantic check.
            
            @param node the <code>GEQUAL_D_OP</code> node.
            @return the greater equal durative operation expression built
            @throws ParserException if an error occurs while parsing.
        </member>
        <member name="M:PDDLParser.Parser.Parser.d_value(PDDLParser.Parser.Lexer.SimpleNode)">
            Extracts the object structures from the <code>GEQUAL_D_OP</code> node
            of the syntaxic tree and implements the semantic check.
            
            @param node the <code>D_OP</code> node.
            @return the greater equal durative operation expression built
            @throws ParserException if an error occurs while parsing.
        </member>
        <member name="M:PDDLParser.Parser.Parser.empty_or(PDDLParser.Parser.Lexer.SimpleNode)">
            Extracts the object structures from the <code>EMPTY_OR</code> node
            of the syntaxic tree and implements the semantic check.
            
            @param node the <code>EMPTY_OR</code> node.
            @return the empty or expression built
            @throws ParserException if an error occurs while parsing.
        </member>
        <member name="M:PDDLParser.Parser.Parser.derived_def(PDDLParser.Parser.Lexer.SimpleNode)">
            Extracts the object structures from the <code>DERIVED_DEF</code> node
            of the syntaxic tree and implements the semantic check.
            
            @param node the <code>DERIVED_DEF</code> node.
            @return the actionCtx structure built.
            @throws ParserException if an error occurs while parsing.
        </member>
        <member name="M:PDDLParser.Parser.Parser.defined_predicate(PDDLParser.Parser.Lexer.SimpleNode)">
            Extracts the object structures from the <code>DEFINED_PREDICATE</code> node
            of the syntaxic tree and implements the semantic check.
            
            @param node the <code>DEFINED_PREDICATE</code> node.
            @return the actionCtx structure built.
            @throws ParserException if an error occurs while parsing.
        </member>
        <member name="M:PDDLParser.Parser.Parser.defined_function(PDDLParser.Parser.Lexer.SimpleNode)">
            Extracts the object structures from the <code>DEFINED_FUNCTION</code> node
            of the syntaxic tree and implements the semantic check.
            
            @param node the <code>DEFINED_FUNCTION</code> node.
            @return the actionCtx structure built.
            @throws ParserException if an error occurs while parsing.
        </member>
        <member name="M:PDDLParser.Parser.Parser.local_vars(PDDLParser.Parser.Lexer.SimpleNode)">
            Extracts the object structures from the <code>LOCAL_VARS</code> node
            of the syntaxic tree and implements the semantic check.
            
            @param node the <code>LOCAL_VARS</code> node.
            @return the actionCtx structure built.
            @throws ParserException if an error occurs while parsing.
        </member>
        <member name="M:PDDLParser.Parser.Parser.local_vars_typed_list(PDDLParser.Parser.Lexer.SimpleNode)">
            Extracts the object structures from the <code>TYPED_LIST</code> node of
            the syntaxic tree and implements the semantic check.
            
            @param node the <code>TYPED_LIST</code> node.
            @param tl the typed list of constants already built.
            @return the typed list structure built.
            @throws ParserException if an error occurs while parsing.
        </member>
        <member name="M:PDDLParser.Parser.Parser.action_def(PDDLParser.Parser.Lexer.SimpleNode)">
            Extracts the object structures from the <code>ACTION_DEF</code> node
            of the syntaxic tree and implements the semantic check.
            
            @param node the <code>ACTION_DEF</code> node.
            @return the actionCtx structure built.
            @throws ParserException if an error occurs while parsing.
        </member>
        <member name="M:PDDLParser.Parser.Parser.action_def_body(PDDLParser.Parser.Lexer.SimpleNode,PDDLParser.Action.Action)">
            Extracts the object structures from the <code>ACTION_DEF_BODY</code> node
            of the syntaxic tree and implements the semantic check.
            
            @param node the <code>ACTION_DEF_BODY</code> node.
            @param action the actionCtx to initialize.
            @throws ParserException if an error occurs while parsing.
        </member>
        <member name="M:PDDLParser.Parser.Parser.effect(PDDLParser.Parser.Lexer.SimpleNode)">
            Extracts the object structures from the <code>EFFECT</code> node
            of the syntaxic tree and implements the semantic check.
            
            @param node the <code>EFFECT</code> node.
            @return the effect expression built.
            @throws ParserException if an error occurs while parsing.
        </member>
        <member name="M:PDDLParser.Parser.Parser.c_effect(PDDLParser.Parser.Lexer.SimpleNode)">
            Extracts the object structures from the <code>EFFECT</code> node
            of the syntaxic tree and implements the semantic check.
            
            @param node the <code>EFFECT</code> node.
            @return the effect expression built.
            @throws ParserException if an error occurs while parsing.
        </member>
        <member name="M:PDDLParser.Parser.Parser.when_con_effect(PDDLParser.Parser.Lexer.SimpleNode)">
            Extracts the object structures from the <code>WHEN_CON_EFFECT</code>
            node of the syntaxic tree and implements the semantic check.
            
            @param node the <code>WHEN_CON_EFFECT</code> node.
            @return the when effect expression built.
            @throws ParserException if an error occurs while parsing.
        </member>
        <member name="M:PDDLParser.Parser.Parser.cond_effect(PDDLParser.Parser.Lexer.SimpleNode)">
            Extracts the object structures from the <code>WHEN_C_EFFECT</code>
            node of the syntaxic tree and implements the semantic check.
            
            @param node the <code>WHEN_C_EFFECT</code> node.
            @return the when effect expression built.
            @throws ParserException if an error occurs while parsing.
        </member>
        <member name="M:PDDLParser.Parser.Parser.and_p_effect(PDDLParser.Parser.Lexer.SimpleNode)">
            Extracts the object structures from the <code>AND_P_EFFECT</code>
            node of the syntaxic tree and implements the semantic check.
            
            @param node the <code>AND_P_EFFECT</code> node.
            @return the conjuncive propositional effect expression built.
            @throws ParserException if an error occurs while parsing.
        </member>
        <member name="M:PDDLParser.Parser.Parser.p_effect(PDDLParser.Parser.Lexer.SimpleNode)">
            Extracts the object structures from the <code>P_EFFECT</code>
            node of the syntaxic tree and implements the semantic check.
            
            @param node the <code>P_EFFECT</code> node.
            @return the propositional effect expression built.
            @throws ParserException if an error occurs while parsing.
        </member>
        <member name="M:PDDLParser.Parser.Parser.forall_effect(PDDLParser.Parser.Lexer.SimpleNode)">
            Extracts the object structures from the <code>FORALL_C_EFFECT</code>
            node of the syntaxic tree and implements the semantic check.
            
            @param node the <code>FORALL_C_EFFECT</code> node.
            @return the universal effect expression built.
            @throws ParserException if an error occurs while parsing.
        </member>
        <member name="M:PDDLParser.Parser.Parser.and_c_effect(PDDLParser.Parser.Lexer.SimpleNode)">
            Extracts the object structures from the <code>AND_C_EFFECT</code>
            node of the syntaxic tree and implements the semantic check.
            
            @param node the <code>AND_C_EFFECT</code> node.
            @return the conjuncive effect expression built.
            @throws ParserException if an error occurs while parsing.
        </member>
        <member name="M:PDDLParser.Parser.Parser.pre_gd(PDDLParser.Parser.Lexer.SimpleNode,System.Collections.Generic.List{PDDLParser.Exp.IConditionPrefExp}@)">
            Extracts the object structures from the <code>PRE_GD</code> node
            of the syntaxic tree and implements the semantic check.
            
            @param node the <code>PRE_GD</code> node.
            @return the precondition goal description built
            @throws ParserException if an error occurs while parsing.
        </member>
        <member name="M:PDDLParser.Parser.Parser.forall_pre_gd(PDDLParser.Parser.Lexer.SimpleNode,System.Collections.Generic.List{PDDLParser.Exp.IConditionPrefExp}@)">
            Extracts the object structures from the <code>FORALL_PRE_GD</code>
            node of the syntaxic tree and implements the semantic check.
            
            @param node the <code>FORALL_PRE_GD</code> node.
            @return the universal precondition goal description structure built.
            @throws ParserException if an error occurs while parsing.
        </member>
        <member name="M:PDDLParser.Parser.Parser.and_pre_gd(PDDLParser.Parser.Lexer.SimpleNode,System.Collections.Generic.List{PDDLParser.Exp.IConditionPrefExp}@)">
            Extracts the object structures from the <code>AND_PRE_GD</code>
            node of the syntaxic tree and implements the semantic check.
            
            @param node the <code>AND_PRE_GD</code> node.
            @return the conjuncive precondition goal description structure built.
            @throws ParserException if an error occurs while parsing.
        </member>
        <member name="M:PDDLParser.Parser.Parser.pref_gd(PDDLParser.Parser.Lexer.SimpleNode,System.Collections.Generic.List{PDDLParser.Exp.IConditionPrefExp}@)">
            Extracts the object structures from the <code>PREF_GD</code> node
            of the syntaxic tree and implements the semantic check.
            
            @param node the <code>PREF_GD</code> node.
            @return the precondition goal description built
            @throws ParserException if an error occurs while parsing.
        </member>
        <member name="M:PDDLParser.Parser.Parser.named_pref_gd(PDDLParser.Parser.Lexer.SimpleNode,System.Collections.Generic.List{PDDLParser.Exp.IConditionPrefExp}@)">
            Extracts the object structures from the <code>PREF_GD</code> node
            of the syntaxic tree and implements the semantic check.
            
            @param node the <code>PREF_GD</code> node.
            @return the precondition goal description built
            @throws ParserException if an error occurs while parsing.
        </member>
        <member name="M:PDDLParser.Parser.Parser.action_name(PDDLParser.Parser.Lexer.SimpleNode)">
            Extracts the object structures from the <code>ACTION_NAME</code> node
            of the syntaxic tree and implements the semantic check.
            
            @param node the <code>ACTION_NAME</code> node.
            @return the actionCtx name structure built.
            @throws ParserException if an error occurs while parsing.
        </member>
        <member name="M:PDDLParser.Parser.Parser.requireDef(PDDLParser.Parser.Lexer.SimpleNode)">
            Extracts the object structures from the <code>REQUIRE_DEF</code> node
            of the syntaxic tree and implements the semantic check.
            
            @param node the <code>REQUIRE_DEF</code> node.
            @return the require definition structure built.
            @throws ParserException if an error occurs while parsing.
        </member>
        <member name="M:PDDLParser.Parser.Parser.types_def(PDDLParser.Parser.Lexer.SimpleNode)">
            Extracts the object structures from the <code>TYPE_DEF</code> node of
            the syntaxic tree and implements the semantic check.
            
            @param node the <code>TYPE_DEF</code> node.
            @return the type definition structure built.
            @throws ParserException if an error occurs while parsing.
        </member>
        <member name="M:PDDLParser.Parser.Parser.type_typed_list(PDDLParser.Parser.Lexer.SimpleNode,System.Collections.Generic.IDictionary{System.String,System.Collections.Generic.HashSet{System.String}})">
            Extracts the object structures from the <code>TYPED_LIST</code> node of
            the syntaxic tree and implements the semantic check.
            
            @param node the <code>TYPED_LIST</code> node.
            @param tl the types list of primitive type already built.
            @return the typed list structure built.
            @throws ParserException if an error occurs while parsing.
        </member>
        <member name="M:PDDLParser.Parser.Parser.var_typed_list(PDDLParser.Parser.Lexer.SimpleNode,System.Collections.Generic.Dictionary{System.String,PDDLParser.Exp.Term.ObjectParameterVariable},System.Boolean)">
            Extracts the object structures from the <code>TYPED_LIST</code> node of
            the syntaxic tree and implements the semantic check.
            
            @param node the <code>TYPED_LIST</code> node.
            @param tl the typed list of variables already built.
            @return the typed list structure built.
            @throws ParserException if an error occurs while parsing.
        </member>
        <member name="M:PDDLParser.Parser.Parser.constant_typed_list(PDDLParser.Parser.Lexer.SimpleNode,System.Collections.Generic.IDictionary{System.String,PDDLParser.Exp.Term.Constant})">
            Extracts the object structures from the <code>TYPED_LIST</code> node of
            the syntaxic tree and implements the semantic check.
            
            @param node the <code>TYPED_LIST</code> node.
            @param tl the typed list of constants already built.
            @return the typed list structure built.
            @throws ParserException if an error occurs while parsing.
        </member>
        <member name="M:PDDLParser.Parser.Parser.primitive_type(PDDLParser.Parser.Lexer.SimpleNode)">
            Extracts the object structures from the <code>PRIMITIVE_TYPE</code>
            node of the syntaxic tree and implements the semantic check.
            
            @param node the <code>PRIMITIVE_TYPE</code> node.
            @return the primitive type structure built.
            @throws ParserException if an error occurs while parsing.
        </member>
        <member name="M:PDDLParser.Parser.Parser.type(PDDLParser.Parser.Lexer.SimpleNode)">
            Extracts the object structures from the <code>TYPE</code> node of the
            syntaxic tree and implements the semantic check.
            
            @param node the <code>TYPE</code> node.
            @return the type structure built.
            @throws ParserException if an error occurs while parsing.
        </member>
        <member name="M:PDDLParser.Parser.Parser.types(PDDLParser.Parser.Lexer.SimpleNode)">
            Extracts the object structures from the <code>TYPE</code> node of the
            syntaxic tree and implements the semantic check.
            
            @param node the <code>TYPE</code> node.
            @return the type structure built.
            @throws ParserException if an error occurs while parsing.
        </member>
        <member name="M:PDDLParser.Parser.Parser.constants_def(PDDLParser.Parser.Lexer.SimpleNode)">
            Extracts the object structures from the <code>CONSTANTS_DEF</code> node
            of the syntaxic tree and implements the semantic check.
            
            @param node the <code>CONSTANTS_DEF</code> node.
            @return the constants definition structure built.
            @throws ParserException if an error occurs while parsing.
        </member>
        <member name="M:PDDLParser.Parser.Parser.constant(PDDLParser.Parser.Lexer.SimpleNode)">
            Extracts the object structures from the <code>CONSTANT</code> node of
            the syntaxic tree and implements the semantic check.
            
            @param node the <code>CONSTANT</code> node.
            @return the constant structure built.
            @throws ParserException if an error occurs while parsing.
        </member>
        <member name="M:PDDLParser.Parser.Parser.predicates_def(PDDLParser.Parser.Lexer.SimpleNode)">
            Extracts the object structures from the <code>PREDICATES_DEF</code>
            node of the syntaxic tree and implements the semantic check.
            
            @param node the <code>PREDICATES_DEF</code> node.
            @return the predicates definition structure built.
            @throws ParserException if an error occurs while parsing.
        </member>
        <member name="M:PDDLParser.Parser.Parser.atomic_formula_skeleton(PDDLParser.Parser.Lexer.SimpleNode,System.Boolean)">
            Extracts the object structures from the <code>PREDICATES_DEF</code>
            node of the syntaxic tree and implements the semantic check.
            
            @param node the <code>PREDICATES_DEF</code> node.
            @return the predicates definition structure built.
            @throws ParserException if an error occurs while parsing.
        </member>
        <member name="M:PDDLParser.Parser.Parser.predicate(PDDLParser.Parser.Lexer.SimpleNode)">
            Extracts the object structures from the <code>PREDICATE</code> node of
            the syntaxic tree and implements the semantic check.
            
            @param node the <code>PREDICATE</code> node.
            @return the predicate structure built.
            @throws ParserException if an error occurs while parsing.
        </member>
        <member name="M:PDDLParser.Parser.Parser.functions_def(PDDLParser.Parser.Lexer.SimpleNode)">
            Extracts the object structures from the <code>FUNCTIONS_DEF</code> node
            of the syntaxic tree and implements the semantic check.
            
            @param node the <code>FUNCTIONS_DEF</code> node.
            @return the functions definition structure built.
            @throws ParserException if an error occurs while parsing.
        </member>
        <member name="M:PDDLParser.Parser.Parser.atomic_function_skeleton_typed_list(PDDLParser.Parser.Lexer.SimpleNode)">
            Extracts the object structures from the <code>TYPED_LIST</code> node of
            the syntaxic tree and implements the semantic check.
            
            @param node the <code>TYPED_LIST</code> node.
            @param tl the typed list of constants already built.
            @return the typed list structure built.
            @throws ParserException if an error occurs while parsing.
        </member>
        <member name="M:PDDLParser.Parser.Parser.typed_function(PDDLParser.Parser.Lexer.SimpleNode,System.Boolean)">
            Extracts the object structures from the <code>TYPED_FUNCTION</code> node of
            the syntaxic tree and implements the semantic check.
            
            @param node the <code>TYPED_FUNCTION</code> node.
            @param tl the typed list of constants already built.
            @return the typed list structure built.
            @throws ParserException if an error occurs while parsing.
        </member>
        <member name="M:PDDLParser.Parser.Parser.function_type(PDDLParser.Parser.Lexer.SimpleNode)">
            Extracts the object structures from the <code>FUNCTION_TYPE</code> node of the
            syntaxic tree and implements the semantic check.
            
            @param node the <code>FUNCTION_TYPE</code> node.
            @return the type structure built.
            @throws ParserException if an error occurs while parsing.
        </member>
        <member name="M:PDDLParser.Parser.Parser.atomic_function_skeleton(PDDLParser.Parser.Lexer.SimpleNode,System.Boolean)">
            Extracts the object structures from the
            <code>ATOMIC_FUNCTION_SKELETON</code> node of the syntaxic tree and
            implements the semantic check.
            
            @param node the <code>ATOMIC_FUNCTION_SKELETON</code> node.
            @return the atomic function skeleton structure built.
            @throws ParserException if an error occurs while parsing.
        </member>
        <member name="M:PDDLParser.Parser.Parser.functor(PDDLParser.Parser.Lexer.SimpleNode)">
            Extracts the object structures from the <code>FUNCTOR</code> node of
            the syntaxic tree and implements the semantic check.
            
            @param node the <code>FUNCTOR</code> node.
            @return the function structure built.
            @throws ParserException if an error occurs while parsing.
        </member>
        <member name="M:PDDLParser.Parser.Parser.def_variable(PDDLParser.Parser.Lexer.SimpleNode,System.Boolean)">
            Extracts the object structures from the <code>TERM</code> node of the
            syntaxic tree and implements the semantic check.
            
            @param node the <code>TERM</code> node.
            @return the exp structure built.
            @throws ParserException if an error occurs while parsing.
        </member>
        <member name="M:PDDLParser.Parser.Parser.def_local_variable(PDDLParser.Parser.Lexer.SimpleNode)">
            Extracts the object structures from the <code>TERM</code> node of the
            syntaxic tree and implements the semantic check.
            
            @param node the <code>TERM</code> node.
            @return the exp structure built.
            @throws ParserException if an error occurs while parsing.
        </member>
        <member name="M:PDDLParser.Parser.Parser.variable(PDDLParser.Parser.Lexer.SimpleNode)">
            Extracts the object structures from the <code>VARIABLE</code> node of the
            syntaxic tree and implements the semantic check.
            
            @param node the <code>VARIABLE</code> node.
            @return the exp structure built.
            @throws ParserException if an error occurs while parsing.
        </member>
        <member name="M:PDDLParser.Parser.Parser.local_function_name(PDDLParser.Parser.Lexer.SimpleNode)">
            Returns the local variable corresponding to the function name
            referenced in the specified node.
            
            @param node the local variable corresponding to the function name
            @return the exp structure built.
        </member>
        <member name="M:PDDLParser.Parser.Parser.local_variable(PDDLParser.Parser.Lexer.SimpleNode)">
            Returns the local variable referenced in the specified node.
            
            @param node the local variable node
            @return the exp structure built.
        </member>
        <member name="M:PDDLParser.Parser.Parser.object_variable(PDDLParser.Parser.Lexer.SimpleNode)">
            Returns the object variable referenced in the specified node.
            
            @param node the object variable node
            @return the exp structure built.
        </member>
        <member name="M:PDDLParser.Parser.Parser.object_local_variable(PDDLParser.Parser.Lexer.SimpleNode)">
            Returns the object local variable referenced in the specified node.
            
            @param node the object local variable node
            @return the exp structure built.
        </member>
        <member name="M:PDDLParser.Parser.Parser.object_function_or_variable(PDDLParser.Parser.Lexer.SimpleNode)">
            Returns the object local variable referenced in the specified node.
            
            @param node the object local variable node
            @return the exp structure built.
        </member>
        <member name="M:PDDLParser.Parser.Parser.numeric_variable(PDDLParser.Parser.Lexer.SimpleNode)">
            Returns the numeric variable referenced in the specified node.
            
            @param node the numeric variable node
            @return the exp structure built.
        </member>
        <member name="M:PDDLParser.Parser.Parser.numeric_local_variable(PDDLParser.Parser.Lexer.SimpleNode)">
            Returns the object local variable referenced in the specified node.
            
            @param node the object local variable node
            @return the exp structure built.
        </member>
        <member name="M:PDDLParser.Parser.Parser.numeric_function_or_variable(PDDLParser.Parser.Lexer.SimpleNode)">
            Returns the numeric local variable referenced in the specified node.
            
            @param node the numeric local variable node
            @return the exp structure built.
        </member>
        <member name="M:PDDLParser.Parser.Parser.boolean_variable(PDDLParser.Parser.Lexer.SimpleNode)">
            Returns the boolean variable referenced in the specified node.
            
            @param node the boolean variable node
            @return the exp structure built.
        </member>
        <member name="M:PDDLParser.Parser.Parser.boolean_local_variable(PDDLParser.Parser.Lexer.SimpleNode)">
            Returns the boolean local variable referenced in the specified node.
            
            @param node the boolean local variable node
            @return the exp structure built.
        </member>
        <member name="M:PDDLParser.Parser.Parser.boolean_function_or_variable(PDDLParser.Parser.Lexer.SimpleNode)">
            Returns the boolean local variable referenced in the specified node.
            
            @param node the boolean local variable node
            @return the exp structure built.
        </member>
        <member name="M:PDDLParser.Parser.Parser.constraints(PDDLParser.Parser.Lexer.SimpleNode)">
            Extracts the object structures from the <code>CONSTRAINTS</code> node
            of the syntaxic tree and implements the semantic check.
            
            @param node the <code>CONSTRAINTS</code> node.
            @return the constraints definition structure built.
            @throws ParserException if an error occurs while parsing.
        </member>
        <member name="M:PDDLParser.Parser.Parser.pref_con_gd(PDDLParser.Parser.Lexer.SimpleNode,System.Collections.Generic.List{PDDLParser.Exp.IConstraintPrefExp}@)">
            Extracts the object structures from the <code>PREF_CON_GD</code> node
            of the syntaxic tree and implements the semantic check.
            
            @param node the <code>PREF_CON_GD</code> node.
            @return the conditional goal description preference structure built.
            @throws ParserException if an error occurs while parsing.
        </member>
        <member name="M:PDDLParser.Parser.Parser.and_pref_con_gd(PDDLParser.Parser.Lexer.SimpleNode,System.Collections.Generic.List{PDDLParser.Exp.IConstraintPrefExp}@)">
            Extracts the object structures from the <code>AND_PREF_CON_GD</code>
            node of the syntaxic tree and implements the semantic check.
            
            @param node the <code>AND_PREF_CON_GD</code> node.
            @return the and condition goal description preference structure built.
            @throws ParserException if an error occurs while parsing.
        </member>
        <member name="M:PDDLParser.Parser.Parser.forall_pref_con_gd(PDDLParser.Parser.Lexer.SimpleNode,System.Collections.Generic.List{PDDLParser.Exp.IConstraintPrefExp}@)">
            Extracts the object structures from the <code>FORALL_PREF_CON_GD</code>
            node of the syntaxic tree and implements the semantic check.
            
            @param node the <code>FORALL_PREF_CON_GD</code> node.
            @return the forall condition goal description preference structure built.
            @throws ParserException if an error occurs while parsing.
        </member>
        <member name="M:PDDLParser.Parser.Parser.named_pref_con_gd(PDDLParser.Parser.Lexer.SimpleNode,System.Collections.Generic.List{PDDLParser.Exp.IConstraintPrefExp}@)">
            Extracts the object structures from the <code>PREFERENCE</code> node of
            the syntaxic tree and implements the semantic check.
            
            @param node the <code>PREFERENCE</code> node.
            @return the preference structure built.
            @throws ParserException if an error occurs while parsing.
        </member>
        <member name="M:PDDLParser.Parser.Parser.pref_name(PDDLParser.Parser.Lexer.SimpleNode)">
            Extracts the object structures from the <code>PREF_NAME</code> node of
            the syntaxic tree and implements the semantic check.
            
            @param node the <code>PREF_NAME</code> node.
            @return the preference image structure built.
            @throws ParserException if an error occurs while parsing.
        </member>
        <member name="M:PDDLParser.Parser.Parser.con_gd(PDDLParser.Parser.Lexer.SimpleNode)">
            Extracts the object structures from the <code>CON_GD</code> node of the
            syntaxic tree and implements the semantic check.
            
            @param node the <code>CON_GD</code> node.
            @return the conditional goal description structure built.
            @throws ParserException if an error occurs while parsing.
        </member>
        <member name="M:PDDLParser.Parser.Parser.hold_after_con_gd(PDDLParser.Parser.Lexer.SimpleNode)">
            Extracts the object structures from the <code>HOLD_AFTER</code> node of
            the syntaxic tree and implements the semantic check.
            
            @param node the <code>HOLD_AFTER</code> node.
            @return the "hold after" conditional goal description structure built.
            @throws ParserException if an error occurs while parsing.
        </member>
        <member name="M:PDDLParser.Parser.Parser.hold_during_con_gd(PDDLParser.Parser.Lexer.SimpleNode)">
            Extracts the object structures from the <code>HOLD_DURING</code> node
            of the syntaxic tree and implements the semantic check.
            
            @param node the <code>HOLD_DURING</code> node.
            @return the "hold during" conditional goal description structure built.
            @throws ParserException if an error occurs while parsing.
        </member>
        <member name="M:PDDLParser.Parser.Parser.always_within_con_gd(PDDLParser.Parser.Lexer.SimpleNode)">
            Extracts the object structures from the <code>ALWAYS_WITHIN</code> node
            of the syntaxic tree and implements the semantic check.
            
            @param node the <code>ALWAYS_WITHIN</code> node.
            @return the "always within" conditional goal description structure built.
            @throws ParserException if an error occurs while parsing.
        </member>
        <member name="M:PDDLParser.Parser.Parser.sometime_before_con_gd(PDDLParser.Parser.Lexer.SimpleNode)">
            Extracts the object structures from the <code>SOMETIME_BEFORE</code>
            node of the syntaxic tree and implements the semantic check.
            
            @param node the <code>SOMETIME_BEFORE</code> node.
            @return the "sometime before" conditional goal description structure
                    built.
            @throws ParserException if an error occurs while parsing.
        </member>
        <member name="M:PDDLParser.Parser.Parser.sometime_after_con_gd(PDDLParser.Parser.Lexer.SimpleNode)">
            Extracts the object structures from the <code>SOMETIME_AFTER</code>
            node of the syntaxic tree and implements the semantic check.
            
            @param node the <code>SOMETIME_AFTER</code> node.
            @return the "sometime after" conditional goal description structure
                    built.
            @throws ParserException if an error occurs while parsing.
        </member>
        <member name="M:PDDLParser.Parser.Parser.at_most_once_con_gd(PDDLParser.Parser.Lexer.SimpleNode)">
            Extracts the object structures from the <code>AT_MOST_ONCE</code> node
            of the syntaxic tree and implements the semantic check.
            
            @param node the <code>AT_MOST_ONCE</code> node.
            @return the "at most once" conditional goal description structure built.
            @throws ParserException if an error occurs while parsing.
        </member>
        <member name="M:PDDLParser.Parser.Parser.within_con_gd(PDDLParser.Parser.Lexer.SimpleNode)">
            Extracts the object structures from the <code>WITHIN</code> node of the
            syntaxic tree and implements the semantic check.
            
            @param node the <code>WITHIN</code> node.
            @return the "within" conditional goal description structure built.
            @throws ParserException if an error occurs while parsing.
        </member>
        <member name="M:PDDLParser.Parser.Parser.sometime_con_gd(PDDLParser.Parser.Lexer.SimpleNode)">
            Extracts the object structures from the <code>SOMETIME</code> node of
            the syntaxic tree and implements the semantic check.
            
            @param node the <code>SOMETIME</code> node.
            @return the "sometime" conditional goal description structure built.
            @throws ParserException if an error occurs while parsing.
        </member>
        <member name="M:PDDLParser.Parser.Parser.always_con_gd(PDDLParser.Parser.Lexer.SimpleNode)">
            Extracts the object structures from the <code>ALWAYS</code> node of the
            syntaxic tree and implements the semantic check.
            
            @param node the <code>ALWAYS</code> node.
            @return the "always" conditional goal description structure built.
            @throws ParserException if an error occurs while parsing.
        </member>
        <member name="M:PDDLParser.Parser.Parser.next_con_gd(PDDLParser.Parser.Lexer.SimpleNode)">
            Extracts the object structures from the <code>NEXT</code> node of the
            syntaxic tree and implements the semantic check.
            
            @param node the <code>NEXT</code> node.
            @return the "next" conditional goal description structure built.
            @throws ParserException if an error occurs while parsing.
        </member>
        <member name="M:PDDLParser.Parser.Parser.weak_until_con_gd(PDDLParser.Parser.Lexer.SimpleNode)">
            Extracts the object structures from the <code>WEAK_UNTIL</code>
            node of the syntaxic tree and implements the semantic check.
            
            @param node the <code>WEAK_UNTIL</code> node.
            @return the "weak until" conditional goal description structure
                    built.
            @throws ParserException if an error occurs while parsing.
        </member>
        <member name="M:PDDLParser.Parser.Parser.until_con_gd(PDDLParser.Parser.Lexer.SimpleNode)">
            Extracts the object structures from the <code>UNTIL</code>
            node of the syntaxic tree and implements the semantic check.
            
            @param node the <code>UNTIL</code> node.
            @return the "until" conditional goal description structure
                    built.
            @throws ParserException if an error occurs while parsing.
        </member>
        <member name="M:PDDLParser.Parser.Parser.and_con_gd(PDDLParser.Parser.Lexer.SimpleNode)">
            Extracts the object structures from the <code>AND_CON_GD</code> node of
            the syntaxic tree and implements the semantic check.
            
            @param node the <code>AND_CON_GD</code> node.
            @return the and conditional goal description structure built.
            @throws ParserException if an error occurs while parsing.
        </member>
        <member name="M:PDDLParser.Parser.Parser.or_con_gd(PDDLParser.Parser.Lexer.SimpleNode)">
            Extracts the object structures from the <code>OR_CON_GD</code> node of
            the syntaxic tree and implements the semantic check.
            
            @param node the <code>OR_CON_GD</code> node.
            @return the and conditional goal description structure built.
            @throws ParserException if an error occurs while parsing.
        </member>
        <member name="M:PDDLParser.Parser.Parser.xor_con_gd(PDDLParser.Parser.Lexer.SimpleNode)">
            Extracts the object structures from the <code>XOR_CON_GD</code> node of
            the syntaxic tree and implements the semantic check.
            
            @param node the <code>XOR_CON_GD</code> node.
            @return the and conditional goal description structure built.
            @throws ParserException if an error occurs while parsing.
        </member>
        <member name="M:PDDLParser.Parser.Parser.not_con_gd(PDDLParser.Parser.Lexer.SimpleNode)">
            Extracts the object structures from the <code>NOT_CON_GD</code> node of the
            syntaxic tree and implements the semantic check.
            
            @param node the <code>NOT_CON_GD</code> node.
            @return the negative goal description structure built.
            @throws ParserException if an error occurs while parsing.
        </member>
        <member name="M:PDDLParser.Parser.Parser.imply_con_gd(PDDLParser.Parser.Lexer.SimpleNode)">
            Extracts the object structures from the <code>IMPLY_CON_GD</code> node of
            the syntaxic tree and implements the semantic check.
            
            @param node the <code>IMPLY_CON_GD</code> node.
            @return the implicative goal description structure built.
            @throws ParserException if an error occurs while parsing.
        </member>
        <member name="M:PDDLParser.Parser.Parser.if_then_else_con_gd(PDDLParser.Parser.Lexer.SimpleNode)">
            Extracts the object structures from the <code>IF_THEN_ELSE_CON_GD</code> node of
            the syntaxic tree and implements the semantic check.
            
            @param node the <code>IF_THEN_ELSE_CON_GD</code> node.
            @return the implicative goal description structure built.
            @throws ParserException if an error occurs while parsing.
        </member>
        <member name="M:PDDLParser.Parser.Parser.exists_con_gd(PDDLParser.Parser.Lexer.SimpleNode)">
            Extracts the object structures from the <code>EXISTS_CON_GD</code> node of
            the syntaxic tree and implements the semantic check.
            
            @param node the <code>EXISTS_CON_GD</code> node.
            @return the existential goal description structure built.
            @throws ParserException if an error occurs while parsing.
        </member>
        <member name="M:PDDLParser.Parser.Parser.exists_unique_con_gd(PDDLParser.Parser.Lexer.SimpleNode)">
            Extracts the object structures from the <code>EXISTS_UNIQUE_CON_GD</code> node of
            the syntaxic tree and implements the semantic check.
            
            @param node the <code>EXISTS_UNIQUE_CON_GD</code> node.
            @return the existential goal description structure built.
            @throws ParserException if an error occurs while parsing.
        </member>
        <member name="M:PDDLParser.Parser.Parser.forall_con_gd(PDDLParser.Parser.Lexer.SimpleNode)">
            Extracts the object structures from the <code>FORALL_CON_GD</code> node
            of the syntaxic tree and implements the semantic check.
            
            @param node the <code>FORALL_CON_GD</code> node.
            @return the universal conditional goal description structure built.
            @throws ParserException if an error occurs while parsing.
        </member>
        <member name="M:PDDLParser.Parser.Parser.at_end_con_gd(PDDLParser.Parser.Lexer.SimpleNode)">
            Extracts the object structures from the <code>AT_END_CON_GD</code> node
            of the syntaxic tree and implements the semantic check.
            
            @param node the <code>AT_END_CON_GD</code> node.
            @return the at end conditional goal description structure built.
            @throws ParserException if an error occurs while parsing.
        </member>
        <member name="M:PDDLParser.Parser.Parser.sub_con_gd(PDDLParser.Parser.Lexer.SimpleNode)">
            Extracts the object structures from the <code>SUB_CON_GD</code> node of the
            syntaxic tree and implements the semantic check.
            
            @param node the <code>SUB_CON_GD</code> node.
            @return the conditional goal description structure built.
            @throws ParserException if an error occurs while parsing.
        </member>
        <member name="M:PDDLParser.Parser.Parser.and_sub_con_gd(PDDLParser.Parser.Lexer.SimpleNode)">
            Extracts the object structures from the <code>AND_SUB_CON_GD</code> node of
            the syntaxic tree and implements the semantic check.
            
            @param node the <code>AND_SUB_CON_GD</code> node.
            @return the and conditional goal description structure built.
            @throws ParserException if an error occurs while parsing.
        </member>
        <member name="M:PDDLParser.Parser.Parser.or_sub_con_gd(PDDLParser.Parser.Lexer.SimpleNode)">
            Extracts the object structures from the <code>OR_SUB_CON_GD</code> node of
            the syntaxic tree and implements the semantic check.
            
            @param node the <code>OR_SUB_CON_GD</code> node.
            @return the and conditional goal description structure built.
            @throws ParserException if an error occurs while parsing.
        </member>
        <member name="M:PDDLParser.Parser.Parser.xor_sub_con_gd(PDDLParser.Parser.Lexer.SimpleNode)">
            Extracts the object structures from the <code>XOR_SUB_CON_GD</code> node of
            the syntaxic tree and implements the semantic check.
            
            @param node the <code>XOR_SUB_CON_GD</code> node.
            @return the and conditional goal description structure built.
            @throws ParserException if an error occurs while parsing.
        </member>
        <member name="M:PDDLParser.Parser.Parser.not_sub_con_gd(PDDLParser.Parser.Lexer.SimpleNode)">
            Extracts the object structures from the <code>NOT_SUB_CON_GD</code> node of the
            syntaxic tree and implements the semantic check.
            
            @param node the <code>NOT_SUB_CON_GD</code> node.
            @return the negative goal description structure built.
            @throws ParserException if an error occurs while parsing.
        </member>
        <member name="M:PDDLParser.Parser.Parser.imply_sub_con_gd(PDDLParser.Parser.Lexer.SimpleNode)">
            Extracts the object structures from the <code>IMPLY_SUB_CON_GD</code> node of
            the syntaxic tree and implements the semantic check.
            
            @param node the <code>IMPLY_SUB_CON_GD</code> node.
            @return the implicative goal description structure built.
            @throws ParserException if an error occurs while parsing.
        </member>
        <member name="M:PDDLParser.Parser.Parser.if_then_else_sub_con_gd(PDDLParser.Parser.Lexer.SimpleNode)">
            Extracts the object structures from the <code>IF_THEN_ELSE_SUB_CON_GD</code> node of
            the syntaxic tree and implements the semantic check.
            
            @param node the <code>IF_THEN_ELSE_SUB_CON_GD</code> node.
            @return the implicative goal description structure built.
            @throws ParserException if an error occurs while parsing.
        </member>
        <member name="M:PDDLParser.Parser.Parser.exists_sub_con_gd(PDDLParser.Parser.Lexer.SimpleNode)">
            Extracts the object structures from the <code>EXISTS_SUB_CON_GD</code> node of
            the syntaxic tree and implements the semantic check.
            
            @param node the <code>EXISTS_SUB_CON_GD</code> node.
            @return the existential goal description structure built.
            @throws ParserException if an error occurs while parsing.
        </member>
        <member name="M:PDDLParser.Parser.Parser.exists_unique_sub_con_gd(PDDLParser.Parser.Lexer.SimpleNode)">
            Extracts the object structures from the <code>EXISTS_UNIQUE_SUB_CON_GD</code> node of
            the syntaxic tree and implements the semantic check.
            
            @param node the <code>EXISTS_UNIQUE_SUB_CON_GD</code> node.
            @return the existential goal description structure built.
            @throws ParserException if an error occurs while parsing.
        </member>
        <member name="M:PDDLParser.Parser.Parser.forall_sub_con_gd(PDDLParser.Parser.Lexer.SimpleNode)">
            Extracts the object structures from the <code>FORALL_SUB_CON_GD</code> node
            of the syntaxic tree and implements the semantic check.
            
            @param node the <code>FORALL_SUB_CON_GD</code> node.
            @return the universal conditional goal description structure built.
            @throws ParserException if an error occurs while parsing.
        </member>
        <member name="M:PDDLParser.Parser.Parser.gd(PDDLParser.Parser.Lexer.SimpleNode)">
            Extracts the object structures from the <code>GD</code> node of the
            syntaxic tree and implements the semantic check.
            
            @param node the <code>GD</code> node.
            @return the goal description structure built.
            @throws ParserException if an error occurs while parsing.
        </member>
        <member name="M:PDDLParser.Parser.Parser.f_comp(PDDLParser.Parser.Lexer.SimpleNode)">
            Extracts the object structures from the <code>FCOMP</code> node of the
            syntaxic tree and implements the semantic check.
            
            @param node the <code>FCOMP</code> node.
            @return the comparaison function structure built.
            @throws ParserException if an error occurs while parsing.
        </member>
        <member name="M:PDDLParser.Parser.Parser.goal_modality(PDDLParser.Parser.Lexer.SimpleNode)">
            Extracts the object structures from the <code>GOAL_MODALITY</code> node of the
            syntaxic tree and implements the semantic check.
            
            @param node the <code>GOAL_MODALITY</code> node.
            @return the comparaison function structure built.
            @throws ParserException if an error occurs while parsing.
        </member>
        <member name="M:PDDLParser.Parser.Parser.assign_local_var(PDDLParser.Parser.Lexer.SimpleNode)">
            Extracts the object structures from the <code>ASSIGN_LOCAL_VAR</code> node of the
            syntaxic tree and implements the semantic check.
            
            @param node the <code>ASSIGN_LOCAL_VAR</code> node.
            @return the comparaison function structure built.
            @throws ParserException if an error occurs while parsing.
        </member>
        <member name="M:PDDLParser.Parser.Parser.function_or_variable(PDDLParser.Parser.Lexer.SimpleNode)">
            Extracts the object structures from the <code>FUNCTION_OR_VARIABLE</code> node of the
            syntaxic tree and implements the semantic check.
            
            @param node the <code>FUNCTION_OR_VARIABLE</code> node.
            @return the comparaison function structure built.
            @throws ParserException if an error occurs while parsing.
        </member>
        <member name="M:PDDLParser.Parser.Parser.local_value(PDDLParser.Parser.Lexer.SimpleNode)">
            Extracts the object structures from the <code>LOCAL_VALUE</code> node of the
            syntaxic tree and implements the semantic check.
            
            @param node the <code>LOCAL_VALUE</code> node.
            @return the comparaison function structure built.
            @throws ParserException if an error occurs while parsing.
        </member>
        <member name="M:PDDLParser.Parser.Parser.binary_comp(PDDLParser.Parser.Lexer.SimpleNode)">
            Extracts the object structures from the <code>BINARY_COMP</code> node
            of the syntaxic tree and implements the semantic check.
            
            @param node the <code>BINARY_COMP</code> node.
            @return the binray numeric operation structure built.
            @throws ParserException if an error occurs while parsing.
        </member>
        <member name="M:PDDLParser.Parser.Parser.greater_comp(PDDLParser.Parser.Lexer.SimpleNode)">
            Extracts the object structures from the <code>GREATER_COMP</code> node
            of the syntaxic tree and implements the semantic check.
            
            @param node the <code>GREATER_COMP</code> node.
            @return the greater compraison structure built.
            @throws ParserException if an error occurs while parsing.
        </member>
        <member name="M:PDDLParser.Parser.Parser.less_comp(PDDLParser.Parser.Lexer.SimpleNode)">
            Extracts the object structures from the <code>LESS_COMP</code> node of
            the syntaxic tree and implements the semantic check.
            
            @param node the <code>LESS_COMP</code> node.
            @return the less compraison structure built.
            @throws ParserException if an error occurs while parsing.
        </member>
        <member name="M:PDDLParser.Parser.Parser.equal_comp(PDDLParser.Parser.Lexer.SimpleNode)">
            Extracts the object structures from the <code>EQUAL_COMP</code> node of
            the syntaxic tree and implements the semantic check.
            
            @param node the <code>EQUAL_COMP</code> node.
            @return the equal compraison structure built.
            @throws ParserException if an error occurs while parsing.
        </member>
        <member name="M:PDDLParser.Parser.Parser.greater_equal_comp(PDDLParser.Parser.Lexer.SimpleNode)">
            Extracts the object structures from the <code>GREATER_EQUAL_COMP</code>
            node of the syntaxic tree and implements the semantic check.
            
            @param node the <code>GREATER_EQUAL_COMP</code> node.
            @return the greater equal compraison structure built.
            @throws ParserException if an error occurs while parsing.
        </member>
        <member name="M:PDDLParser.Parser.Parser.less_equal_comp(PDDLParser.Parser.Lexer.SimpleNode)">
            Extracts the object structures from the <code>LESS_EQUAL_COMP</code>
            node of the syntaxic tree and implements the semantic check.
            
            @param node the <code>LESS_EQUAL_COMP</code> node.
            @return the less equal compraison structure built.
            @throws ParserException if an error occurs while parsing.
        </member>
        <member name="M:PDDLParser.Parser.Parser.f_exp(PDDLParser.Parser.Lexer.SimpleNode)">
            Extracts the object structures from the <code>F_EXP</code> node of the
            syntaxic tree and implements the semantic check.
            
            @param node the <code>F_EXP</code> node.
            @return the fonction expression structure built.
            @throws ParserException if an error occurs while parsing.
        </member>
        <member name="M:PDDLParser.Parser.Parser.f_head(PDDLParser.Parser.Lexer.SimpleNode)">
            Extracts the object structures from the <code>F_HEAD</code> node of the
            syntaxic tree and implements the semantic check.
            
            @param node the <code>F_HEAD</code> node.
            @return the function head structure built.
            @throws ParserException if an error occurs while parsing.
        </member>
        <member name="M:PDDLParser.Parser.Parser.op(PDDLParser.Parser.Lexer.SimpleNode)">
            Extracts the object structures from the <code>OPERATION</code> node of
            the syntaxic tree and implements the semantic check.
            
            @param node the <code>OPERATION</code> node.
            @return the operation structure built.
            @throws ParserException if an error occurs while parsing.
        </member>
        <member name="M:PDDLParser.Parser.Parser.add_op(PDDLParser.Parser.Lexer.SimpleNode)">
            Extracts the object structures from the <code>ADD_OPERATION</code> node
            of the syntaxic tree and implements the semantic check.
            
            @param node the <code>ADD_OPERATION</code> node.
            @return the add operation structure built.
            @throws ParserException if an error occurs while parsing.
        </member>
        <member name="M:PDDLParser.Parser.Parser.substract_op(PDDLParser.Parser.Lexer.SimpleNode)">
            Extracts the object structures from the <code>SUBSTRACT_OPERATION</code>
            node of the syntaxic tree and implements the semantic check.
            
            @param node the <code>SUBSTRACT_OPERATION</code> node.
            @return the substract operation structure built.
            @throws ParserException if an error occurs while parsing.
        </member>
        <member name="M:PDDLParser.Parser.Parser.multiply_op(PDDLParser.Parser.Lexer.SimpleNode)">
            Extracts the object structures from the <code>MULTIPLY_OPERATION</code>
            node of the syntaxic tree and implements the semantic check.
            
            @param node the <code>MULTIPLY_OPERATION</code> node.
            @return the multiply operation structure built.
            @throws ParserException if an error occurs while parsing.
        </member>
        <member name="M:PDDLParser.Parser.Parser.divide_op(PDDLParser.Parser.Lexer.SimpleNode)">
            Extracts the object structures from the <code>DIVIDE_OPERATION</code>
            node of the syntaxic tree and implements the semantic check.
            
            @param node the <code>DIVIDE_OPERATION</code> node.
            @return the divide operation structure built.
            @throws ParserException if an error occurs while parsing.
        </member>
        <member name="M:PDDLParser.Parser.Parser.mod_op(PDDLParser.Parser.Lexer.SimpleNode)">
            Extracts the object structures from the <code>MOD_OPERATION</code>
            node of the syntaxic tree and implements the semantic check.
            
            @param node the <code>MOD_OPERATION</code> node.
            @return the divide operation structure built.
            @throws ParserException if an error occurs while parsing.
        </member>
        <member name="M:PDDLParser.Parser.Parser.max_op(PDDLParser.Parser.Lexer.SimpleNode)">
            Extracts the object structures from the <code>MAX_OPERATION</code>
            node of the syntaxic tree and implements the semantic check.
            
            @param node the <code>MAX_OPERATION</code> node.
            @return the divide operation structure built.
            @throws ParserException if an error occurs while parsing.
        </member>
        <member name="M:PDDLParser.Parser.Parser.min_op(PDDLParser.Parser.Lexer.SimpleNode)">
            Extracts the object structures from the <code>NARITY_MIN</code>
            node of the syntaxic tree and implements the semantic check.
            
            @param node the <code>NARITY_MIN</code> node.
            @return the divide operation structure built.
            @throws ParserException if an error occurs while parsing.
        </member>
        <member name="M:PDDLParser.Parser.Parser.expt_op(PDDLParser.Parser.Lexer.SimpleNode)">
            Extracts the object structures from the <code>EXPT_OPERATION</code>
            node of the syntaxic tree and implements the semantic check.
            
            @param node the <code>EXPT_OPERATION</code> node.
            @return the divide operation structure built.
            @throws ParserException if an error occurs while parsing.
        </member>
        <member name="M:PDDLParser.Parser.Parser.sqrt_op(PDDLParser.Parser.Lexer.SimpleNode)">
            Extracts the object structures from the <code>SQRT_OPERATION</code>
            node of the syntaxic tree and implements the semantic check.
            
            @param node the <code>SQRT_OPERATION</code> node.
            @return the divide operation structure built.
            @throws ParserException if an error occurs while parsing.
        </member>
        <member name="M:PDDLParser.Parser.Parser.abs_op(PDDLParser.Parser.Lexer.SimpleNode)">
            Extracts the object structures from the <code>ABS_OPERATION</code>
            node of the syntaxic tree and implements the semantic check.
            
            @param node the <code>ABS_OPERATION</code> node.
            @return the divide operation structure built.
            @throws ParserException if an error occurs while parsing.
        </member>
        <member name="M:PDDLParser.Parser.Parser.log_op(PDDLParser.Parser.Lexer.SimpleNode)">
            Extracts the object structures from the <code>LOG_OPERATION</code>
            node of the syntaxic tree and implements the semantic check.
            
            @param node the <code>LOG_OPERATION</code> node.
            @return the divide operation structure built.
            @throws ParserException if an error occurs while parsing.
        </member>
        <member name="M:PDDLParser.Parser.Parser.exp_op(PDDLParser.Parser.Lexer.SimpleNode)">
            Extracts the object structures from the <code>EXP_OPERATION</code>
            node of the syntaxic tree and implements the semantic check.
            
            @param node the <code>EXP_OPERATION</code> node.
            @return the divide operation structure built.
            @throws ParserException if an error occurs while parsing.
        </member>
        <member name="M:PDDLParser.Parser.Parser.round_op(PDDLParser.Parser.Lexer.SimpleNode)">
            Extracts the object structures from the <code>ROUND_OPERATION</code>
            node of the syntaxic tree and implements the semantic check.
            
            @param node the <code>ROUND_OPERATION</code> node.
            @return the divide operation structure built.
            @throws ParserException if an error occurs while parsing.
        </member>
        <member name="M:PDDLParser.Parser.Parser.int_op(PDDLParser.Parser.Lexer.SimpleNode)">
            Extracts the object structures from the <code>INT_OPERATION</code>
            node of the syntaxic tree and implements the semantic check.
            
            @param node the <code>INT_OPERATION</code> node.
            @return the divide operation structure built.
            @throws ParserException if an error occurs while parsing.
        </member>
        <member name="M:PDDLParser.Parser.Parser.floor_op(PDDLParser.Parser.Lexer.SimpleNode)">
            Extracts the object structures from the <code>FLOOR_OPERATION</code>
            node of the syntaxic tree and implements the semantic check.
            
            @param node the <code>FLOOR_OPERATION</code> node.
            @return the divide operation structure built.
            @throws ParserException if an error occurs while parsing.
        </member>
        <member name="M:PDDLParser.Parser.Parser.ceil_op(PDDLParser.Parser.Lexer.SimpleNode)">
            Extracts the object structures from the <code>CEILING_OPERATION</code>
            node of the syntaxic tree and implements the semantic check.
            
            @param node the <code>CEILING_OPERATION</code> node.
            @return the divide operation structure built.
            @throws ParserException if an error occurs while parsing.
        </member>
        <member name="M:PDDLParser.Parser.Parser.number(PDDLParser.Parser.Lexer.SimpleNode)">
            Extracts the object structures from the <code>Number</code> node of the
            syntaxic tree and implements the semantic check.
            
            @param node the <code>Number</code> node.
            @return the number structure built.
            @throws ParserException if an error occurs while parsing.
        </member>
        <member name="M:PDDLParser.Parser.Parser.and_gd(PDDLParser.Parser.Lexer.SimpleNode)">
            Extracts the object structures from the <code>AND_GD</code> node of the
            syntaxic tree and implements the semantic check.
            
            @param node the <code>AND_GD</code> node.
            @return the conjunctive goal description structure built.
            @throws ParserException if an error occurs while parsing.
        </member>
        <member name="M:PDDLParser.Parser.Parser.or_gd(PDDLParser.Parser.Lexer.SimpleNode)">
            Extracts the object structures from the <code>OR_GD</code> node of the
            syntaxic tree and implements the semantic check.
            
            @param node the <code>OR_GD</code> node.
            @return the disjunctive goal description structure built.
            @throws ParserException if an error occurs while parsing.
        </member>
        <member name="M:PDDLParser.Parser.Parser.xor_gd(PDDLParser.Parser.Lexer.SimpleNode)">
            Extracts the object structures from the <code>XOR_GD</code> node of the
            syntaxic tree and implements the semantic check.
            
            @param node the <code>XOR_GD</code> node.
            @return the disjunctive goal description structure built.
            @throws ParserException if an error occurs while parsing.
        </member>
        <member name="M:PDDLParser.Parser.Parser.not_gd(PDDLParser.Parser.Lexer.SimpleNode)">
            Extracts the object structures from the <code>NOT_GD</code> node of the
            syntaxic tree and implements the semantic check.
            
            @param node the <code>NOT_GD</code> node.
            @return the negative goal description structure built.
            @throws ParserException if an error occurs while parsing.
        </member>
        <member name="M:PDDLParser.Parser.Parser.imply_gd(PDDLParser.Parser.Lexer.SimpleNode)">
            Extracts the object structures from the <code>IMPLY_GD</code> node of
            the syntaxic tree and implements the semantic check.
            
            @param node the <code>IMPLY_GD</code> node.
            @return the implicative goal description structure built.
            @throws ParserException if an error occurs while parsing.
        </member>
        <member name="M:PDDLParser.Parser.Parser.if_then_else_gd(PDDLParser.Parser.Lexer.SimpleNode)">
            Extracts the object structures from the <code>IF_THEN_ELSE_GD</code> node of
            the syntaxic tree and implements the semantic check.
            
            @param node the <code>IF_THEN_ELSE_GD</code> node.
            @return the implicative goal description structure built.
            @throws ParserException if an error occurs while parsing.
        </member>
        <member name="M:PDDLParser.Parser.Parser.forall_gd(PDDLParser.Parser.Lexer.SimpleNode)">
            Extracts the object structures from the <code>FORALL_GD</code> node of
            the syntaxic tree and implements the semantic check.
            
            @param node the <code>FORALL_GD</code> node.
            @return the universal goal description structure built.
            @throws ParserException if an error occurs while parsing.
        </member>
        <member name="M:PDDLParser.Parser.Parser.exists_gd(PDDLParser.Parser.Lexer.SimpleNode)">
            Extracts the object structures from the <code>EXISTS_GD</code> node of
            the syntaxic tree and implements the semantic check.
            
            @param node the <code>EXISTS_GD</code> node.
            @return the existential goal description structure built.
            @throws ParserException if an error occurs while parsing.
        </member>
        <member name="M:PDDLParser.Parser.Parser.exists_unique_gd(PDDLParser.Parser.Lexer.SimpleNode)">
            Extracts the object structures from the <code>EXISTS_GD</code> node of
            the syntaxic tree and implements the semantic check.
            
            @param node the <code>EXISTS_GD</code> node.
            @return the existential goal description structure built.
            @throws ParserException if an error occurs while parsing.
        </member>
        <member name="M:PDDLParser.Parser.Parser.literal(PDDLParser.Parser.Lexer.SimpleNode)">
            Extracts the object structures from the <code>LITERAL</code> node of
            the syntaxic tree and implements the semantic check.
            
            @param node the <code>LITERAL</code> node.
            @return the exp literal structure built.
            @throws ParserException if an error occurs while parsing.
        </member>
        <member name="M:PDDLParser.Parser.Parser.ground_literal(PDDLParser.Parser.Lexer.SimpleNode)">
            Extracts the object structures from the <code>LITERAL</code> node of
            the syntaxic tree and implements the semantic check.
            
            @param node the <code>LITERAL</code> node.
            @return the exp literal structure built.
            @throws ParserException if an error occurs while parsing.
        </member>
        <member name="M:PDDLParser.Parser.Parser.not_atomic_formula(PDDLParser.Parser.Lexer.SimpleNode)">
            Extracts the object structures from the <code>LITERAL</code> node of
            the syntaxic tree and implements the semantic check.
            
            @param node the <code>LITERAL</code> node.
            @return the exp literal structure built.
            @throws ParserException if an error occurs while parsing.
        </member>
        <member name="M:PDDLParser.Parser.Parser.not_ground_atomic_formula(PDDLParser.Parser.Lexer.SimpleNode)">
            Extracts the object structures from the <code>LITERAL</code> node of
            the syntaxic tree and implements the semantic check.
            
            @param node the <code>LITERAL</code> node.
            @return the exp literal structure built.
            @throws ParserException if an error occurs while parsing.
        </member>
        <member name="M:PDDLParser.Parser.Parser.atomic_formula(PDDLParser.Parser.Lexer.SimpleNode)">
            Extracts the object structures from the <code>ATOMIC_FORMULA</code>
            node of the syntaxic tree and implements the semantic check.
            
            @param node the <code>ATOMIC_FORMULA</code> node.
            @return the atomic formula structure built.
            @throws ParserException if an error occurs while parsing.
        </member>
        <member name="M:PDDLParser.Parser.Parser.ground_atomic_formula(PDDLParser.Parser.Lexer.SimpleNode)">
            Extracts the object structures from the <code>ATOMIC_FORMULA</code>
            node of the syntaxic tree and implements the semantic check.
            
            @param node the <code>ATOMIC_FORMULA</code> node.
            @return the atomic formula structure built.
            @throws ParserException if an error occurs while parsing.
        </member>
        <member name="M:PDDLParser.Parser.Parser.term(PDDLParser.Parser.Lexer.SimpleNode)">
            Extracts the object structures from the <code>TERM</code> node of the
            syntaxic tree and implements the semantic check.
            
            @param node the <code>TERM</code> node.
            @return the exp structure built.
            @throws ParserException if an error occurs while parsing.
        </member>
        <member name="T:PDDLParser.Parser.Parser.lexerFunctDelegate">
            <summary>
            A delegate used to provide the right lexer function to parse the wanted expression.
            </summary>
            <param name="lexer">The lexer used to parse the expression.</param>
        </member>
        <member name="T:PDDLParser.Parser.Parser.parserFunctDelegate`1">
            <summary>
            A delegate used to provide the right parser function to parse the wanted expression
            from the node issued by the lexer.
            </summary>
            <typeparam name="T">The type of the returned expression.</typeparam>
            <param name="parser">The parser used to parse the expression from the lexer's node.</param>
            <param name="node">The lexer's node.</param>
            <returns>The parsed expression.</returns>
        </member>
        <member name="T:PDDLParser.Exp.Numeric.TLPlan.NArityModulo">
            <summary>
            This class implements a n-ary modulo function.
            If only one argument is present, then the result is that argument. 
            If more than two arguments are present, the calculation is left associative.
            This is not part of PDDL; it was rather added for TLPlan.
            </summary>
        </member>
        <member name="M:PDDLParser.Exp.Numeric.TLPlan.NArityModulo.#ctor(System.Collections.Generic.List{PDDLParser.Exp.INumericExp})">
            <summary>
            Creates a new modulo function with the specified arguments.
            </summary>
            <param name="args">The arguments of the new modulo function.</param>
        </member>
        <member name="M:PDDLParser.Exp.Numeric.TLPlan.NArityModulo.Calculate(System.Double[])">
            <summary>
            Calculates the remainder after division of all arguments. If only one argument 
            is present, then the result is that argument. If more than two arguments are present, 
            the calculation is left associative. Taking the remainder of two floating point arguments 
            is perfectly legal. Division by zero is an error.
            </summary>
            <param name="args">The arguments to call the function with.</param>
            <returns>The remainder after division of all arguments.</returns>
        </member>
        <member name="T:PDDLParser.Exp.Metric.MaximizeExp">
            <summary>
            Represents the maximize expression used in metric specification of the PDDL language.
            </summary>
        </member>
        <member name="M:PDDLParser.Exp.Metric.MaximizeExp.#ctor(PDDLParser.Exp.INumericExp,PDDLParser.Exp.INumericExp)">
            <summary>
            Creates a maximize metric with the given expression.
            </summary>
            <param name="exp">The expression to maximize.</param>
            <param name="unnamedPrefs">The unnamed preferences.</param>
        </member>
        <member name="M:PDDLParser.Exp.Metric.MaximizeExp.EvaluateMinimizedMetric(PDDLParser.World.IReadOnlyOpenWorld,PDDLParser.Exp.LocalBindings)">
            <summary>
            Returns a minimized version of the metric evaluated on a given world.
            </summary>
            <param name="world">The evaluation world.</param>
            <param name="bindings">A set of variable bindings.</param>
            <returns>The minimized version of the metric.</returns>
        </member>
        <member name="M:PDDLParser.Exp.Metric.MaximizeExp.EvaluateMinimizedMetric(PDDLParser.World.IReadOnlyClosedWorld,PDDLParser.Exp.LocalBindings)">
            <summary>
            Returns a minimized version of the metric evaluated on a given world.
            </summary>
            <param name="world">The evaluation world.</param>
            <param name="bindings">A set of variable bindings.</param>
            <returns>The minimized version of the metric.</returns>
        </member>
        <member name="P:PDDLParser.Exp.Metric.MaximizeExp.TypeName">
            <summary>
            Gets a string representatin of the type of optimization required.
            </summary>
        </member>
        <member name="T:PDDLParser.Exp.Logical.ForallExp">
            <summary>
            This class represents a universal quantification of a logical expression.
            </summary>
        </member>
        <member name="M:PDDLParser.Exp.Logical.ForallExp.#ctor(System.Collections.Generic.HashSet{PDDLParser.Exp.Term.ObjectParameterVariable},PDDLParser.Exp.ILogicalExp)">
            <summary>
            Creates a new universal expression with the given quantified variables and 
            logical expression.
            </summary>
            <param name="vars">The quantified variables.</param>
            <param name="exp">The logical expression</param>
        </member>
        <member name="M:PDDLParser.Exp.Logical.ForallExp.GenerateEquivalentExp">
            <summary>
            Creates a new ground expression equivalent to this quantified expression.
            </summary>
            <returns>A new ground expression equivalent to this quantified expression.</returns>
        </member>
        <member name="M:PDDLParser.Exp.Logical.ForallExp.Evaluate(PDDLParser.World.IReadOnlyOpenWorld,PDDLParser.Exp.LocalBindings)">
            <summary>
            Evaluates this logical expression in the specified open world.
            A universal expression is evaluated as the conjunction of all its variable substitutions.
            </summary>
            <param name="world">The evaluation world.</param>
            <param name="bindings">A set of variable bindings.</param>
            <returns>True, false, undefined, or unknown.</returns>
        </member>
        <member name="M:PDDLParser.Exp.Logical.ForallExp.EvaluateWithImmediateShortCircuit(PDDLParser.World.IReadOnlyOpenWorld,PDDLParser.Exp.LocalBindings)">
            <summary>
            Evaluates this logical expression in the specified open world.
            In addition to False, Undefined and Unknown also shortcircuit conjunctions.
            In addition to True, Unknown also shortcircuits disjunctions.
            A universal expression is evaluated as the conjunction of all its variable substitutions.
            </summary>
            <param name="world">The evaluation world.</param>
            <param name="bindings">A set of variable bindings.</param>
            <returns>True, false, undefined, or unknown.</returns>
        </member>
        <member name="M:PDDLParser.Exp.Logical.ForallExp.Simplify(PDDLParser.World.IReadOnlyOpenWorld,PDDLParser.Exp.LocalBindings)">
            <summary>
            Simplifies this logical expression by evaluating its known expression parts.
            A universal expression is simplified as a conjunction of its yet unknown substitutions.
            </summary>
            <param name="world">The evaluation world.</param>
            <param name="bindings">A set of variable bindings.</param>
            <returns>True, false, undefined, or the simplified expression.</returns>
        </member>
        <member name="M:PDDLParser.Exp.Logical.ForallExp.Evaluate(PDDLParser.World.IReadOnlyClosedWorld,PDDLParser.Exp.LocalBindings)">
            <summary>
            Evaluates this logical expression in the specified closed world.
            A universal expression is evaluated as the conjunction of all its variable substitutions.
            </summary>
            <param name="world">The evaluation world.</param>
            <param name="bindings">A set of variable bindings.</param>
            <returns>True, false, or undefined.</returns>
        </member>
        <member name="M:PDDLParser.Exp.Logical.ForallExp.EvaluateWithImmediateShortCircuit(PDDLParser.World.IReadOnlyClosedWorld,PDDLParser.Exp.LocalBindings)">
            <summary>
            Evaluates this logical expression in the specified closed world.
            In addition to False, Undefined also shortcircuit conjunctions.
            A universal expression is evaluated as the conjunction of all its variable substitutions.
            </summary>
            <param name="world">The evaluation world.</param>
            <param name="bindings">A set of variable bindings.</param>
            <returns>True, false, or undefined.</returns>
        </member>
        <member name="M:PDDLParser.Exp.Logical.ForallExp.EnumerateAllSatisfyingWorlds">
            <summary>
            Enumerates all the worlds within which this logical expression evaluates to true.
            This method is used to support the goal modality expressions.
            </summary>
            <returns>All the worlds satisfying this logical expression.</returns>
        </member>
        <member name="M:PDDLParser.Exp.Logical.ForallExp.Progress(PDDLParser.World.IReadOnlyDurativeClosedWorld,PDDLParser.Exp.LocalBindings)">
            <summary>
            Evaluates the progression of this constraint expression in the next worlds.
            This function returns false if this constraint expression is not satisfied 
            in the given world;
            it returns true if the progression is always satisfied in the next worlds;
            else it returns the progressed expression.
            </summary>
            <param name="world">The current world.</param>
            <param name="bindings">A set of variable bindings.</param>
            <returns>True, false, undefined, or a progressed expression.</returns>
        </member>
        <member name="M:PDDLParser.Exp.Logical.ForallExp.EvaluateIdle(PDDLParser.World.IReadOnlyDurativeClosedWorld,PDDLParser.Exp.LocalBindings)">
            <summary>
            Evaluates this constraint expression in an idle world, i.e. a world which
            won't be modified by further updates.
            </summary>
            <param name="idleWorld">The (idle) evaluation world.</param>
            <param name="bindings">A set of variable bindings.</param>
            <returns>True, false, or undefined.</returns>
        </member>
        <member name="T:PDDLParser.Exp.Logical.FalseExp">
            <summary>
            This class represents a false logical expression, i.e. a contradiction.
            </summary>
        </member>
        <member name="F:PDDLParser.Exp.Logical.FalseExp.s_falseExp">
            <summary>
            The immutable false expression.
            </summary>
        </member>
        <member name="M:PDDLParser.Exp.Logical.FalseExp.#ctor">
            <summary>
            Creates a new false expression. Note that this constructor is private.
            </summary>
        </member>
        <member name="M:PDDLParser.Exp.Logical.FalseExp.Evaluate(PDDLParser.World.IReadOnlyOpenWorld,PDDLParser.Exp.LocalBindings)">
            <summary>
            Evaluates this logical expression in the specified open world.
            </summary>
            <param name="world">The evaluation world.</param>
            <param name="bindings">A set of variable bindings.</param>
            <returns>False.</returns>
        </member>
        <member name="M:PDDLParser.Exp.Logical.FalseExp.EvaluateWithImmediateShortCircuit(PDDLParser.World.IReadOnlyOpenWorld,PDDLParser.Exp.LocalBindings)">
            <summary>
            Evaluates this logical expression in the specified open world.
            </summary>
            <param name="world">The evaluation world.</param>
            <param name="bindings">A set of variable bindings.</param>
            <returns>False.</returns>
        </member>
        <member name="M:PDDLParser.Exp.Logical.FalseExp.Simplify(PDDLParser.World.IReadOnlyOpenWorld,PDDLParser.Exp.LocalBindings)">
            <summary>
            Simplifies this logical expression by evaluating its known expression parts.
            </summary>
            <param name="world">The evaluation world.</param>
            <param name="bindings">A set of variable bindings.</param>
            <returns>False.</returns>
        </member>
        <member name="M:PDDLParser.Exp.Logical.FalseExp.Evaluate(PDDLParser.World.IReadOnlyClosedWorld,PDDLParser.Exp.LocalBindings)">
            <summary>
            Evaluates this logical expression in the specified closed world.
            </summary>
            <param name="world">The evaluation world.</param>
            <param name="bindings">A set of variable bindings.</param>
            <returns>False.</returns>
        </member>
        <member name="M:PDDLParser.Exp.Logical.FalseExp.EvaluateWithImmediateShortCircuit(PDDLParser.World.IReadOnlyClosedWorld,PDDLParser.Exp.LocalBindings)">
            <summary>
            Evaluates this logical expression in the specified closed world.
            </summary>
            <param name="world">The evaluation world.</param>
            <param name="bindings">A set of variable bindings.</param>
            <returns>False.</returns>
        </member>
        <member name="M:PDDLParser.Exp.Logical.FalseExp.EnumerateAllSatisfyingWorlds">
            <summary>
            Enumerates all the worlds within which this logical expression evaluates to true.
            This method is used to support the goal modality expressions.
            Note that no world can satisfy a false expression.
            </summary>
            <returns>The empty set.</returns>
        </member>
        <member name="M:PDDLParser.Exp.Logical.FalseExp.Progress(PDDLParser.World.IReadOnlyDurativeClosedWorld,PDDLParser.Exp.LocalBindings)">
            <summary>
            Evaluates the progression of this constraint expression in the next worlds.
            </summary>
            <param name="world">The current world.</param>
            <param name="bindings">A set of variable bindings.</param>
            <returns>False.</returns>
        </member>
        <member name="M:PDDLParser.Exp.Logical.FalseExp.EvaluateIdle(PDDLParser.World.IReadOnlyDurativeClosedWorld,PDDLParser.Exp.LocalBindings)">
            <summary>
            Evaluates this constraint expression in an idle world, i.e. a world which
            won't be modified by further updates.
            </summary>
            <param name="idleWorld">The (idle) evaluation world.</param>
            <param name="bindings">A set of variable bindings.</param>
            <returns>False.</returns>
        </member>
        <member name="M:PDDLParser.Exp.Logical.FalseExp.Apply(PDDLParser.Exp.ParameterBindings)">
            <summary>
            Substitutes all occurrences of the variables that occur in this
            expression by their corresponding bindings.
            </summary>
            <param name="bindings">The bindings.</param>
            <returns>This.</returns>
        </member>
        <member name="M:PDDLParser.Exp.Logical.FalseExp.Standardize(System.Collections.Generic.IDictionary{System.String,System.String})">
            <summary>
            Standardizes all occurrences of the variables that occur in this
            expression. The IDictionary argument is used to store the variable already
            standardized. Remember that free variables are existentially quantified.
            </summary>
            <param name="images">The object that maps old variable images to the standardize
            image.</param>
            <returns>This.</returns>
        </member>
        <member name="M:PDDLParser.Exp.Logical.FalseExp.IsGround">
            <summary>
            Returns true if the expression is ground, i.e. it does not contain any variables.
            </summary>
            <returns>True.</returns>
        </member>
        <member name="M:PDDLParser.Exp.Logical.FalseExp.GetFreeVariables">
            <summary>
            Returns the free variables in this expression.
            </summary>
            <returns>The empty set.</returns>
        </member>
        <member name="M:PDDLParser.Exp.Logical.FalseExp.Clone">
            <summary>
            Returns a clone of this expression.
            </summary>
            <returns>This.</returns>
        </member>
        <member name="M:PDDLParser.Exp.Logical.FalseExp.Equals(System.Object)">
            <summary>
            Returns true if this expression is equal to a specified object.
            </summary>
            <param name="obj">Object to test for equality.</param>
            <returns>True if this expression is equal to the specified objet.</returns>
        </member>
        <member name="M:PDDLParser.Exp.Logical.FalseExp.GetHashCode">
            <summary>
            Returns the hash code of this expression.
            </summary>
            <returns>The hash code of this expression.</returns>
        </member>
        <member name="M:PDDLParser.Exp.Logical.FalseExp.ToTypedString">
            <summary>
            Returns a typed string of this expression.
            </summary>
            <returns>A typed string representation of this expression.</returns>
        </member>
        <member name="M:PDDLParser.Exp.Logical.FalseExp.ToString">
            <summary>
            Returns a string representation of this expression.
            </summary>
            <returns>A string representation of this expression.</returns>
        </member>
        <member name="P:PDDLParser.Exp.Logical.FalseExp.False">
            <summary>
            The false expression.
            </summary>
        </member>
        <member name="T:PDDLParser.Exp.Formula.TLPlan.LocalVar.BooleanLocalVariable">
            <summary>
            A boolean local variable is a local variable bound to a boolean value.
            </summary>
        </member>
        <member name="T:PDDLParser.Exp.Formula.TLPlan.LocalVar.BooleanVariable">
            <summary>
            A boolean variable is a variable bound to a boolean value.
            </summary>
        </member>
        <member name="M:PDDLParser.Exp.Formula.TLPlan.LocalVar.BooleanVariable.#ctor(System.String)">
            <summary>
            Creates a new boolean variable with the specified name.
            </summary>
            <param name="name">The name of the boolean variable.</param>
        </member>
        <member name="M:PDDLParser.Exp.Formula.TLPlan.LocalVar.BooleanVariable.Evaluate(PDDLParser.World.IReadOnlyOpenWorld,PDDLParser.Exp.LocalBindings)">
            <summary>
            Evaluates this logical expression in the specified open world.
            The bindings should not be modified by this call.
            </summary>
            <param name="world">The evaluation world.</param>
            <param name="bindings">A set of variable bindings.</param>
            <returns>True, false, undefined, or unknown.</returns>
            <exception cref="T:PDDLParser.Exception.BindingException">A BindingException is thrown if this
            variable is not bound.</exception>
        </member>
        <member name="M:PDDLParser.Exp.Formula.TLPlan.LocalVar.BooleanVariable.EvaluateWithImmediateShortCircuit(PDDLParser.World.IReadOnlyOpenWorld,PDDLParser.Exp.LocalBindings)">
            <summary>
            Evaluates this logical expression in the specified open world.
            The bindings should not be modified by this call.
            In addition to False, Undefined and Unknown also shortcircuit conjunctions.
            In addition to True, Unknown also shortcircuits disjunctions.
            This function is used to evaluate defined formulas' body as is done in the
            original TLPlan.
            </summary>
            <param name="world">The evaluation world.</param>
            <param name="bindings">A set of variable bindings.</param>
            <returns>True, false, undefined, or unknown.</returns>
            <exception cref="T:PDDLParser.Exception.BindingException">A BindingException is thrown if this
            variable is not bound.</exception>
        </member>
        <member name="M:PDDLParser.Exp.Formula.TLPlan.LocalVar.BooleanVariable.Simplify(PDDLParser.World.IReadOnlyOpenWorld,PDDLParser.Exp.LocalBindings)">
            <summary>
            Simplifies this logical expression by evaluating its known expression parts.
            The bindings should not be modified by this call.
            The resulting expression should not contain any unbound variables, since
            they are substituted according to the bindings supplied.
            </summary>
            <param name="world">The evaluation world.</param>
            <param name="bindings">A set of variable bindings.</param>
            <returns>True, false, undefined, or the simplified expression.</returns>
            <exception cref="T:PDDLParser.Exception.BindingException">A BindingException is thrown if this
            variable is not bound.</exception>
        </member>
        <member name="M:PDDLParser.Exp.Formula.TLPlan.LocalVar.BooleanVariable.Evaluate(PDDLParser.World.IReadOnlyClosedWorld,PDDLParser.Exp.LocalBindings)">
            <summary>
            Evaluates this logical expression in the specified closed world.
            The bindings should not be modified by this call.
            </summary>
            <param name="world">The evaluation world.</param>
            <param name="bindings">A set of variable bindings.</param>
            <returns>True, false, or undefined.</returns>
            <exception cref="T:PDDLParser.Exception.BindingException">A BindingException is thrown if this
            variable is not bound.</exception>
        </member>
        <member name="M:PDDLParser.Exp.Formula.TLPlan.LocalVar.BooleanVariable.EvaluateWithImmediateShortCircuit(PDDLParser.World.IReadOnlyClosedWorld,PDDLParser.Exp.LocalBindings)">
            <summary>
            Evaluates this logical expression in the specified closed world.
            The bindings should not be modified by this call.
            In addition to False, Undefined also shortcircuit conjunctions.
            This function is used to evaluate defined formulas' body as is done in the
            original TLPlan.
            </summary>
            <param name="world">The evaluation world.</param>
            <param name="bindings">A set of variable bindings.</param>
            <returns>True, false, or undefined.</returns>
            <exception cref="T:PDDLParser.Exception.BindingException">A BindingException is thrown if this
            variable is not bound.</exception>
        </member>
        <member name="M:PDDLParser.Exp.Formula.TLPlan.LocalVar.BooleanVariable.EnumerateAllSatisfyingWorlds">
            <summary>
            This method is not supported.
            </summary>
            <returns>Throws an exception.</returns>
            <exception cref="T:System.NotSupportedException">A NotSupportedException is always thrown since
            this method is not supported.</exception>
        </member>
        <member name="M:PDDLParser.Exp.Formula.TLPlan.LocalVar.BooleanVariable.ToTypedString">
            <summary>
            Returns a typed string representation of this expression.
            </summary>
            <returns>A typed string representation of this expression.</returns>
        </member>
        <member name="M:PDDLParser.Exp.Formula.TLPlan.LocalVar.BooleanVariable.Progress(PDDLParser.World.IReadOnlyDurativeClosedWorld,PDDLParser.Exp.LocalBindings)">
            <summary>
            Evaluates the progression of this constraint expression in the next worlds.
            This function returns false if this constraint expression is not satisfied 
            in the given world;
            it returns true if the progression is always satisfied in the next worlds;
            else it returns the progressed expression.
            </summary>
            <param name="world">The current world.</param>
            <param name="bindings">A set of variable bindings.</param>
            <returns>True, false, undefined, or a progressed expression.</returns>
            <exception cref="T:PDDLParser.Exception.BindingException">A BindingException is thrown if an attempt
            is made to evaluate an unbound variable.</exception>
        </member>
        <member name="M:PDDLParser.Exp.Formula.TLPlan.LocalVar.BooleanVariable.EvaluateIdle(PDDLParser.World.IReadOnlyDurativeClosedWorld,PDDLParser.Exp.LocalBindings)">
            <summary>
            Evaluates this constraint expression in an idle world, i.e. a world which
            won't be modified by further updates.
            </summary>
            <param name="idleWorld">The (idle) evaluation world.</param>
            <param name="bindings">A set of variable bindings.</param>
            <returns>True, false, or undefined.</returns>
            <exception cref="T:PDDLParser.Exception.BindingException">A BindingException is thrown if an attempt
            is made to evaluate an unbound variable.</exception>
        </member>
        <member name="M:PDDLParser.Exp.Formula.TLPlan.LocalVar.BooleanLocalVariable.#ctor(System.String)">
            <summary>
            Creates a new boolean local variable with the specified name.
            </summary>
            <param name="name">The name of this boolean local variable.</param>
        </member>
        <member name="M:PDDLParser.Exp.Formula.TLPlan.LocalVar.BooleanLocalVariable.Evaluate(PDDLParser.World.IReadOnlyOpenWorld,PDDLParser.Exp.LocalBindings)">
            <summary>
            Evaluates this logical expression in the specified open world.
            A local variable is evaluated by retrieving its binding in the provided set of bindings.
            </summary>
            <param name="world">The evaluation world.</param>
            <param name="bindings">A set of variable bindings.</param>
            <returns>True, false, undefined, or unknown.</returns>
            <exception cref="T:PDDLParser.Exception.BindingException">A BindingException is thrown if this
            variable is not bound.</exception>
        </member>
        <member name="M:PDDLParser.Exp.Formula.TLPlan.LocalVar.BooleanLocalVariable.EvaluateWithImmediateShortCircuit(PDDLParser.World.IReadOnlyOpenWorld,PDDLParser.Exp.LocalBindings)">
            <summary>
            Evaluates this logical expression in the specified open world.
            A local variable is evaluated by retrieving its binding in the provided set of bindings.
            </summary>
            <param name="world">The evaluation world.</param>
            <param name="bindings">A set of variable bindings.</param>
            <returns>True, false, undefined, or unknown.</returns>
            <exception cref="T:PDDLParser.Exception.BindingException">A BindingException is thrown if this
            variable is not bound.</exception>
        </member>
        <member name="M:PDDLParser.Exp.Formula.TLPlan.LocalVar.BooleanLocalVariable.Simplify(PDDLParser.World.IReadOnlyOpenWorld,PDDLParser.Exp.LocalBindings)">
            <summary>
            Simplifies this logical expression by evaluating its known expression parts.
            A local variable is simplified by retrieving its corresponding binding, if accessible.
            </summary>
            <param name="world">The evaluation world.</param>
            <param name="bindings">A set of variable bindings.</param>
            <returns>True, false, undefined, or the simplified expression.</returns>
            <exception cref="T:PDDLParser.Exception.BindingException">A BindingException is thrown if this
            variable is not bound.</exception>
        </member>
        <member name="M:PDDLParser.Exp.Formula.TLPlan.LocalVar.BooleanLocalVariable.Evaluate(PDDLParser.World.IReadOnlyClosedWorld,PDDLParser.Exp.LocalBindings)">
            <summary>
            Evaluates this logical expression in the specified closed world.
            A local variable is evaluated by retrieving its binding in the provided set of bindings.
            </summary>
            <param name="world">The evaluation world.</param>
            <param name="bindings">A set of variable bindings.</param>
            <returns>True, false, or undefined.</returns>
            <exception cref="T:PDDLParser.Exception.BindingException">A BindingException is thrown if this
            variable is not bound.</exception>
        </member>
        <member name="M:PDDLParser.Exp.Formula.TLPlan.LocalVar.BooleanLocalVariable.EvaluateWithImmediateShortCircuit(PDDLParser.World.IReadOnlyClosedWorld,PDDLParser.Exp.LocalBindings)">
            <summary>
            Evaluates this logical expression in the specified closed world.
            In addition to False, Undefined also shortcircuit conjunctions.
            A local variable is evaluated by retrieving its binding in the provided set of bindings.
            </summary>
            <param name="world">The evaluation world.</param>
            <param name="bindings">A set of variable bindings.</param>
            <returns>True, false, or undefined.</returns>
            <exception cref="T:PDDLParser.Exception.BindingException">A BindingException is thrown if this
            variable is not bound.</exception>
        </member>
        <member name="M:PDDLParser.Exp.Formula.TLPlan.LocalVar.BooleanLocalVariable.Apply(PDDLParser.Exp.ParameterBindings)">
            <summary>
            Substitutes all occurrences of the variables that occur in this
            expression by their corresponding bindings.
            </summary>
            <param name="bindings">The bindings.</param>
            <returns>A substituted copy of this expression.</returns>
        </member>
        <member name="M:PDDLParser.Exp.Formula.TLPlan.LocalVar.BooleanLocalVariable.IsFree">
            <summary>
            Returns true if this variable is free, false it is bound.
            A boolean local variable is bound.
            </summary>
            <returns>False.</returns>
        </member>
        <member name="T:PDDLParser.Exp.Constraint.SometimeAfterExp">
            <summary>
            Represents the "sometime-after" constraint expression of the PDDL language.
            </summary>
            <seealso cref="T:PDDLParser.Exp.Constraint.AlwaysExp"/>
            <seealso cref="T:PDDLParser.Exp.Constraint.ImplyConstraintExp"/>
            <seealso cref="T:PDDLParser.Exp.Constraint.SometimeExp"/>
        </member>
        <member name="F:PDDLParser.Exp.Constraint.SometimeAfterExp.m_exp">
            <summary>
            The first, conditional constraint expression.
            </summary>
        </member>
        <member name="F:PDDLParser.Exp.Constraint.SometimeAfterExp.m_afterExp">
            <summary>
            The second, consequent constraint expression that must be true after the first one.
            </summary>
            <remarks>This may never be progressed if the <see cref="F:PDDLParser.Exp.Constraint.SometimeAfterExp.m_exp"/> never progresses to true.</remarks>
        </member>
        <member name="M:PDDLParser.Exp.Constraint.SometimeAfterExp.#ctor(PDDLParser.Exp.IConstraintExp,PDDLParser.Exp.IConstraintExp)">
            <summary>
            Creates a new "sometime-after" constraint expression.
            </summary>
            <param name="exp">The first, conditional constraint expression.</param>
            <param name="afterExp">The second, consequent constraint expression (progressed only if the first one ever progresses to true).</param>
        </member>
        <member name="M:PDDLParser.Exp.Constraint.SometimeAfterExp.GenerateEquivalentExp">
            <summary>
            Generates and returns the compound constraint expression equivalent to this expression.
            in this case, (sometime-after a b) = (always (imply a (sometime b))
            </summary>
            <returns>An equivalent constraint expression to this expression.</returns>
            <seealso cref="T:PDDLParser.Exp.Constraint.AlwaysExp"/>
            <seealso cref="T:PDDLParser.Exp.Constraint.ImplyConstraintExp"/>
            <seealso cref="T:PDDLParser.Exp.Constraint.SometimeExp"/>
        </member>
        <member name="M:PDDLParser.Exp.Constraint.SometimeAfterExp.Apply(PDDLParser.Exp.ParameterBindings)">
            <summary>
            Substitutes all occurrences of the variables that occur in this
            expression by their corresponding bindings.
            The base implementation is to simply clone the object.
            </summary>
            <param name="bindings">The bindings.</param>
            <returns>A substituted copy of this expression.</returns>
        </member>
        <member name="M:PDDLParser.Exp.Constraint.SometimeAfterExp.Standardize(System.Collections.Generic.IDictionary{System.String,System.String})">
            <summary>
            Standardizes all occurrences of the variables that occur in this
            expression. The IDictionary argument is used to store the variable already
            standardized. Remember that free variables are existentially quantified.
            The base implementation is to simply clone the object.
            </summary>
            <param name="images">The object that maps old variable images to the standardize
            image.</param>
            <returns>A standardized copy of this expression.</returns>
        </member>
        <member name="M:PDDLParser.Exp.Constraint.SometimeAfterExp.Equals(System.Object)">
            <summary>
            Returns true if this expression is equal to a specified object.
            </summary>
            <param name="obj">Object to test for equality.</param>
            <returns>True if this expression is equal to the specified objet.</returns>
        </member>
        <member name="M:PDDLParser.Exp.Constraint.SometimeAfterExp.GetHashCode">
            <summary>
            Returns the hash code of this expression.
            </summary>
            <returns>The hash code of this expression.</returns>
        </member>
        <member name="M:PDDLParser.Exp.Constraint.SometimeAfterExp.ToString">
            <summary>
            Returns a string representation of this expression.
            </summary>
            <returns>A string representation of this expression.</returns>
        </member>
        <member name="M:PDDLParser.Exp.Constraint.SometimeAfterExp.ToTypedString">
            <summary>
            Returns a typed string of this expression.
            </summary>
            <returns>A typed string representation of this expression.</returns>
        </member>
        <member name="M:PDDLParser.Exp.Constraint.SometimeAfterExp.CompareTo(PDDLParser.Exp.IExp)">
            <summary>
            Compares this abstract expression with another expression.
            </summary>
            <param name="other">The other expression to compare this abstract expression to.</param>
            <returns>An integer representing the total order relation between the two expressions.</returns>
        </member>
        <member name="T:PDDLParser.Exp.Comparison.LessEqualComp">
            <summary>
            This class implements the less or equal numeric comparison.
            </summary>
        </member>
        <member name="M:PDDLParser.Exp.Comparison.LessEqualComp.#ctor(PDDLParser.Exp.INumericExp,PDDLParser.Exp.INumericExp)">
            <summary>
            Creates a new less or equal numeric comparison.
            </summary>
            <param name="arg1">The first argument.</param>
            <param name="arg2">The second argument.</param>
        </member>
        <member name="M:PDDLParser.Exp.Comparison.LessEqualComp.Compare(PDDLParser.Exp.Struct.Double,PDDLParser.Exp.Struct.Double)">
            <summary>
            Compares the two arguments. This comparison should return undefined if at least
            one of the two arguments is undefined.
            </summary>
            <param name="arg1">The first argument.</param>
            <param name="arg2">The second argument.</param>
            <returns>True, false, or undefined.</returns>
        </member>
        <member name="M:PDDLParser.Exp.Comparison.LessEqualComp.Compare(PDDLParser.Exp.Struct.FuzzyDouble,PDDLParser.Exp.Struct.FuzzyDouble)">
            <summary>
            Compares the two arguments. This comparison should return undefined if at least one 
            of the two arguments is undefined, or unknown if at least one of the two arguments is 
            unknown.
            </summary>
            <param name="arg1">The first argument.</param>
            <param name="arg2">The second argument.</param>
            <returns>True, false, undefined, or unknown.</returns>
        </member>
        <member name="T:PDDLParser.Action.ContinuousVariable">
            <summary>
            Represents the continusous variable of the PDDL language (i.e. the "#t" symbol)
            </summary>
        </member>
        <member name="M:PDDLParser.Action.ContinuousVariable.#ctor">
            <summary>
            Creates an instance of the continuous variable.
            </summary>
        </member>
        <member name="M:PDDLParser.Action.ContinuousVariable.Evaluate(PDDLParser.World.IReadOnlyOpenWorld,PDDLParser.Exp.LocalBindings)">
            <summary>
            Evaluates this numeric expression in the specified open world.
            The bindings should not be modified by this call.
            </summary>
            <param name="world">The evaluation world.</param>
            <param name="bindings">A set of variable bindings.</param>
            <returns>Undefined, unknown, or the resulting numeric value.</returns>
            <exception cref="T:PDDLParser.Exception.BindingException">A BindingException is thrown if an attempt
            is made to evaluate an unbound variable.</exception>
            <exception cref="T:PDDLParser.Exception.NumericException">A NumericException is thrown if an 
            illegal operation is performed (like a division by zero).</exception>
        </member>
        <member name="M:PDDLParser.Action.ContinuousVariable.Evaluate(PDDLParser.World.IReadOnlyClosedWorld,PDDLParser.Exp.LocalBindings)">
            <summary>
            Evaluates this numeric expression in the specified closed world.
            The bindings should not be modified by this call.
            </summary>
            <param name="world">The evaluation world.</param>
            <param name="bindings">A set of variable bindings.</param>
            <returns>Undefined, or the resulting numeric value.</returns>
            <exception cref="T:PDDLParser.Exception.BindingException">A BindingException is thrown if an attempt
            is made to evaluate an unbound variable.</exception>
            <exception cref="T:PDDLParser.Exception.NumericException">A NumericException is thrown if an 
            illegal operation is performed (like a division by zero).</exception>
        </member>
        <member name="T:PDDLParser.World.Context.IEvaluationRecord`1">
            <summary>
            An evaluation records whether an evaluation is finished and the result of this
            evaluation.
            </summary>
            <typeparam name="T">The type of evaluation record.</typeparam>
        </member>
        <member name="P:PDDLParser.World.Context.IEvaluationRecord`1.Finished">
            <summary>
            Whether the evaluation has finished.
            </summary>
        </member>
        <member name="P:PDDLParser.World.Context.IEvaluationRecord`1.Result">
            <summary>
            The result of the evaluation, which is not defined if the evaluation is in progress.
            </summary>
        </member>
        <member name="T:PDDLParser.World.Context.EvaluationRecord`1">
            <summary>
            An evaluation record holds information about the evaluation status 
            and result of a logical expression.
            </summary>
            <typeparam name="T">The record type.</typeparam>
        </member>
        <member name="F:PDDLParser.World.Context.EvaluationRecord`1.m_finished">
            <summary>
            Whether the evaluation has finished.
            </summary>
        </member>
        <member name="F:PDDLParser.World.Context.EvaluationRecord`1.m_result">
            <summary>
            The result of the evaluation.
            </summary>
        </member>
        <member name="M:PDDLParser.World.Context.EvaluationRecord`1.#ctor">
            <summary>
            Creates a new evaluation record and assumes the evaluation has 
            not finished yet.
            </summary>
        </member>
        <member name="M:PDDLParser.World.Context.EvaluationRecord`1.#ctor(`0)">
            <summary>
            Creates a new evaluation record and sets the result of the evaluation.
            </summary>
            <param name="result">The result of the evaluation.</param>
        </member>
        <member name="P:PDDLParser.World.Context.EvaluationRecord`1.Finished">
            <summary>
            Whether the evaluation has finished.
            </summary>
        </member>
        <member name="P:PDDLParser.World.Context.EvaluationRecord`1.Result">
            <summary>
            The result of the evaluation.
            </summary>
        </member>
        <member name="T:PDDLParser.World.Context.FuzzyCertaintyEvaluationRecordWrapper">
            <summary>
            This wrapper wraps a Bool evaluation record into a FuzzyBool evaluation record.
            </summary>
        </member>
        <member name="F:PDDLParser.World.Context.FuzzyCertaintyEvaluationRecordWrapper.m_eval">
            <summary>
            The wrapped Bool evaluation record.
            </summary>
        </member>
        <member name="M:PDDLParser.World.Context.FuzzyCertaintyEvaluationRecordWrapper.#ctor(PDDLParser.World.Context.IEvaluationRecord{PDDLParser.Exp.Struct.BoolValue})">
            <summary>
            Creates a new wrapper for the specified wrapped Bool evaluation record.
            </summary>
            <param name="eval">The wrapped Bool evaluation record.</param>
        </member>
        <member name="P:PDDLParser.World.Context.FuzzyCertaintyEvaluationRecordWrapper.Finished">
            <summary>
            Whether the evaluation has finished.
            </summary>
        </member>
        <member name="P:PDDLParser.World.Context.FuzzyCertaintyEvaluationRecordWrapper.Result">
            <summary>
            The result of the evaluation.
            </summary>
        </member>
        <member name="T:PDDLParser.World.Context.FuzzyNumericEvaluationRecordWrapper">
            <summary>
            This wrapper wraps a Double evaluation record into a FuzzyDouble evaluation record.
            </summary>
        </member>
        <member name="F:PDDLParser.World.Context.FuzzyNumericEvaluationRecordWrapper.m_eval">
            <summary>
            The wrapped Double evaluation record.
            </summary>
        </member>
        <member name="M:PDDLParser.World.Context.FuzzyNumericEvaluationRecordWrapper.#ctor(PDDLParser.World.Context.IEvaluationRecord{PDDLParser.Exp.Struct.Double})">
            <summary>
            Creates a new wrapper for the specified wrapped Double evaluation record.
            </summary>
            <param name="eval">The wrapped Double evaluation record.</param>
        </member>
        <member name="P:PDDLParser.World.Context.FuzzyNumericEvaluationRecordWrapper.Finished">
            <summary>
            Whether the evaluation has finished.
            </summary>
        </member>
        <member name="P:PDDLParser.World.Context.FuzzyNumericEvaluationRecordWrapper.Result">
            <summary>
            The result of the evaluation.
            </summary>
        </member>
        <member name="T:PDDLParser.World.Context.FuzzyObjectEvaluationRecordWrapper">
            <summary>
            This wrapper wraps a ConstantExp evaluation record into a FuzzyConstantExp
            evaluation record.
            </summary>
        </member>
        <member name="F:PDDLParser.World.Context.FuzzyObjectEvaluationRecordWrapper.m_eval">
            <summary>
            The wrapped ConstantExp evaluation record.
            </summary>
        </member>
        <member name="M:PDDLParser.World.Context.FuzzyObjectEvaluationRecordWrapper.#ctor(PDDLParser.World.Context.IEvaluationRecord{PDDLParser.Exp.Struct.ConstantExp})">
            <summary>
            Creates a new wrapper for the specified wrapped ConstantExp evaluation record.
            </summary>
            <param name="eval">The wrapped ConstantExp evaluation record.</param>
        </member>
        <member name="P:PDDLParser.World.Context.FuzzyObjectEvaluationRecordWrapper.Finished">
            <summary>
            Whether the evaluation has finished.
            </summary>
        </member>
        <member name="P:PDDLParser.World.Context.FuzzyObjectEvaluationRecordWrapper.Result">
            <summary>
            The result of the evaluation.
            </summary>
        </member>
        <member name="T:PDDLParser.Parser.Lexer.SimpleCharStream">
            An implementation of interface CharStream, where the stream is assumed to
            contain only ASCII characters (without unicode processing).
        </member>
        <member name="M:PDDLParser.Parser.Lexer.SimpleCharStream.getColumn">
            @deprecated 
            @see #getEndColumn
        </member>
        <member name="M:PDDLParser.Parser.Lexer.SimpleCharStream.getLine">
            @deprecated 
            @see #getEndLine
        </member>
        <member name="M:PDDLParser.Parser.Lexer.SimpleCharStream.adjustBeginLineColumn(System.Int32,System.Int32)">
            Method to adjust line and column numbers for the start of a token.
        </member>
        <member name="T:PDDLParser.Exp.Term.ObjectParameterVariable">
            <summary>
            An object parameter variable is a parameter variable which must be assigned a constant value.
            </summary>
        </member>
        <member name="T:PDDLParser.Exp.Term.ObjectVariable">
            <summary>
            An object variable is a variable bound to an object (a constant from the domain).
            </summary>
        </member>
        <member name="F:PDDLParser.Exp.Term.ObjectVariable.m_typeSet">
            <summary>
            The typeset of this object variable.
            </summary>
        </member>
        <member name="M:PDDLParser.Exp.Term.ObjectVariable.#ctor(System.String,PDDLParser.Exp.Term.Type.TypeSet)">
            <summary>
            Creates a new object variable with the specified name and typeset.
            </summary>
            <param name="name">The name of the object variable.</param>
            <param name="typeSet">The typeset of the object variable.</param>
        </member>
        <member name="M:PDDLParser.Exp.Term.ObjectVariable.Evaluate(PDDLParser.World.IReadOnlyOpenWorld,PDDLParser.Exp.LocalBindings)">
            <summary>
            Evaluates this term in the specified open world.
            The bindings should not be modified by this call.
            </summary>
            <param name="world">The evaluation world.</param>
            <param name="bindings">A set of variable bindings.</param>
            <returns>Undefined, unknown, or the constant resulting from the evaluation.</returns>
            <exception cref="T:PDDLParser.Exception.BindingException">A BindingException is thrown if this
            variable is not bound.</exception>
        </member>
        <member name="M:PDDLParser.Exp.Term.ObjectVariable.Simplify(PDDLParser.World.IReadOnlyOpenWorld,PDDLParser.Exp.LocalBindings)">
            <summary>
            Simplifies this term by evaluating its known expression parts.
            The bindings should not be modified by this call.
            The resulting expression should not contain any unbound variables, since
            they are substituted according to the bindings supplied.
            </summary>
            <param name="world">The evaluation world.</param>
            <param name="bindings">A set of variable bindings.</param>
            <returns>Undefined, or the term (possibly a constant) resulting from 
            the simplification.</returns>
            <exception cref="T:PDDLParser.Exception.BindingException">A BindingException is thrown if this
            variable is not bound.</exception>
        </member>
        <member name="M:PDDLParser.Exp.Term.ObjectVariable.Evaluate(PDDLParser.World.IReadOnlyClosedWorld,PDDLParser.Exp.LocalBindings)">
            <summary>
            Evaluates this term in the specified closed world.
            The bindings should not be modified by this call.
            </summary>
            <param name="world">The evaluation world.</param>
            <param name="bindings">A set of variable bindings.</param>
            <returns>Undefined, or the constant resulting from the evaluation.</returns>
            <exception cref="T:PDDLParser.Exception.BindingException">A BindingException is thrown if this
            variable is not bound.</exception>
        </member>
        <member name="M:PDDLParser.Exp.Term.ObjectVariable.GetTypeSet">
            <summary>
            Returns the typeset of this term.
            </summary>
            <returns>This term's typeset.</returns>
        </member>
        <member name="M:PDDLParser.Exp.Term.ObjectVariable.CanBeAssignedFrom(PDDLParser.Exp.ITerm)">
            <summary>
            Verifies whether the specified term can be assigned to this term, 
            i.e. if the other term's domain is a subset of this term's domain.
            </summary>
            <param name="term">The other term.</param>
            <returns>True if the types are compatible, false otherwise.</returns>
        </member>
        <member name="M:PDDLParser.Exp.Term.ObjectVariable.IsComparableTo(PDDLParser.Exp.ITerm)">
            <summary>
            Verifies whether the specified term can be compared to this term,
            i.e. if their domain overlap.
            </summary>
            <param name="term">The other term</param>
            <returns>True if the types can be compared, false otherwise.</returns>
        </member>
        <member name="M:PDDLParser.Exp.Term.ObjectVariable.Clone">
            <summary>
            Returns a clone of this expression.
            </summary>
            <returns>A clone of this expression.</returns>
        </member>
        <member name="M:PDDLParser.Exp.Term.ObjectVariable.SetTypeSet(PDDLParser.Exp.Term.Type.TypeSet)">
            <summary>
            Sets the typset of this object variable. Registration must be done on the TypeDomainChanged
            event of the typeset in the case where its domain changes.
            </summary>
            <param name="typeSet">The typeset of this object variable.</param>
        </member>
        <member name="M:PDDLParser.Exp.Term.ObjectVariable.TypeSet_TypeDomainChanged(PDDLParser.Exp.Term.Type.TypeSet)">
            <summary>
            Handles typeset TypeDomainChanged events.
            </summary>
            <param name="sender">The typeset which sent the event.</param>
        </member>
        <member name="M:PDDLParser.Exp.Term.ObjectVariable.FireTypeDomainChanged">
            <summary>
            Fires a TypeDomainChanged event.
            </summary>
        </member>
        <member name="M:PDDLParser.Exp.Term.ObjectVariable.ToTypedString">
            <summary>
            Returns a typed string representation of this expression.
            </summary>
            <returns>A typed string representation of this expression.</returns>
        </member>
        <member name="E:PDDLParser.Exp.Term.ObjectVariable.TypeDomainChanged">
            <summary>
            This event is raised whenever the domain of this object variable changes.
            This mechanism has been implemented to allow formulas to update their arguments ID
            if the domain of one of their argument is modified.
            </summary>
        </member>
        <member name="T:PDDLParser.Exp.Term.ObjectVariable.VariableEventHandler">
            <summary>
            An handler for messages transmitted by object variables.
            </summary>
            <param name="sender">The object variable which sends the message.</param>
        </member>
        <member name="F:PDDLParser.Exp.Term.ObjectParameterVariable.m_isFree">
            <summary>
            Whether this parameter variable is free.
            </summary>
        </member>
        <member name="M:PDDLParser.Exp.Term.ObjectParameterVariable.#ctor(System.String,PDDLParser.Exp.Term.Type.TypeSet,System.Boolean)">
            <summary>
            Creates a new object parameter variable with the specified name and typeset.
            </summary>
            <param name="name">The name of the new parameter variable.</param>
            <param name="typeSet">The typeset of the new parameter variable.</param>
            <param name="isFree">Whether the new parameter variable is free.</param>
        </member>
        <member name="M:PDDLParser.Exp.Term.ObjectParameterVariable.Evaluate(PDDLParser.World.IReadOnlyOpenWorld,PDDLParser.Exp.LocalBindings)">
            <summary>
            Evaluates this term in the specified open world.
            An object parameter variable evaluates to the constant to which it is bound.
            </summary>
            <param name="world">The evaluation world.</param>
            <param name="bindings">A set of variable bindings.</param>
            <returns>The constant to which this variable is bound.</returns>
        </member>
        <member name="M:PDDLParser.Exp.Term.ObjectParameterVariable.Simplify(PDDLParser.World.IReadOnlyOpenWorld,PDDLParser.Exp.LocalBindings)">
            <summary>
            Simplifies this term by evaluating its known expression parts.
            An object parameter variable simplifies to the constant to which it is bound.
            </summary>
            <param name="world">The evaluation world.</param>
            <param name="bindings">A set of variable bindings.</param>
            <returns>The constant to which this variable is bound.</returns>
        </member>
        <member name="M:PDDLParser.Exp.Term.ObjectParameterVariable.Evaluate(PDDLParser.World.IReadOnlyClosedWorld,PDDLParser.Exp.LocalBindings)">
            <summary>
            Evaluates this term in the specified closed world.
            An object parameter variable evaluates to the constant to which it is bound.
            </summary>
            <param name="world">The evaluation world.</param>
            <param name="bindings">A set of variable bindings.</param>
            <returns>The constant to which this variable is bound.</returns>
        </member>
        <member name="M:PDDLParser.Exp.Term.ObjectParameterVariable.Apply(PDDLParser.Exp.ParameterBindings)">
            <summary>
            Substitutes all occurrences of the variables that occur in this
            expression by their corresponding bindings.
            </summary>
            <param name="bindings">A set of variable bindings.</param>
            <returns>A substituted copy of this expression.</returns>
        </member>
        <member name="M:PDDLParser.Exp.Term.ObjectParameterVariable.IsFree">
            <summary>
            Returns true if this variable is free, false it is bound.
            </summary>
            <returns>Whether this variable is free.</returns>
        </member>
        <member name="M:PDDLParser.Exp.Term.ObjectParameterVariable.CompareTo(PDDLParser.Exp.Term.ObjectParameterVariable)">
            <summary>
            Compares this object parameter variable with another object parameter variable.
            </summary>
            <param name="other">The other variable to compare this variable to.</param>
            <returns>An integer representing the total order relation between the two variables.
            </returns>
        </member>
        <member name="T:PDDLParser.Exp.Struct.ConstantExp">
            <summary>
            A ConstantExp represents a constant value which may also be undefined.
            </summary>
        </member>
        <member name="F:PDDLParser.Exp.Struct.ConstantExp.Undefined">
            <summary>
            The undefined ConstantExp.
            </summary>
        </member>
        <member name="F:PDDLParser.Exp.Struct.ConstantExp.m_value">
            <summary>
            The constant object of this ConstantExp.
            </summary>
        </member>
        <member name="F:PDDLParser.Exp.Struct.ConstantExp.m_status">
            <summary>
            The status of this ConstantExp.
            </summary>
        </member>
        <member name="M:PDDLParser.Exp.Struct.ConstantExp.#ctor(PDDLParser.Exp.Term.Constant)">
            <summary>
            Creates a new ConstantExp with the specified constant object.
            </summary>
            <param name="value">The new ConstantExp's constant object.</param>
        </member>
        <member name="M:PDDLParser.Exp.Struct.ConstantExp.#ctor(PDDLParser.Exp.Struct.ConstantExp.State,PDDLParser.Exp.Term.Constant)">
            <summary>
            Creates a new ConstantExp with the specified status and constant object.
            </summary>
            <param name="status">The new ConstantExp's status.</param>
            <param name="value">The new ConstantExp's constant object.</param>
        </member>
        <member name="M:PDDLParser.Exp.Struct.ConstantExp.ConstantEquals(PDDLParser.Exp.Struct.ConstantExp,PDDLParser.Exp.Struct.ConstantExp)">
            <summary>
            Returns whether two constant values are equal. If one of them is undefined, this
            function returns undefined.
            </summary>
            <param name="x">The first constant value.</param>
            <param name="y">The second constant value.</param>
            <returns>Bool.Undefined if at least one of two operands is undefined, else
            Bool.True if the first operand is equal to the second operand.</returns>
        </member>
        <member name="M:PDDLParser.Exp.Struct.ConstantExp.Equals(System.Object)">
            <summary>
            Returns true if this ConstantExp is equal to another object.
            </summary>
            <param name="obj">The other object to test for equality.</param>
            <returns>True if this ConstantExp is equal to the other object.</returns>
        </member>
        <member name="M:PDDLParser.Exp.Struct.ConstantExp.GetHashCode">
            <summary>
            Returns the hashcode of this ConstantExp.
            </summary>
            <returns>The hashcode of this ConstantExp.</returns>
        </member>
        <member name="M:PDDLParser.Exp.Struct.ConstantExp.ToString">
            <summary>
            Returns a string representation of this ConstantExp.
            </summary>
            <returns>A string representation of this ConstantExp.</returns>
        </member>
        <member name="M:PDDLParser.Exp.Struct.ConstantExp.ToTypedString">
            <summary>
            Returns a typed string representation of this ConstantExp.
            </summary>
            <returns>A typed string representation of this ConstantExp.</returns>
        </member>
        <member name="M:PDDLParser.Exp.Struct.ConstantExp.CompareTo(PDDLParser.Exp.Struct.ConstantExp)">
            <summary>
            Compares this ConstantExp with another ConstantExp.
            </summary>
            <param name="other">The other ConstantExp to compare this ConstantExp to.
            </param>
            <returns>An integer representing the total order relation between the two ConstantExps.
            </returns>
        </member>
        <member name="P:PDDLParser.Exp.Struct.ConstantExp.Status">
            <summary>
            Returns the status of this ConstantExp.
            </summary>
        </member>
        <member name="P:PDDLParser.Exp.Struct.ConstantExp.Value">
            <summary>
            Returns the inner Constant value of this ConstantExp.
            The value should only be accessed if this ConstantExp is defined.
            </summary>
        </member>
        <member name="T:PDDLParser.Exp.Struct.ConstantExp.State">
            <summary>
            Internal ConstantExp status, which indicates whether the ConstantExp 
            is defined or not.
            </summary>
        </member>
        <member name="F:PDDLParser.Exp.Struct.ConstantExp.State.Defined">
            <summary>
            Indicates that this ConstantExp is defined, and thus its internal Constant
            value can be accessed.
            </summary>
        </member>
        <member name="F:PDDLParser.Exp.Struct.ConstantExp.State.Undefined">
            <summary>
            Indicates that this ConstantExp is undefined.
            </summary>
        </member>
        <member name="T:PDDLParser.Exp.Numeric.TLPlan.NArityExponent">
            <summary>
            This class implements a n-ary exponentiation function.
            This is not part of PDDL; it was rather added for TLPlan.
            </summary>
        </member>
        <member name="M:PDDLParser.Exp.Numeric.TLPlan.NArityExponent.#ctor(System.Collections.Generic.List{PDDLParser.Exp.INumericExp})">
            <summary>
            Creates a new exponentiation function with the specified arguments.
            </summary>
            <param name="args">The arguments of the new exponentiation function.</param>
        </member>
        <member name="M:PDDLParser.Exp.Numeric.TLPlan.NArityExponent.Calculate(System.Double[])">
            <summary>
            Calculates the left-associative power of the arguments.
            </summary>
            <param name="args">The arguments to call the function with.</param>
            <returns>The left-associative power of the arguments.</returns>
            <exception cref="T:PDDLParser.Exception.NumericException">A NumericException is thrown if a negative number
            is exponentiated by a non-integer. Try (expt a (round b)) instead of (expt a b)
            </exception>
        </member>
        <member name="T:PDDLParser.Exp.Numeric.TLPlan.BinaryFunctionExp">
            <summary>
            Base class for binary arithmetic functions.
            </summary>
        </member>
        <member name="M:PDDLParser.Exp.Numeric.TLPlan.BinaryFunctionExp.#ctor(System.String,PDDLParser.Exp.INumericExp,PDDLParser.Exp.INumericExp)">
            <summary>
            Creates a new binary arithmetic function with the two specified arguments.
            </summary>
            <param name="image">The image of the arithmetic function.</param>
            <param name="arg1">The first argument of the new arithmetic function.</param>
            <param name="arg2">The second argument of the new arithmetic function.</param>
        </member>
        <member name="M:PDDLParser.Exp.Numeric.TLPlan.BinaryFunctionExp.Calculate(System.Double,System.Double)">
            <summary>
            Calculates the result of this arithmetic function called with the specified two arguments.
            </summary>
            <param name="arg1">The first argument.</param>
            <param name="arg2">The second argument.</param>
            <returns>The result of the arithmetic function.</returns>
        </member>
        <member name="M:PDDLParser.Exp.Numeric.TLPlan.BinaryFunctionExp.Calculate(System.Double[])">
            <summary>
            Calculates the result of this arithmetic function called with the specified arguments.
            </summary>
            <param name="args">The arguments to call the function with.</param>
            <returns>The result of the arithmetic function.</returns>
        </member>
        <member name="T:PDDLParser.Exp.Logical.NotExp">
            <summary>
            This class represents the negation of an expression.
            </summary>
        </member>
        <member name="M:PDDLParser.Exp.Logical.NotExp.#ctor(PDDLParser.Exp.ILogicalExp)">
            <summary>
            Creates a new negative expression.
            </summary>
            <param name="exp">The expression to negate.</param>
        </member>
        <member name="M:PDDLParser.Exp.Logical.NotExp.Evaluate(PDDLParser.World.IReadOnlyOpenWorld,PDDLParser.Exp.LocalBindings)">
            <summary>
            Evaluates this logical expression in the specified open world.
            </summary>
            <param name="world">The evaluation world.</param>
            <param name="bindings">A set of variable bindings.</param>
            <returns>True, false, undefined, or unknown.</returns>
        </member>
        <member name="M:PDDLParser.Exp.Logical.NotExp.EvaluateWithImmediateShortCircuit(PDDLParser.World.IReadOnlyOpenWorld,PDDLParser.Exp.LocalBindings)">
            <summary>
            Evaluates this logical expression in the specified open world.
            In addition to False, Undefined and Unknown also shortcircuit conjunctions.
            In addition to True, Unknown also shortcircuits disjunctions.
            </summary>
            <param name="world">The evaluation world.</param>
            <param name="bindings">A set of variable bindings.</param>
            <returns>True, false, undefined, or unknown.</returns>
        </member>
        <member name="M:PDDLParser.Exp.Logical.NotExp.Simplify(PDDLParser.World.IReadOnlyOpenWorld,PDDLParser.Exp.LocalBindings)">
            <summary>
            Simplifies this logical expression by evaluating its known expression parts.
            </summary>
            <param name="world">The evaluation world.</param>
            <param name="bindings">A set of variable bindings.</param>
            <returns>True, false, undefined, or the simplified expression.</returns>
        </member>
        <member name="M:PDDLParser.Exp.Logical.NotExp.Evaluate(PDDLParser.World.IReadOnlyClosedWorld,PDDLParser.Exp.LocalBindings)">
            <summary>
            Evaluates this logical expression in the specified closed world.
            </summary>
            <param name="world">The evaluation world.</param>
            <param name="bindings">A set of variable bindings.</param>
            <returns>True, false, or undefined.</returns>
        </member>
        <member name="M:PDDLParser.Exp.Logical.NotExp.EvaluateWithImmediateShortCircuit(PDDLParser.World.IReadOnlyClosedWorld,PDDLParser.Exp.LocalBindings)">
            <summary>
            Evaluates this logical expression in the specified closed world.
            In addition to False, Undefined also shortcircuit conjunctions.
            </summary>
            <param name="world">The evaluation world.</param>
            <param name="bindings">A set of variable bindings.</param>
            <returns>True, false, or undefined.</returns>
        </member>
        <member name="M:PDDLParser.Exp.Logical.NotExp.EnumerateAllSatisfyingWorlds">
            <summary>
            Enumerates all the worlds within which this logical expression evaluates to true.
            This method is used to support the goal modality expressions.
            The worlds satisfying a negative expression correspond to the complement of the set of 
            worlds satisfying the negated expression.
            </summary>
            <returns>All worlds except the ones satisfying the negated expression.</returns>
        </member>
        <member name="M:PDDLParser.Exp.Logical.NotExp.Progress(PDDLParser.World.IReadOnlyDurativeClosedWorld,PDDLParser.Exp.LocalBindings)">
            <summary>
            Evaluates the progression of this constraint expression in the next worlds.
            This function returns false if this constraint expression is not satisfied 
            in the given world;
            it returns true if the progression is always satisfied in the next worlds;
            else it returns the progressed expression.
            </summary>
            <param name="world">The current world.</param>
            <param name="bindings">A set of variable bindings.</param>
            <returns>True, false, undefined, or a progressed expression.</returns>
        </member>
        <member name="M:PDDLParser.Exp.Logical.NotExp.EvaluateIdle(PDDLParser.World.IReadOnlyDurativeClosedWorld,PDDLParser.Exp.LocalBindings)">
            <summary>
            Evaluates this constraint expression in an idle world, i.e. a world which
            won't be modified by further updates.
            </summary>
            <param name="idleWorld">The (idle) evaluation world.</param>
            <param name="bindings">A set of variable bindings.</param>
            <returns>True, false, or undefined.</returns>
        </member>
        <member name="T:PDDLParser.Exp.Logical.ImplyExp">
            <summary>
            This class represents an implication expression.
            </summary>
        </member>
        <member name="T:PDDLParser.Exp.Constraint.AbstractImplyExp`1">
            <summary>
            Base class for implication expressions.
            </summary>
            <typeparam name="T">The type of the expressions.</typeparam>
        </member>
        <member name="F:PDDLParser.Exp.Constraint.AbstractImplyExp`1.m_antecedent">
            <summary>
            The antecedent of the implication expression.
            </summary>
        </member>
        <member name="F:PDDLParser.Exp.Constraint.AbstractImplyExp`1.m_consequent">
            <summary>
            The consequent of the implication expression.
            </summary>
        </member>
        <member name="M:PDDLParser.Exp.Constraint.AbstractImplyExp`1.#ctor(`0,`0)">
            <summary>
            Creates a new implication expression with the specified antecedent and consequent.
            </summary>
            <param name="antecedent">The antecedent of the implication.</param>
            <param name="consequent">The consequent of the implication.</param>
        </member>
        <member name="M:PDDLParser.Exp.Constraint.AbstractImplyExp`1.Apply(PDDLParser.Exp.ParameterBindings)">
            <summary>
            Substitutes all occurrences of the variables that occur in this
            expression by their corresponding bindings.
            </summary>
            <param name="bindings">A set of variable bindings.</param>
            <returns>A substituted copy of this expression.</returns>
        </member>
        <member name="M:PDDLParser.Exp.Constraint.AbstractImplyExp`1.Standardize(System.Collections.Generic.IDictionary{System.String,System.String})">
            <summary>
            Standardizes all occurrences of the variables that occur in this
            expression. Remember that free variables are existentially quantified.
            </summary>
            <param name="images">The object that maps old variable images to the standardize
            image.</param>
            <returns>A standardized copy of this expression.</returns>
        </member>
        <member name="M:PDDLParser.Exp.Constraint.AbstractImplyExp`1.IsGround">
            <summary>
            Returns true if the expression is ground, i.e. it does not contain any variables.
            </summary>
            <returns>Whether the expression is ground.</returns>
        </member>
        <member name="M:PDDLParser.Exp.Constraint.AbstractImplyExp`1.GetFreeVariables">
            <summary>
            Returns the free variables in this expression.
            </summary>
            <returns>The free variables in this expression.</returns>
        </member>
        <member name="M:PDDLParser.Exp.Constraint.AbstractImplyExp`1.Equals(System.Object)">
            <summary>
            Returns true if this expression is equal to a specified object.
            </summary>
            <param name="obj">Object to test for equality.</param>
            <returns>True if this expression is equal to the specified objet.</returns>
        </member>
        <member name="M:PDDLParser.Exp.Constraint.AbstractImplyExp`1.GetHashCode">
            <summary>
            Returns the hash code of this expression.
            </summary>
            <returns>The hash code of this expression.</returns>
        </member>
        <member name="M:PDDLParser.Exp.Constraint.AbstractImplyExp`1.ToString">
            <summary>
            Returns a string representation of this expression.
            </summary>
            <returns>A string representation of this expression.</returns>
        </member>
        <member name="M:PDDLParser.Exp.Constraint.AbstractImplyExp`1.ToTypedString">
            <summary>
            Returns a typed string representation of this expression.
            </summary>
            <returns>A typed string representation of this expression.</returns>
        </member>
        <member name="M:PDDLParser.Exp.Constraint.AbstractImplyExp`1.CompareTo(PDDLParser.Exp.IExp)">
            <summary>
            Compares this expression with another expression.
            </summary>
            <param name="other">The other expression to compare this expression to.</param>
            <returns>An integer representing the total order relation between the two expressions.</returns>
        </member>
        <member name="M:PDDLParser.Exp.Logical.ImplyExp.#ctor(PDDLParser.Exp.ILogicalExp,PDDLParser.Exp.ILogicalExp)">
            <summary>
            Creates a new implication expression with the specified antecedent and consequent.
            </summary>
            <param name="antecedent">The antecedent of the implication.</param>
            <param name="consequent">The consequent of the implication.</param>
        </member>
        <member name="M:PDDLParser.Exp.Logical.ImplyExp.Evaluate(PDDLParser.World.IReadOnlyOpenWorld,PDDLParser.Exp.LocalBindings)">
            <summary>
            Evaluates this logical expression in the specified open world.
            </summary>
            <param name="world">The evaluation world.</param>
            <param name="bindings">A set of variable bindings.</param>
            <returns>True, false, undefined, or unknown.</returns>
        </member>
        <member name="M:PDDLParser.Exp.Logical.ImplyExp.EvaluateWithImmediateShortCircuit(PDDLParser.World.IReadOnlyOpenWorld,PDDLParser.Exp.LocalBindings)">
            <summary>
            Evaluates this logical expression in the specified open world.
            In addition to False, Undefined and Unknown also shortcircuit conjunctions.
            In addition to True, Unknown also shortcircuits disjunctions.
            </summary>
            <param name="world">The evaluation world.</param>
            <param name="bindings">A set of variable bindings.</param>
            <returns>True, false, undefined, or unknown.</returns>
        </member>
        <member name="M:PDDLParser.Exp.Logical.ImplyExp.Simplify(PDDLParser.World.IReadOnlyOpenWorld,PDDLParser.Exp.LocalBindings)">
            <summary>
            Simplifies this logical expression by evaluating its known expression parts.
            </summary>
            <param name="world">The evaluation world.</param>
            <param name="bindings">A set of variable bindings.</param>
            <returns>True, false, undefined, or the simplified expression.</returns>
        </member>
        <member name="M:PDDLParser.Exp.Logical.ImplyExp.Evaluate(PDDLParser.World.IReadOnlyClosedWorld,PDDLParser.Exp.LocalBindings)">
            <summary>
            Evaluates this logical expression in the specified closed world.
            </summary>
            <param name="world">The evaluation world.</param>
            <param name="bindings">A set of variable bindings.</param>
            <returns>True, false, or undefined.</returns>
        </member>
        <member name="M:PDDLParser.Exp.Logical.ImplyExp.EvaluateWithImmediateShortCircuit(PDDLParser.World.IReadOnlyClosedWorld,PDDLParser.Exp.LocalBindings)">
            <summary>
            Evaluates this logical expression in the specified closed world.
            In addition to False, Undefined also shortcircuit conjunctions.
            </summary>
            <param name="world">The evaluation world.</param>
            <param name="bindings">A set of variable bindings.</param>
            <returns>True, false, or undefined.</returns>
        </member>
        <member name="M:PDDLParser.Exp.Logical.ImplyExp.EnumerateAllSatisfyingWorlds">
            <summary>
            Enumerates all the worlds within which this logical expression evaluates to true.
            This method is used to support the goal modality expressions.
            </summary>
            <returns>All the worlds satisfying this logical expression.</returns>
        </member>
        <member name="M:PDDLParser.Exp.Logical.ImplyExp.GenerateEquivalentExp">
            <summary>
            Creates a new ground expression equivalent to this implication expression.
            </summary>
            <returns>A new ground expression equivalent to this implication expression.</returns>
        </member>
        <member name="M:PDDLParser.Exp.Logical.ImplyExp.Progress(PDDLParser.World.IReadOnlyDurativeClosedWorld,PDDLParser.Exp.LocalBindings)">
            <summary>
            Evaluates the progression of this constraint expression in the next worlds.
            This function returns false if this constraint expression is not satisfied 
            in the given world;
            it returns true if the progression is always satisfied in the next worlds;
            else it returns the progressed expression.
            </summary>
            <param name="world">The current world.</param>
            <param name="bindings">A set of variable bindings.</param>
            <returns>True, false, undefined, or a progressed expression.</returns>
        </member>
        <member name="M:PDDLParser.Exp.Logical.ImplyExp.EvaluateIdle(PDDLParser.World.IReadOnlyDurativeClosedWorld,PDDLParser.Exp.LocalBindings)">
            <summary>
            Evaluates this constraint expression in an idle world, i.e. a world which
            won't be modified by further updates.
            </summary>
            <param name="idleWorld">The (idle) evaluation world.</param>
            <param name="bindings">A set of variable bindings.</param>
            <returns>True, false, or undefined.</returns>
        </member>
        <member name="T:PDDLParser.Exp.Effect.Assign.ScaleDown">
            <summary>
            This class represents a fluent scale-down operation.
            </summary>
        </member>
        <member name="M:PDDLParser.Exp.Effect.Assign.ScaleDown.#ctor(PDDLParser.Exp.Formula.NumericFluentApplication,PDDLParser.Exp.INumericExp)">
            <summary>
            Creates a new fluent scale-down operation.
            </summary>
            <param name="head">The numeric fluent whose value is to be scaled down.</param>
            <param name="body">The numeric value to scale down the fluent by.</param>
        </member>
        <member name="M:PDDLParser.Exp.Effect.Assign.ScaleDown.UpdateWorldWithAssignEffect(PDDLParser.Exp.Formula.FluentApplication,PDDLParser.World.IDurativeOpenWorld,PDDLParser.Exp.LocalBindings)">
            <summary>
            Updates the world with this fluent assignment.
            </summary>
            <param name="head">The evaluated fluent application to update.</param>
            <param name="updateWorld">The world to update.</param>
            <param name="bindings">A set of variable bindings.</param>
        </member>
        <member name="T:PDDLParser.Exp.Constraint.TLPlan.UntilExp">
            <summary>
            Represents the "until" operator of the LTL language. This is not part of PDDL; it was rather added
            for TLPlan.
            </summary>
        </member>
        <member name="M:PDDLParser.Exp.Constraint.TLPlan.UntilExp.#ctor(PDDLParser.Exp.IConstraintExp,PDDLParser.Exp.IConstraintExp)">
            <summary>
            Creates a new "until" constraint expression.
            </summary>
            <param name="arg1">The first expression, which must always be true until the second one is.</param>
            <param name="arg2">The second expression. When this one becomes true, the value of the first one
            becomes irrelevant. Note that the second expression must become true before the end of the trajectory.</param>
        </member>
        <member name="M:PDDLParser.Exp.Constraint.TLPlan.UntilExp.Progress(PDDLParser.World.IReadOnlyDurativeClosedWorld,PDDLParser.Exp.LocalBindings)">
            <summary>
            Evaluates the progression of this constraint expression in the next worlds.
            </summary>
            <param name="world">The current world.</param>
            <param name="bindings">A set of variable bindings.</param>
            <returns>True, false, undefined, or a progressed expression.</returns>
            <exception cref="T:PDDLParser.Exception.BindingException">A BindingException is thrown if an attempt
            is made to evaluate an unbound variable.</exception>
            <seealso cref="M:PDDLParser.Exp.IConstraintExp.Progress(PDDLParser.World.IReadOnlyDurativeClosedWorld,PDDLParser.Exp.LocalBindings)"/>
        </member>
        <member name="M:PDDLParser.Exp.Constraint.TLPlan.UntilExp.EvaluateIdle(PDDLParser.World.IReadOnlyDurativeClosedWorld,PDDLParser.Exp.LocalBindings)">
            <summary>
            Evaluates this constraint expression in an idle world, i.e. a world which
            won't be modified by further updates.
            </summary>
            <param name="idleWorld">The (idle) evaluation world.</param>
            <param name="bindings">A set of variable bindings.</param>
            <returns>True, false, or undefined.</returns>
            <exception cref="T:PDDLParser.Exception.BindingException">A BindingException is thrown if an attempt
            is made to evaluate an unbound variable.</exception>
            <seealso cref="M:PDDLParser.Exp.IConstraintExp.EvaluateIdle(PDDLParser.World.IReadOnlyDurativeClosedWorld,PDDLParser.Exp.LocalBindings)"/>
        </member>
        <member name="M:PDDLParser.Exp.Constraint.TLPlan.UntilExp.ToString">
            <summary>
            Returns a string representation of this expression.
            </summary>
            <returns>A string representation of this expression.</returns>
        </member>
        <member name="M:PDDLParser.Exp.Constraint.TLPlan.UntilExp.ToTypedString">
            <summary>
            Returns a typed string of this expression.
            </summary>
            <returns>A typed string representation of this expression.</returns>
        </member>
        <member name="T:PDDLParser.Exp.Constraint.OrConstraintExp">
            <summary>
            Represents a disjunction of constraint expressions.
            </summary>
        </member>
        <member name="M:PDDLParser.Exp.Constraint.OrConstraintExp.#ctor(System.Collections.Generic.IEnumerable{PDDLParser.Exp.IConstraintExp})">
            <summary>
            Creates a new disjunction of constraint expressions.
            </summary>
            <param name="exps">The constraint expressions associated with the new disjunctive
            expression.</param>
        </member>
        <member name="M:PDDLParser.Exp.Constraint.OrConstraintExp.#ctor(PDDLParser.Exp.IConstraintExp[])">
            <summary>
            Creates a new disjunction of constraint expressions.
            </summary>
            <param name="exps">The constraint expressions associated with the new disjunctive
            expression.</param>
        </member>
        <member name="M:PDDLParser.Exp.Constraint.OrConstraintExp.Progress(PDDLParser.World.IReadOnlyDurativeClosedWorld,PDDLParser.Exp.LocalBindings)">
            <summary>
            Evaluates the progression of this constraint expression in the next worlds.
            The algorithm is: Progress(or formula1 ...) =&gt; (or Progress(formula1) ...)
            </summary>
            <param name="world">The current world.</param>
            <param name="bindings">A set of variable bindings.</param>
            <returns>True, false, undefined, or a progressed expression.</returns>
            <exception cref="T:PDDLParser.Exception.BindingException">A BindingException is thrown if an attempt
            is made to evaluate an unbound variable.</exception>
            <seealso cref="M:PDDLParser.Exp.IConstraintExp.Progress(PDDLParser.World.IReadOnlyDurativeClosedWorld,PDDLParser.Exp.LocalBindings)"/>
        </member>
        <member name="M:PDDLParser.Exp.Constraint.OrConstraintExp.EvaluateIdle(PDDLParser.World.IReadOnlyDurativeClosedWorld,PDDLParser.Exp.LocalBindings)">
            <summary>
            Evaluates this constraint expression in an idle world, i.e. a world which
            won't be modified by further updates.
            </summary>
            <param name="idleWorld">The (idle) evaluation world.</param>
            <param name="bindings">A set of variable bindings.</param>
            <returns>True, false, or undefined.</returns>
            <exception cref="T:PDDLParser.Exception.BindingException">A BindingException is thrown if an attempt
            is made to evaluate an unbound variable.</exception>
            <seealso cref="M:PDDLParser.Exp.IConstraintExp.EvaluateIdle(PDDLParser.World.IReadOnlyDurativeClosedWorld,PDDLParser.Exp.LocalBindings)"/>
        </member>
        <member name="T:PDDLParser.Exception.UnknownExpException">
            <summary>
            An UnknownExpException is thrown if an attempt is made to set to retrieve the value 
            of an undefined expression.
            </summary>
        </member>
        <member name="M:PDDLParser.Exception.UnknownExpException.#ctor(System.String)">
            <summary>
            Creates a new UnknownExpException with a specific message.
            </summary>
            <param name="message">The exception message.</param>
        </member>
        <member name="T:PDDLParser.Exp.ParameterBindings">
            <summary>
            This class represents a set of (object) parameter variable bindings.
            </summary>
        </member>
        <member name="F:PDDLParser.Exp.ParameterBindings.m_parameterBindings">
            <summary>
            The set of parameter bindings. Note that parameter variables cannot be bound 
            to an undefined value.
            </summary>
        </member>
        <member name="M:PDDLParser.Exp.ParameterBindings.#ctor">
            <summary>
            Creates a new empty set of parameter bindings.
            </summary>
        </member>
        <member name="M:PDDLParser.Exp.ParameterBindings.GetBinding(PDDLParser.Exp.Term.ObjectParameterVariable)">
            <summary>
            Returns the constant value associated with the specified parameter variable.
            </summary>
            <param name="var">The parameter variable for which the binding must be retrieved.
            </param>
            <returns>The constant value associated with the parameter variable.</returns>
            <exception cref="T:PDDLParser.Exception.BindingException">A BindingException is thrown if the
            specified parameter variable is not bound.</exception>
        </member>
        <member name="M:PDDLParser.Exp.ParameterBindings.TryGetBinding(PDDLParser.Exp.Term.ObjectParameterVariable,PDDLParser.Exp.Term.Constant@)">
            <summary>
            Retrieves the constant value associated with the specified parameter variable.
            This function returns true if the specified parameter variable is bound, else
            it returns false and the returned binding is not defined.
            </summary>
            <param name="var">The parameter variable for which the binding must be retrieved.
            </param>
            <param name="binding">If found, returns the constant value associated with the
            parameter variable.</param>
            <returns>True if the specified parameter variable is bound.</returns>
        </member>
        <member name="M:PDDLParser.Exp.ParameterBindings.Bind(PDDLParser.Exp.Term.ObjectParameterVariable,PDDLParser.Exp.Term.Constant)">
            <summary>
            Binds a parameter variable to a specified constant value.
            </summary>
            <param name="var">The parameter variable to bind.</param>
            <param name="value">The constant to bind this variable to.</param>
        </member>
        <member name="M:PDDLParser.Exp.ParameterBindings.Clone">
            <summary>
            Returns a clone of this set of parameter bindings.
            </summary>
            <returns>A clone of this set of parameter bindings.</returns>
        </member>
        <member name="M:PDDLParser.Exp.ParameterBindings.Equals(System.Object)">
            <summary>
            Returns whether this set of parameter bindings is equal to another object.
            </summary>
            <param name="obj">The other object to compare this set of bindings to.</param>
            <returns>True if this set of parameter bindings is equal to another object.</returns>
        </member>
        <member name="M:PDDLParser.Exp.ParameterBindings.GetHashCode">
            <summary>
            Returns the hash code of this set of parameter bindings.
            </summary>
            <returns>The hash code of this set of parameter bindings.</returns>
        </member>
        <member name="M:PDDLParser.Exp.ParameterBindings.ToString">
            <summary>
            Returns a string representation of this set of parameter bindings.
            </summary>
            <returns>A string representation of this set of parameter bindings.</returns>
        </member>
        <member name="M:PDDLParser.Exp.ParameterBindings.ToTypedString">
            <summary>
            Returns a typed string representation of this set of parameter variables.
            </summary>
            <returns>A typed string representation of this set of parameter variables.</returns>
        </member>
        <member name="T:PDDLParser.Exp.Metric.ConstraintPrefExp">
            <summary>
            Represents a constraint preference expression of the PDDL language, i.e. a preference
            that lies in a domain or a problem's constraints.
            </summary>
        </member>
        <member name="F:PDDLParser.Exp.Metric.ConstraintPrefExp.m_atom">
            <summary>
            The associated <see cref="T:PDDLParser.Exp.Formula.AtomicFormulaApplication"/> 
            which tracks whether this preference is violated.
            </summary>
        </member>
        <member name="M:PDDLParser.Exp.Metric.ConstraintPrefExp.#ctor(System.String,PDDLParser.Exp.IConstraintExp,PDDLParser.Exp.Formula.AtomicFormulaApplication,System.Boolean)">
            <summary>
            Creates a new constraint preference expression.
            </summary>
            <param name="name">The preference's name.</param>
            <param name="exp">The preference's body.</param>
            <param name="atom">The <see cref="T:PDDLParser.Exp.Formula.AtomicFormulaApplication"/> 
            which tracks whether this preference is violated.</param>
            <param name="unnamed">Whether this preference is unnamed.</param>
        </member>
        <member name="M:PDDLParser.Exp.Metric.ConstraintPrefExp.#ctor(System.String,PDDLParser.Exp.IConstraintExp,PDDLParser.Exp.Formula.AtomicFormulaApplication)">
            <summary>
            Creates a new named constraint preference expression.
            </summary>
            <param name="name">The preference's name.</param>
            <param name="exp">The preference's body.</param>
            <param name="atom">The <see cref="T:PDDLParser.Exp.Formula.AtomicFormulaApplication"/> 
            which tracks whether this preference is violated.</param>
        </member>
        <member name="M:PDDLParser.Exp.Metric.ConstraintPrefExp.GetDummyAtomicFormula">
            <summary>
            Returns the preference's corresponding dummy literal, which is used to determine whether the preference has been violated.
            </summary>
            <returns>The preference's corresponding violation literal.</returns>
        </member>
        <member name="M:PDDLParser.Exp.Metric.ConstraintPrefExp.GetViolationEffect">
            <summary>
            Returns the effect which must be applied to the world if the preference is violated.
            </summary>
            <remarks>This is only setting a given literal to true.</remarks>
            <returns>The effect to apply to the world upon violation of the preference.</returns>
        </member>
        <member name="M:PDDLParser.Exp.Metric.ConstraintPrefExp.GetAllSubstitutedConstraintPreferences">
            <summary>
            Returns all substituted preferences, in their simplest form. This will therefore expand preference quantifiers.
            </summary>
            <returns>An enumerable containing only this preference.</returns>
            <seealso cref="M:PDDLParser.Exp.IConstraintPrefExp.GetAllSubstitutedConstraintPreferences"/>
        </member>
        <member name="P:PDDLParser.Exp.Metric.ConstraintPrefExp.Constraint">
            <summary>
            Gets or sets the constraint of the preference (i.e. the preference's "body"). Setting this property should only be used in
            order to update the preference's constraint with its progressed form.
            </summary>
        </member>
        <member name="T:PDDLParser.Exp.Logical.TLPlan.XorUniqueExp">
            <summary>
            This class represents an exclusive disjunction (XOR!) of logical expressions.
            This is not part of PDDL; it was rather added for TLPlan.
            </summary>
            <remarks>
            PLEASE NOTE that this implementation of an n-ary xor returns
            true iff only one of its arguments is true (as is done in the
            original TLPlan). Thus its truth value can be calculated 
            independently from its false operands;
            for example: (xor T F F) = (xor T)
            
            This is different from another definition of n-ary xor which
            returns true iff an odd number of its arguments are true. 
            </remarks>
        </member>
        <member name="M:PDDLParser.Exp.Logical.TLPlan.XorUniqueExp.#ctor(System.Collections.Generic.IEnumerable{PDDLParser.Exp.ILogicalExp})">
            <summary>
            Creates a new exclusive disjunction of logical expressions.
            </summary>
            <param name="exps">The logical expressions associated with the new exclusive 
            disjunction expression.</param>
        </member>
        <member name="M:PDDLParser.Exp.Logical.TLPlan.XorUniqueExp.#ctor(PDDLParser.Exp.ILogicalExp[])">
            <summary>
            Creates a new exclusive disjunction of logical expressions.
            </summary>
            <param name="exps">The logical expressions associated with the new exclusive 
            disjunction expression.</param>
        </member>
        <member name="M:PDDLParser.Exp.Logical.TLPlan.XorUniqueExp.Evaluate(PDDLParser.World.IReadOnlyOpenWorld,PDDLParser.Exp.LocalBindings)">
            <summary>
            Evaluates this logical expression in the specified open world.
            </summary>
            <param name="world">The evaluation world.</param>
            <param name="bindings">A set of variable bindings.</param>
            <returns>True, false, undefined, or unknown.</returns>
        </member>
        <member name="M:PDDLParser.Exp.Logical.TLPlan.XorUniqueExp.EvaluateWithImmediateShortCircuit(PDDLParser.World.IReadOnlyOpenWorld,PDDLParser.Exp.LocalBindings)">
            <summary>
            Evaluates this logical expression in the specified open world.
            In addition to False, Undefined and Unknown also shortcircuit conjunctions.
            In addition to True, Unknown also shortcircuits disjunctions.
            </summary>
            <param name="world">The evaluation world.</param>
            <param name="bindings">A set of variable bindings.</param>
            <returns>True, false, undefined, or unknown.</returns>
        </member>
        <member name="M:PDDLParser.Exp.Logical.TLPlan.XorUniqueExp.Simplify(PDDLParser.World.IReadOnlyOpenWorld,PDDLParser.Exp.LocalBindings)">
            <summary>
            Simplifies this logical expression by evaluating its known expression parts.
            </summary>
            <param name="world">The evaluation world.</param>
            <param name="bindings">A set of variable bindings.</param>
            <returns>True, false, undefined, or the simplified expression.</returns>
        </member>
        <member name="M:PDDLParser.Exp.Logical.TLPlan.XorUniqueExp.Evaluate(PDDLParser.World.IReadOnlyClosedWorld,PDDLParser.Exp.LocalBindings)">
            <summary>
            Evaluates this logical expression in the specified closed world.
            </summary>
            <param name="world">The evaluation world.</param>
            <param name="bindings">A set of variable bindings.</param>
            <returns>True, false, or undefined.</returns>
        </member>
        <member name="M:PDDLParser.Exp.Logical.TLPlan.XorUniqueExp.EvaluateWithImmediateShortCircuit(PDDLParser.World.IReadOnlyClosedWorld,PDDLParser.Exp.LocalBindings)">
            <summary>
            Evaluates this logical expression in the specified closed world.
            The bindings should not be modified by this call.
            In addition to False, Undefined also shortcircuit conjunctions.
            This function is used to evaluate defined formulas' body as is done in the
            original TLPlan.
            </summary>
            <param name="world">The evaluation world.</param>
            <param name="bindings">A set of variable bindings.</param>
            <returns>True, false, or undefined.</returns>
        </member>
        <member name="M:PDDLParser.Exp.Logical.TLPlan.XorUniqueExp.EnumerateAllSatisfyingWorlds">
            <summary>
            Enumerates all the worlds within which this logical expression evaluates to true.
            This method is used to support the goal modality expressions.
            </summary>
            <returns>All the worlds satisfying this logical expression.</returns>
        </member>
        <member name="M:PDDLParser.Exp.Logical.TLPlan.XorUniqueExp.GenerateEquivalentExp">
            <summary>
            Creates a new ground expression equivalent to this exclusive disjunction expression.
            </summary>
            <returns>A new ground expression equivalent to this exclusive disjunction expression.
            </returns>
        </member>
        <member name="M:PDDLParser.Exp.Logical.TLPlan.XorUniqueExp.Progress(PDDLParser.World.IReadOnlyDurativeClosedWorld,PDDLParser.Exp.LocalBindings)">
            <summary>
            Evaluates the progression of this constraint expression in the next worlds.
            This function returns false if this constraint expression is not satisfied 
            in the given world;
            it returns true if the progression is always satisfied in the next worlds;
            else it returns the progressed expression.
            </summary>
            <param name="world">The current world.</param>
            <param name="bindings">A set of variable bindings.</param>
            <returns>True, false, undefined, or a progressed expression.</returns>
        </member>
        <member name="M:PDDLParser.Exp.Logical.TLPlan.XorUniqueExp.EvaluateIdle(PDDLParser.World.IReadOnlyDurativeClosedWorld,PDDLParser.Exp.LocalBindings)">
            <summary>
            Evaluates this constraint expression in an idle world, i.e. a world which
            won't be modified by further updates.
            </summary>
            <param name="idleWorld">The (idle) evaluation world.</param>
            <param name="bindings">A set of variable bindings.</param>
            <returns>True, false, or undefined.</returns>
        </member>
        <member name="T:PDDLParser.Exp.Effect.Assign.ScaleUp">
            <summary>
            This class represents a fluent scale-up operation.
            </summary>
        </member>
        <member name="M:PDDLParser.Exp.Effect.Assign.ScaleUp.#ctor(PDDLParser.Exp.Formula.NumericFluentApplication,PDDLParser.Exp.INumericExp)">
            <summary>
            Creates a new fluent scale-up operation.
            </summary>
            <param name="head">The numeric fluent whose value is to be scaled up.</param>
            <param name="body">The numeric value to scale up the fluent by.</param>
        </member>
        <member name="M:PDDLParser.Exp.Effect.Assign.ScaleUp.UpdateWorldWithAssignEffect(PDDLParser.Exp.Formula.FluentApplication,PDDLParser.World.IDurativeOpenWorld,PDDLParser.Exp.LocalBindings)">
            <summary>
            Updates the world with this fluent assignment.
            </summary>
            <param name="head">The evaluated fluent application to update.</param>
            <param name="updateWorld">The world to update.</param>
            <param name="bindings">A set of variable bindings.</param>
        </member>
        <member name="T:PDDLParser.Exp.Constraint.TLPlan.AbsoluteTUntilExp">
            <summary>
            Represents the "t-until" constraint expression. This is a time-bounded version of
            TLPlan's "until" constraint expression. This is not part of the PDDL language;
            it was rather added for TLPlan.
            This constraint expression uses absolute timestamps.
            </summary>
            <remarks>
            This object should only be created by <see cref="T:PDDLParser.Exp.Constraint.TLPlan.TUntilExp"/> constraint expressions.
            </remarks>
            <seealso cref="T:PDDLParser.Exp.Constraint.TLPlan.TUntilExp"/>
            <seealso cref="T:PDDLParser.Exp.Constraint.TLPlan.UntilExp"/>
        </member>
        <member name="M:PDDLParser.Exp.Constraint.TLPlan.AbsoluteTUntilExp.#ctor(PDDLParser.Exp.Struct.TimeInterval,PDDLParser.Exp.IConstraintExp,PDDLParser.Exp.IConstraintExp)">
            <summary>
            Creates a new "t-until" constraint expression with absolute timestamps.
            </summary>
            <param name="absoluteInterval">The absolute interval.</param>
            <param name="arg1">The first expression, which must always be true until the second one is.</param>
            <param name="arg2">The second expression. The second expression has to become true within the interval.
            When this one becomes true, the value of the first one becomes irrelevant. Note that the second 
            expression must become true before the end of the trajectory.</param>
        </member>
        <member name="M:PDDLParser.Exp.Constraint.TLPlan.AbsoluteTUntilExp.Progress(PDDLParser.World.IReadOnlyDurativeClosedWorld,PDDLParser.Exp.LocalBindings)">
            <summary>
            Evaluates the progression of this constraint expression in the next worlds.
            </summary>
            <param name="world">The current world.</param>
            <param name="bindings">A set of variable bindings.</param>
            <returns>True, false, undefined, or a progressed expression.</returns>
            <exception cref="T:PDDLParser.Exception.BindingException">A BindingException is thrown if an attempt
            is made to evaluate an unbound variable.</exception>
            <seealso cref="M:PDDLParser.Exp.IConstraintExp.Progress(PDDLParser.World.IReadOnlyDurativeClosedWorld,PDDLParser.Exp.LocalBindings)"/>
        </member>
        <member name="M:PDDLParser.Exp.Constraint.TLPlan.AbsoluteTUntilExp.EvaluateIdle(PDDLParser.World.IReadOnlyDurativeClosedWorld,PDDLParser.Exp.LocalBindings)">
            <summary>
            Evaluates this constraint expression in an idle world, i.e. a world which
            won't be modified by further updates.
            </summary>
            <param name="idleWorld">The (idle) evaluation world.</param>
            <param name="bindings">A set of variable bindings.</param>
            <returns>True, false, or undefined.</returns>
            <exception cref="T:PDDLParser.Exception.BindingException">A BindingException is thrown if an attempt
            is made to evaluate an unbound variable.</exception>
            <seealso cref="M:PDDLParser.Exp.IConstraintExp.EvaluateIdle(PDDLParser.World.IReadOnlyDurativeClosedWorld,PDDLParser.Exp.LocalBindings)"/>
        </member>
        <member name="P:PDDLParser.Exp.Constraint.TLPlan.AbsoluteTUntilExp.AbsoluteTimeInterval">
            <summary>
            Gets the absolute time interval.
            </summary>
        </member>
        <member name="T:PDDLParser.Exp.Constraint.SometimeBeforeExp">
            <summary>
            Represents the "sometime-before" constraint expression of the PDDL language.
            </summary>
            <remarks>
            On the goal world, this constraint expression will evaluate to true even if
            the "before" expression was never true when the other expression was never
            true either.
            </remarks>
            <seealso cref="T:PDDLParser.Exp.Constraint.TLPlan.WeakUntilExp"/>
            <seealso cref="T:PDDLParser.Exp.Constraint.AndConstraintExp"/>
            <seealso cref="T:PDDLParser.Exp.Constraint.NotConstraintExp"/>
        </member>
        <member name="F:PDDLParser.Exp.Constraint.SometimeBeforeExp.m_exp">
            <summary>
            The main constraint expression which happens second.
            </summary>
        </member>
        <member name="F:PDDLParser.Exp.Constraint.SometimeBeforeExp.m_beforeExp">
            <summary>
            The constraint expression which must happen first.
            </summary>
        </member>
        <member name="M:PDDLParser.Exp.Constraint.SometimeBeforeExp.#ctor(PDDLParser.Exp.IConstraintExp,PDDLParser.Exp.IConstraintExp)">
            <summary>
            Creates a new "sometime-before" constraint expression.
            </summary>
            <param name="exp">The expression that must happen second.</param>
            <param name="beforeExp">The expression that must happen first.</param>
        </member>
        <member name="M:PDDLParser.Exp.Constraint.SometimeBeforeExp.GenerateEquivalentExp">
            <summary>
            Generates and returns the compound constraint expression equivalent to this expression.
            In this case, (sometime-before a b) = (weak-until (and ¬a ¬b) (and b ¬a))
            </summary>
            <returns>An equivalent constraint expression to this expression.</returns>
            <seealso cref="T:PDDLParser.Exp.Constraint.TLPlan.WeakUntilExp"/>
            <seealso cref="T:PDDLParser.Exp.Constraint.AndConstraintExp"/>
            <seealso cref="T:PDDLParser.Exp.Constraint.NotConstraintExp"/>
        </member>
        <member name="M:PDDLParser.Exp.Constraint.SometimeBeforeExp.Apply(PDDLParser.Exp.ParameterBindings)">
            <summary>
            Substitutes all occurrences of the variables that occur in this
            expression by their corresponding bindings.
            The base implementation is to simply clone the object.
            </summary>
            <param name="bindings">The bindings.</param>
            <returns>A substituted copy of this expression.</returns>
        </member>
        <member name="M:PDDLParser.Exp.Constraint.SometimeBeforeExp.Standardize(System.Collections.Generic.IDictionary{System.String,System.String})">
            <summary>
            Standardizes all occurrences of the variables that occur in this
            expression. The IDictionary argument is used to store the variable already
            standardized. Remember that free variables are existentially quantified.
            The base implementation is to simply clone the object.
            </summary>
            <param name="images">The object that maps old variable images to the standardize
            image.</param>
            <returns>A standardized copy of this expression.</returns>
        </member>
        <member name="M:PDDLParser.Exp.Constraint.SometimeBeforeExp.Equals(System.Object)">
            <summary>
            Returns true if this expression is equal to a specified object.
            </summary>
            <param name="obj">Object to test for equality.</param>
            <returns>True if this expression is equal to the specified objet.</returns>
        </member>
        <member name="M:PDDLParser.Exp.Constraint.SometimeBeforeExp.GetHashCode">
            <summary>
            Returns the hash code of this expression.
            </summary>
            <returns>The hash code of this expression.</returns>
        </member>
        <member name="M:PDDLParser.Exp.Constraint.SometimeBeforeExp.ToString">
            <summary>
            Returns a string representation of this expression.
            </summary>
            <returns>A string representation of this expression.</returns>
        </member>
        <member name="M:PDDLParser.Exp.Constraint.SometimeBeforeExp.ToTypedString">
            <summary>
            Returns a typed string of this expression.
            </summary>
            <returns>A typed string representation of this expression.</returns>
        </member>
        <member name="M:PDDLParser.Exp.Constraint.SometimeBeforeExp.CompareTo(PDDLParser.Exp.IExp)">
            <summary>
            Compares this abstract expression with another expression.
            </summary>
            <param name="other">The other expression to compare this abstract expression to.</param>
            <returns>An integer representing the total order relation between the two expressions.</returns>
        </member>
        <member name="T:PDDLParser.Exp.Constraint.ForallConstraintExp">
            <summary>
            Represents a universal quantification of an expression.
            </summary>
        </member>
        <member name="M:PDDLParser.Exp.Constraint.ForallConstraintExp.#ctor(System.Collections.Generic.HashSet{PDDLParser.Exp.Term.ObjectParameterVariable},PDDLParser.Exp.IConstraintExp)">
            <summary>
            Creates a new universal expression with the given quantified variables and 
            constraint expression.
            </summary>
            <param name="vars">The quantified variables.</param>
            <param name="exp">The quantified expression</param>
        </member>
        <member name="M:PDDLParser.Exp.Constraint.ForallConstraintExp.GenerateEquivalentExp">
            <summary>
            Creates a new ground expression equivalent to this quantified expression.
            </summary>
            <returns>A new ground expression equivalent to this quantified expression.</returns>
        </member>
        <member name="M:PDDLParser.Exp.Constraint.ForallConstraintExp.Progress(PDDLParser.World.IReadOnlyDurativeClosedWorld,PDDLParser.Exp.LocalBindings)">
            <summary>
            Evaluates the progression of this constraint expression in the next worlds.
            </summary>
            <param name="world">The current world.</param>
            <param name="bindings">A set of variable bindings.</param>
            <returns>True, false, undefined, or a progressed expression.</returns>
            <exception cref="T:PDDLParser.Exception.BindingException">A BindingException is thrown if an attempt
            is made to evaluate an unbound variable.</exception>
            <seealso cref="M:PDDLParser.Exp.IConstraintExp.Progress(PDDLParser.World.IReadOnlyDurativeClosedWorld,PDDLParser.Exp.LocalBindings)"/>
        </member>
        <member name="M:PDDLParser.Exp.Constraint.ForallConstraintExp.EvaluateIdle(PDDLParser.World.IReadOnlyDurativeClosedWorld,PDDLParser.Exp.LocalBindings)">
            <summary>
            Evaluates this constraint expression in an idle world, i.e. a world which
            won't be modified by further updates.
            </summary>
            <param name="idleWorld">The (idle) evaluation world.</param>
            <param name="bindings">A set of variable bindings.</param>
            <returns>True, false, or undefined.</returns>
            <exception cref="T:PDDLParser.Exception.BindingException">A BindingException is thrown if an attempt
            is made to evaluate an unbound variable.</exception>
            <seealso cref="M:PDDLParser.Exp.IConstraintExp.EvaluateIdle(PDDLParser.World.IReadOnlyDurativeClosedWorld,PDDLParser.Exp.LocalBindings)"/>
        </member>
        <member name="T:PDDLParser.Parser.IProblem">
            <summary>
            This (incomplete) interface lists the attributes and functions available from a domain.
            </summary>
        </member>
        <member name="P:PDDLParser.Parser.IProblem.Requirements">
            <summary>
            Returns all the requirements necessary to parse this problem.
            </summary>
        </member>
        <member name="P:PDDLParser.Parser.IProblem.Constants">
            <summary>
            Returns all constants defined in this problem.
            </summary>
        </member>
        <member name="P:PDDLParser.Parser.IProblem.Metric">
            <summary>
            Returns the metric defined in this problem.
            </summary>
        </member>
        <member name="P:PDDLParser.Parser.IProblem.Goal">
            <summary>
            Returns the goal formulation of this problem.
            </summary>
        </member>
        <member name="P:PDDLParser.Parser.IProblem.InitialWorld">
            <summary>
            Returns the list of initial elements present in this problem.
            </summary>
        </member>
        <member name="P:PDDLParser.Parser.IProblem.ProblemFile">
            <summary>
            Returns the file in which this problem is defined.
            </summary>
        </member>
        <member name="P:PDDLParser.Parser.IProblem.ProblemName">
            <summary>
            Returns the name of this problem.
            </summary>
        </member>
        <member name="P:PDDLParser.Parser.IProblem.DomainName">
            <summary>
            Returns the name of the domain to which this problem refers.
            </summary>
        </member>
        <member name="T:PDDLParser.Exp.Term.Type.TypeSetSet">
            <summary>
            Represents a set of typesets. A single instance of this class contains all the types defined
            in a full problem (i.e. a parsed and linked domain/problem pair).
            </summary>
        </member>
        <member name="F:PDDLParser.Exp.Term.Type.TypeSetSet.m_types">
            <summary>
            All existing types.
            </summary>
        </member>
        <member name="F:PDDLParser.Exp.Term.Type.TypeSetSet.m_typeSets">
            <summary>
            All existing typesets.
            </summary>
        </member>
        <member name="F:PDDLParser.Exp.Term.Type.TypeSetSet.m_domainConstants">
            <summary>
            All existing domain constants.
            </summary>
            <remarks>
            Domain constants are not cleared from the types' domains when reseting the <see cref="T:PDDLParser.Exp.Term.Type.TypeSetSet"/>
            using <see cref="M:PDDLParser.Exp.Term.Type.TypeSetSet.ClearAllButDomainConstants"/>.
            </remarks>
        </member>
        <member name="M:PDDLParser.Exp.Term.Type.TypeSetSet.#ctor">
            <summary>
            Create a new empty set of typesets, useful for untyped domains.
            </summary>
        </member>
        <member name="M:PDDLParser.Exp.Term.Type.TypeSetSet.#ctor(System.Collections.Generic.IDictionary{System.String,System.Collections.Generic.HashSet{System.String}})">
            <summary>
            Create a new set of typesets based on a given type hierarchy.
            </summary>
            <param name="hierarchy">The type hierarchy.</param>
        </member>
        <member name="M:PDDLParser.Exp.Term.Type.TypeSetSet.GetTypeSet(System.String)">
            <summary>
            Gets a typeset from its name. This is used to get typesets containing
            only a single primitive type.
            </summary>
            <param name="typeName">The name of the type (and typeset).</param>
            <returns>The typeset whose name was given.</returns>
            <exception cref="T:System.Collections.Generic.KeyNotFoundException">Thrown when the requested typeset does not exist.</exception>
        </member>
        <member name="M:PDDLParser.Exp.Term.Type.TypeSetSet.GetTypeSet(System.Collections.Generic.HashSet{System.String})">
            <summary>
            Gets a typeset from the names of all the types it contains. This is used to get
            typesets containing combined types (i.e. (either typeX typeY)).
            </summary>
            <remarks>
            If the requested combination of types does not yet exist as a typeset, it is created.
            </remarks>
            <param name="typeNames">The list of type names.</param>
            <returns>The corresponding typeset.</returns>
            <exception cref="T:System.Collections.Generic.KeyNotFoundException">Thrown when one of the requested primitive type does not exist.</exception>
        </member>
        <member name="M:PDDLParser.Exp.Term.Type.TypeSetSet.TypeExists(System.String)">
            <summary>
            Returns whether a given type exists.
            </summary>
            <param name="typeName">The name of the type.</param>
            <returns>True if the type exists; false otherwise.</returns>
        </member>
        <member name="M:PDDLParser.Exp.Term.Type.TypeSetSet.FlagAsDomainConstants(System.Collections.Generic.IEnumerable{PDDLParser.Exp.Term.Constant})">
            <summary>
            Flag the given constants as domain constants.
            </summary>
            <remarks>
            See <see cref="F:PDDLParser.Exp.Term.Type.TypeSetSet.m_domainConstants"/> and <see cref="M:PDDLParser.Exp.Term.Type.TypeSetSet.ClearAllButDomainConstants"/>
            for more information about domains constants.
            </remarks>
            <param name="domainConstants">The constants to be flagged as domain constants.</param>
            <seealso cref="F:PDDLParser.Exp.Term.Type.TypeSetSet.m_domainConstants"/>
            <seealso cref="M:PDDLParser.Exp.Term.Type.TypeSetSet.ClearAllButDomainConstants"/>
        </member>
        <member name="M:PDDLParser.Exp.Term.Type.TypeSetSet.ClearAllButDomainConstants">
            <summary>
            Clears all types' domains, but keeps the domain constants, as they do not change when a different problem is
            parsed and linked with the same domain.
            </summary>
            <seealso cref="M:PDDLParser.Exp.Term.Type.TypeSetSet.FlagAsDomainConstants(System.Collections.Generic.IEnumerable{PDDLParser.Exp.Term.Constant})"/>
            <seealso cref="F:PDDLParser.Exp.Term.Type.TypeSetSet.m_domainConstants"/>
        </member>
        <member name="M:PDDLParser.Exp.Term.Type.TypeSetSet.GetEnumerator">
            <summary>
            Returns an enumerator over the typesets forming this set of typeset.
            </summary>
            <returns>An enumerator over the typesets forming this set of typeset.</returns>
        </member>
        <member name="M:PDDLParser.Exp.Term.Type.TypeSetSet.System#Collections#IEnumerable#GetEnumerator">
            <summary>
            Returns an enumerator over the typesets forming this set of typeset.
            </summary>
            <returns>An enumerator over the typesets forming this set of typeset.</returns>
        </member>
        <member name="P:PDDLParser.Exp.Term.Type.TypeSetSet.Object">
            <summary>
            Gets the Object typeset.
            </summary>
        </member>
        <member name="P:PDDLParser.Exp.Term.Type.TypeSetSet.Number">
            <summary>
            Gets the Numerbe typeset.
            </summary>
        </member>
        <member name="T:PDDLParser.Exp.Struct.TermValue">
            <summary>
            A TermValue represents a term (possibly constant) or an undefined value.
            Note that a TermValue behaves exactly like a FuzzyConstantExp; the only difference is 
            that a TermValue stores the actual unknown expression instead of the 
            FuzzyConstantExp.Unknown value.
            </summary>
        </member>
        <member name="F:PDDLParser.Exp.Struct.TermValue.Undefined">
            <summary>
            TermValue undefined value.
            </summary>
        </member>
        <member name="F:PDDLParser.Exp.Struct.TermValue.m_value">
            <summary>
            The inner term stored inside this TermValue.
            </summary>
        </member>
        <member name="F:PDDLParser.Exp.Struct.TermValue.m_status">
            <summary>
            The status of this TermValue.
            </summary>
        </member>
        <member name="M:PDDLParser.Exp.Struct.TermValue.#ctor(PDDLParser.Exp.ITerm)">
            <summary>
            Creates a new TermValue with the specified term.
            </summary>
            <param name="value">The new TermValue's term.</param>
        </member>
        <member name="M:PDDLParser.Exp.Struct.TermValue.#ctor(PDDLParser.Exp.Struct.ConstantExp)">
            <summary>
            Creates a new TermValue with the specified constant value.
            </summary>
            <param name="value">The new TermValue's constant value.</param>
        </member>
        <member name="M:PDDLParser.Exp.Struct.TermValue.#ctor(PDDLParser.Exp.Struct.TermValue.State,PDDLParser.Exp.ITerm)">
            <summary>
            Creates a new TermValue with the specified status and term.
            </summary>
            <param name="status">The new TermValue's status.</param>
            <param name="value">The new TermValue's term.</param>
        </member>
        <member name="M:PDDLParser.Exp.Struct.TermValue.Equals(System.Object)">
            <summary>
            Returns true if this TermValue is equal to another object.
            </summary>
            <param name="obj">The other object to test for equality.</param>
            <returns>True if this TermValue is equal to the other object.</returns>
        </member>
        <member name="M:PDDLParser.Exp.Struct.TermValue.GetHashCode">
            <summary>
            Returns the hashcode of this TermValue.
            </summary>
            <returns>The hashcode of this TermValue.</returns>
        </member>
        <member name="M:PDDLParser.Exp.Struct.TermValue.ToString">
            <summary>
            Returns a string representation of this TermValue.
            </summary>
            <returns>A string representation of this TermValue.</returns>
        </member>
        <member name="P:PDDLParser.Exp.Struct.TermValue.Status">
            <summary>
            Returns the status of this TermValue.
            </summary>
        </member>
        <member name="P:PDDLParser.Exp.Struct.TermValue.Value">
            <summary>
            Returns the inner term stored inside this TermValue.
            The value should only be accessed if this Double is defined.
            </summary>
        </member>
        <member name="T:PDDLParser.Exp.Struct.TermValue.State">
            <summary>
            Internal status of this TermValue which indicates whether it is defined.
            </summary>
        </member>
        <member name="F:PDDLParser.Exp.Struct.TermValue.State.Defined">
            <summary>
            Indicates that this TermValue is defined, and thus its internal term value
            can be accessed.
            </summary>
        </member>
        <member name="F:PDDLParser.Exp.Struct.TermValue.State.Undefined">
            <summary>
            Indicates that this TermValue is undefined.
            </summary>
        </member>
        <member name="T:PDDLParser.Exp.Numeric.TLPlan.UnarySquareRoot">
            <summary>
            This class implements the square root function.
            This is not part of PDDL; it was rather added for TLPlan.
            </summary>
        </member>
        <member name="M:PDDLParser.Exp.Numeric.TLPlan.UnarySquareRoot.#ctor(PDDLParser.Exp.INumericExp)">
            <summary>
            Creates a new square root function with the specified argument.
            </summary>
            <param name="arg">The argument of this new square root function.</param>
        </member>
        <member name="M:PDDLParser.Exp.Numeric.TLPlan.UnarySquareRoot.Calculate(System.Double)">
            <summary>
            Calculates the square root of the argument.
            </summary>
            <param name="arg">The argument.</param>
            <returns>The square root of the argument.</returns>
            <exception cref="T:PDDLParser.Exception.NumericException">A NumericException is thrown if
            the argument is negative.</exception>
        </member>
        <member name="T:PDDLParser.Exp.Numeric.NArityMultiply">
            <summary>
            This class implements a n-ary multiplication.
            </summary>
        </member>
        <member name="M:PDDLParser.Exp.Numeric.NArityMultiply.#ctor(System.Collections.Generic.List{PDDLParser.Exp.INumericExp})">
            <summary>
            Creates a new multiplication function with the specified arguments.
            </summary>
            <param name="args">The arguments of the new multiplication function.</param>
        </member>
        <member name="M:PDDLParser.Exp.Numeric.NArityMultiply.Calculate(System.Double[])">
            <summary>
            Calculates the product of all arguments.
            </summary>
            <param name="args">The arguments to call the function with.</param>
            <returns>The product of all arguments.</returns>
        </member>
        <member name="T:PDDLParser.Exp.Formula.ArgsEvalResult">
            <summary>
            An ArgsEvalResult represents a set of evaluated arguments, or an undefined value if 
            the evaluation was not successful.
            </summary>
        </member>
        <member name="F:PDDLParser.Exp.Formula.ArgsEvalResult.Undefined">
            <summary>
            ArgsEvalResult Undefined value.
            </summary>
        </member>
        <member name="F:PDDLParser.Exp.Formula.ArgsEvalResult.m_value">
            <summary>
            The inner formula application (with evaluated arguments) stored in this ArgsEvalResult.
            </summary>
        </member>
        <member name="F:PDDLParser.Exp.Formula.ArgsEvalResult.m_status">
            <summary>
            The status of this ArgsEvalResult.
            </summary>
        </member>
        <member name="M:PDDLParser.Exp.Formula.ArgsEvalResult.#ctor(PDDLParser.Exp.Formula.FormulaApplication)">
            <summary>
            Creates a new ArgsEvalResult with the given formula application with evaluated arguments.
            </summary>
            <param name="value">A formula application with evaluated arguments.</param>
        </member>
        <member name="M:PDDLParser.Exp.Formula.ArgsEvalResult.#ctor(PDDLParser.Exp.Formula.ArgsEvalResult.State)">
            <summary>
            Creates a new ArgsEvalResult with the given status.
            </summary>
            <param name="status">The status of the new ArgsEvalResult.</param>
        </member>
        <member name="M:PDDLParser.Exp.Formula.ArgsEvalResult.Equals(System.Object)">
            <summary>
            Returns true if this ArgsEvalResult is equal to another object.
            </summary>
            <param name="obj">The other object to test for equality.</param>
            <returns>True if this ArgsEvalResult is equal to the other object.</returns>
        </member>
        <member name="M:PDDLParser.Exp.Formula.ArgsEvalResult.GetHashCode">
            <summary>
            Returns the hash code of this ArgsEvalResult.
            </summary>
            <returns>The hash code of this ArgsEvalResult.</returns>
        </member>
        <member name="M:PDDLParser.Exp.Formula.ArgsEvalResult.ToString">
            <summary>
            Returns a string representation of this ArgsEvalResult.
            </summary>
            <returns>A string representation of this ArgsEvalResult.</returns>
        </member>
        <member name="P:PDDLParser.Exp.Formula.ArgsEvalResult.Status">
            <summary>
            Returns the status of this ArgsEvalResult.
            </summary>
        </member>
        <member name="P:PDDLParser.Exp.Formula.ArgsEvalResult.Value">
            <summary>
            Returns the inner formula application stored inside this ArgsEvalResult.
            If this ArgsEvalResult is undefined, this call throws an UndefinedExpException.
            </summary>
        </member>
        <member name="T:PDDLParser.Exp.Formula.ArgsEvalResult.State">
            <summary>
            Internal status of this ArgsEvalResult which indicates whether it is defined.
            </summary>
        </member>
        <member name="F:PDDLParser.Exp.Formula.ArgsEvalResult.State.Defined">
            <summary>
            Indicates that all the evaluated arguments are defined.
            </summary>
        </member>
        <member name="F:PDDLParser.Exp.Formula.ArgsEvalResult.State.Undefined">
            <summary>
            Indicates that their is at least one argument which evaluates to undefined.
            </summary>
        </member>
        <member name="T:PDDLParser.Exp.Constraint.TLPlan.ExistsUniqueConstraintExp">
            <summary>
            Represents a uniqueness quantification of a constraint expression. This is not part 
            of PDDL; it was rather added for TLPlan.
            </summary>
        </member>
        <member name="M:PDDLParser.Exp.Constraint.TLPlan.ExistsUniqueConstraintExp.#ctor(System.Collections.Generic.HashSet{PDDLParser.Exp.Term.ObjectParameterVariable},PDDLParser.Exp.IConstraintExp)">
            <summary>
            Creates a new uniquely existential expression with the given quantified variables and
            constraint expression.
            </summary>
            <param name="vars">The quantified variables.</param>
            <param name="exp">The constraint expression.</param>
        </member>
        <member name="M:PDDLParser.Exp.Constraint.TLPlan.ExistsUniqueConstraintExp.GenerateEquivalentExp">
            <summary>
            Creates a new ground expression equivalent to this quantified expression.
            </summary>
            <returns>A new ground expression equivalent to this quantified expression.</returns>
        </member>
        <member name="M:PDDLParser.Exp.Constraint.TLPlan.ExistsUniqueConstraintExp.Progress(PDDLParser.World.IReadOnlyDurativeClosedWorld,PDDLParser.Exp.LocalBindings)">
            <summary>
            Evaluates the progression of this constraint expression in the next worlds.
            </summary>
            <param name="world">The current world.</param>
            <param name="bindings">A set of variable bindings.</param>
            <returns>True, false, undefined, or a progressed expression.</returns>
            <exception cref="T:PDDLParser.Exception.BindingException">A BindingException is thrown if an attempt
            is made to evaluate an unbound variable.</exception>
            <seealso cref="M:PDDLParser.Exp.IConstraintExp.Progress(PDDLParser.World.IReadOnlyDurativeClosedWorld,PDDLParser.Exp.LocalBindings)"/>
        </member>
        <member name="M:PDDLParser.Exp.Constraint.TLPlan.ExistsUniqueConstraintExp.EvaluateIdle(PDDLParser.World.IReadOnlyDurativeClosedWorld,PDDLParser.Exp.LocalBindings)">
            <summary>
            Evaluates this constraint expression in an idle world, i.e. a world which
            won't be modified by further updates.
            </summary>
            <param name="idleWorld">The (idle) evaluation world.</param>
            <param name="bindings">A set of variable bindings.</param>
            <returns>True, false, or undefined.</returns>
            <exception cref="T:PDDLParser.Exception.BindingException">A BindingException is thrown if an attempt
            is made to evaluate an unbound variable.</exception>
            <seealso cref="M:PDDLParser.Exp.IConstraintExp.EvaluateIdle(PDDLParser.World.IReadOnlyDurativeClosedWorld,PDDLParser.Exp.LocalBindings)"/>
        </member>
        <member name="T:PDDLParser.Action.DurativeAction">
            <summary>
            Represents a durative action of the PDDl language.
            </summary>
        </member>
        <member name="F:PDDLParser.Action.DurativeAction.m_duration">
            <summary>
            The duration constraint of the action.
            </summary>
        </member>
        <member name="F:PDDLParser.Action.DurativeAction.m_startCondition">
            <summary>
            The start condition of the durative action.
            </summary>
        </member>
        <member name="F:PDDLParser.Action.DurativeAction.m_overallCondition">
            <summary>
            The over all condition of the durative action.
            </summary>
        </member>
        <member name="F:PDDLParser.Action.DurativeAction.m_endCondition">
            <summary>
            The end condition of the durative action.
            </summary>
        </member>
        <member name="F:PDDLParser.Action.DurativeAction.m_startEffect">
            <summary>
            The start effect of the durative action.
            </summary>
        </member>
        <member name="F:PDDLParser.Action.DurativeAction.m_endEffect">
            <summary>
            The end effect of the durative action.
            </summary>
        </member>
        <member name="F:PDDLParser.Action.DurativeAction.m_continuousEffect">
            <summary>
            The continuous effect of the durative action.
            </summary>
        </member>
        <member name="F:PDDLParser.Action.DurativeAction.m_overallEffect">
            <summary>
            The overall effect of the durative action. This is not an effect that can be
            used by the user; it is rather created when using "over all" preferences.
            </summary>
        </member>
        <member name="M:PDDLParser.Action.DurativeAction.#ctor(System.String,System.Double,System.Collections.Generic.List{PDDLParser.Exp.Term.ObjectParameterVariable})">
            <summary>
            Creates a new durative action with a given name, priority, and parameter list.
            </summary>
            <param name="name">The durative action's name.</param>
            <param name="priority">The durative action's priority.</param>
            <param name="parameters">The durative action's parameters.</param>
        </member>
        <member name="M:PDDLParser.Action.DurativeAction.GetAllEffects">
            <summary>
            Returns all effects of the action, independently of their time of effect.
            </summary>
            <returns>All effects of the action.</returns>
        </member>
        <member name="M:PDDLParser.Action.DurativeAction.Standardize">
            <summary>
            Standardizes all occurrences of the variables that occur in this
            action. Remember that free variables are existentially quantified.
            </summary>
            <returns>A standardized copy of this expression.</returns>
        </member>
        <member name="M:PDDLParser.Action.DurativeAction.Clone">
            <summary>
            Returns a deep copy of this abstract action.
            </summary>
            <returns>A deep copy of this abstract action.</returns>
        </member>
        <member name="M:PDDLParser.Action.DurativeAction.ToString">
            <summary>
            Returns a string representation of this action.
            </summary>
            <returns>A string representation of this action.</returns>
        </member>
        <member name="M:PDDLParser.Action.DurativeAction.ToTypedString">
            <summary>
            Returns a typed string representation of this action.
            </summary>
            <returns>A typed string representation of this action.</returns>
        </member>
        <member name="P:PDDLParser.Action.DurativeAction.Duration">
            <summary>
            Gets or sets the duration constraint of the durative action.
            </summary>
        </member>
        <member name="P:PDDLParser.Action.DurativeAction.StartCondition">
            <summary>
            Gets or sets the start conditions of the durative action.
            </summary>
        </member>
        <member name="P:PDDLParser.Action.DurativeAction.OverallCondition">
            <summary>
            Gets or sets the overall conditions of the durative action.
            </summary>
        </member>
        <member name="P:PDDLParser.Action.DurativeAction.EndCondition">
            <summary>
            Gets or sets the end conditions of the durative action.
            </summary>
        </member>
        <member name="P:PDDLParser.Action.DurativeAction.StartEffect">
            <summary>
            Gets or sets the start effect of the durative action.
            </summary>
        </member>
        <member name="P:PDDLParser.Action.DurativeAction.EndEffect">
            <summary>
            Gets or sets the end effect of the durative action.
            </summary>
        </member>
        <member name="P:PDDLParser.Action.DurativeAction.ContinuousEffect">
            <summary>
            Gets or sets the continuous effect of the durative action.
            </summary>
        </member>
        <member name="P:PDDLParser.Action.DurativeAction.OverallEffect">
            <summary>
            Gets or sets the over all effect of the durative action. This is not an effect that can be
            used by the user; it is rather created when using "over all" preferences.
            </summary>
        </member>
        <member name="T:PDDLParser.LinkedDictionary`2">
            <summary>
            A linked dictionary maps keys to values. It allows enumerating over the pairs of key/value
            in the same order they were added to the dictionary.
            </summary>
            <typeparam name="Key">The type of the keys in the dictionary.</typeparam>
            <typeparam name="Value">The type of the values in the dictionary.</typeparam>
        </member>
        <member name="F:PDDLParser.LinkedDictionary`2.m_list">
            <summary>
            This internal list holds all the pairs of key/value contained in the dictionary,
            in the order which they were added.
            </summary>
        </member>
        <member name="F:PDDLParser.LinkedDictionary`2.m_dict">
            <summary>
            This internal dictionary maps keys to <see cref="F:PDDLParser.LinkedDictionary`2.m_list"/>'s nodes.
            It allows for fast retrieval of values when given a key.
            </summary>
        </member>
        <member name="M:PDDLParser.LinkedDictionary`2.#ctor">
            <summary>
            Creates a new empty linked dictionary.
            </summary>
        </member>
        <member name="M:PDDLParser.LinkedDictionary`2.Add(`0,`1)">
            <summary>
            Adds an element with the specified key to the dictionary.
            </summary>
            <param name="key">The key of the element to add.</param>
            <param name="value">The value of the element to add.</param>
        </member>
        <member name="M:PDDLParser.LinkedDictionary`2.ContainsKey(`0)">
            <summary>
            Determines whether the dictionary contains an element with the specified key.
            </summary>
            <param name="key">The key to locate in the dictionary.</param>
            <returns>Whether the dictionary contains an element with the specified key.</returns>
        </member>
        <member name="M:PDDLParser.LinkedDictionary`2.Remove(`0)">
            <summary>
            Removes the element with the specified key from the dictionary.
            </summary>
            <param name="key">The key of the element to remove.</param>
            <returns>True if the element is successfully removed; otherwise, false.</returns>
        </member>
        <member name="M:PDDLParser.LinkedDictionary`2.TryGetValue(`0,`1@)">
            <summary>
            Gets the value associated with the specified key.
            </summary>
            <param name="key">The key of the element to get.</param>
            <param name="value">This parameter is set to the value of the element to look
            for, if found.</param>
            <returns>True if an element with the specified key is contained in the dictionary.</returns>
        </member>
        <member name="M:PDDLParser.LinkedDictionary`2.Add(System.Collections.Generic.KeyValuePair{`0,`1})">
            <summary>
            Adds a pair of key/value to the dictionary.
            </summary>
            <param name="item">The pair of key/value to add to the dictionary.</param>
        </member>
        <member name="M:PDDLParser.LinkedDictionary`2.Clear">
            <summary>
            Clears the dictionary.
            </summary>
        </member>
        <member name="M:PDDLParser.LinkedDictionary`2.Contains(System.Collections.Generic.KeyValuePair{`0,`1})">
            <summary>
            Determines whether the specified pair of key/value is present in the dictionary.
            </summary>
            <param name="item">The key/value pair of the element to locate.</param>
            <returns>True if the dictionary contains an element with the same key and value;
            otherwise false.</returns>
        </member>
        <member name="M:PDDLParser.LinkedDictionary`2.CopyTo(System.Collections.Generic.KeyValuePair{`0,`1}[],System.Int32)">
            <summary>
            Copies the elements of the dictionary to an array, starting at a particular index.
            </summary>
            <param name="array">The one-dimensional Array that is the destination of the elements.</param>
            <param name="arrayIndex">The zero-based index in array at which copying begins.</param>
        </member>
        <member name="M:PDDLParser.LinkedDictionary`2.Remove(System.Collections.Generic.KeyValuePair{`0,`1})">
            <summary>
            Removes the element with the specified key and value.
            </summary>
            <param name="item">The key and value of the element to remove.</param>
            <returns>True if an element with the same key and value was removed.</returns>
        </member>
        <member name="M:PDDLParser.LinkedDictionary`2.GetEnumerator">
            <summary>
            Returns an enumerator over the pairs of key/value in the dictionary.
            </summary>
            <returns>An enumerator over the pairs of key/value in the dictionary.</returns>
        </member>
        <member name="M:PDDLParser.LinkedDictionary`2.System#Collections#IEnumerable#GetEnumerator">
            <summary>
            Returns an enumerator over the pairs of key/value in the dictionary.
            </summary>
            <returns>An enumerator over the pairs of key/value in the dictionary.</returns>
        </member>
        <member name="P:PDDLParser.LinkedDictionary`2.Keys">
            <summary>
            Returns the collection of keys present in the dictionary.
            </summary>
        </member>
        <member name="P:PDDLParser.LinkedDictionary`2.Values">
            <summary>
            Returns the collection of values present in the dictionary.
            </summary>
        </member>
        <member name="P:PDDLParser.LinkedDictionary`2.Item(`0)">
            <summary>
            Gets or sets the element with the specified key.
            </summary>
            <param name="key">The key of the element to get or set.</param>
            <returns>The element with the specified key.</returns>
        </member>
        <member name="P:PDDLParser.LinkedDictionary`2.Count">
            <summary>
            Gets the number of elements contained in this dictionary.
            </summary>
        </member>
        <member name="P:PDDLParser.LinkedDictionary`2.IsReadOnly">
            <summary>
            Gets a value indicating whether this dictionary is read-only, which it is not.
            </summary>
        </member>
        <member name="T:PDDLParser.Exp.Numeric.TLPlan.UnaryExponential">
            <summary>
            This class implements the exponential function.
            This is not part of PDDL; it was rather added for TLPlan.
            </summary>
        </member>
        <member name="M:PDDLParser.Exp.Numeric.TLPlan.UnaryExponential.#ctor(PDDLParser.Exp.INumericExp)">
            <summary>
            Creates a new exponential function with the specified exponent.
            </summary>
            <param name="exponent">The exponent of the new exponential function.</param>
        </member>
        <member name="M:PDDLParser.Exp.Numeric.TLPlan.UnaryExponential.Calculate(System.Double)">
            <summary>
            Calculates the exponential function of the argument (the exponentiation of the 
            Euler number to the given exponent).
            </summary>
            <param name="exponent">The exponent.</param>
            <returns>The exponential function of the argument.</returns>
        </member>
        <member name="T:PDDLParser.Exp.Formula.TLPlan.LocalVar.ObjectLocalVariable">
            <summary>
            An object local variable is a local variable bound to an object (a constant from the domain).
            </summary>
        </member>
        <member name="M:PDDLParser.Exp.Formula.TLPlan.LocalVar.ObjectLocalVariable.#ctor(System.String,PDDLParser.Exp.Term.Type.TypeSet)">
            <summary>
            Creates a new object local variable with the specified name and typeset.
            </summary>
            <param name="name">The name of this object local variable.</param>
            <param name="typeSet">The typeset of this object local variable.</param>
        </member>
        <member name="M:PDDLParser.Exp.Formula.TLPlan.LocalVar.ObjectLocalVariable.Evaluate(PDDLParser.World.IReadOnlyOpenWorld,PDDLParser.Exp.LocalBindings)">
            <summary>
            Evaluates this term in the specified open world.
            A local variable is evaluated by retrieving its binding in the provided set of bindings.
            </summary>
            <param name="world">The evaluation world.</param>
            <param name="bindings">A set of variable bindings.</param>
            <returns>Undefined, unknown, or the constant resulting from the evaluation.</returns>
            <exception cref="T:PDDLParser.Exception.BindingException">A BindingException is thrown if this
            variable is not bound.</exception>
        </member>
        <member name="M:PDDLParser.Exp.Formula.TLPlan.LocalVar.ObjectLocalVariable.Simplify(PDDLParser.World.IReadOnlyOpenWorld,PDDLParser.Exp.LocalBindings)">
            <summary>
            Simplifies this term by evaluating its known expression parts.
            A local variable is simplified by retrieving its corresponding binding, if accessible.
            </summary>
            <param name="world">The evaluation world.</param>
            <param name="bindings">A set of variable bindings.</param>
            <returns>Undefined, or the term (possibly a constant) resulting from 
            the simplification.</returns>
            <exception cref="T:PDDLParser.Exception.BindingException">A BindingException is thrown if this
            variable is not bound.</exception>
        </member>
        <member name="M:PDDLParser.Exp.Formula.TLPlan.LocalVar.ObjectLocalVariable.Evaluate(PDDLParser.World.IReadOnlyClosedWorld,PDDLParser.Exp.LocalBindings)">
            <summary>
            Evaluates this term in the specified closed world.
            A local variable is evaluated by retrieving its binding in the provided set of bindings.
            </summary>
            <param name="world">The evaluation world.</param>
            <param name="bindings">A set of variable bindings.</param>
            <returns>Undefined, or the constant resulting from the evaluation.</returns>
            <exception cref="T:PDDLParser.Exception.BindingException">A BindingException is thrown if this
            variable is not bound.</exception>
        </member>
        <member name="M:PDDLParser.Exp.Formula.TLPlan.LocalVar.ObjectLocalVariable.Apply(PDDLParser.Exp.ParameterBindings)">
            <summary>
            Substitutes all occurrences of the variables that occur in this
            expression by their corresponding bindings.
            </summary>
            <param name="bindings">The bindings.</param>
            <returns>A substituted copy of this expression.</returns>
        </member>
        <member name="M:PDDLParser.Exp.Formula.TLPlan.LocalVar.ObjectLocalVariable.IsFree">
            <summary>
            Returns true if this variable is free, false it is bound.
            An object local variable is bound.
            </summary>
            <returns>False.</returns>
        </member>
        <member name="T:PDDLParser.Exp.Formula.TLPlan.LocalVar.AssignNumericLocalVar">
            <summary>
            A numeric variable assignement is an assignment of a numeric value to a numeric variable.
            </summary>
        </member>
        <member name="M:PDDLParser.Exp.Formula.TLPlan.LocalVar.AssignNumericLocalVar.#ctor(PDDLParser.Exp.Formula.TLPlan.LocalVar.NumericLocalVariable,PDDLParser.Exp.INumericExp)">
            <summary>
            Creates a new numeric variable assignment for the specified numeric variable and 
            assignation expression.
            </summary>
            <param name="localVariable">The numeric local variable to assign a value to.</param>
            <param name="body">The assignation expression.</param>
        </member>
        <member name="M:PDDLParser.Exp.Formula.TLPlan.LocalVar.AssignNumericLocalVar.BindLocalVariable(PDDLParser.World.IReadOnlyClosedWorld,PDDLParser.Exp.LocalBindings)">
            <summary>
            Binds the local variable associated with this assignment to the evaluated assignation
            expression.
            </summary>
            <param name="world">The evaluation world.</param>
            <param name="bindings">A set of variable bindings.</param>
        </member>
        <member name="M:PDDLParser.Exp.Formula.TLPlan.LocalVar.AssignNumericLocalVar.TryBindLocalVariable(PDDLParser.World.IReadOnlyOpenWorld,PDDLParser.Exp.LocalBindings)">
            <summary>
            Tries and binds the local variable associated with this assignment to the evaluated assignation
            expression.
            Note that this function returns false if the assignation expression could not be evaluated.
            </summary>
            <param name="world">The evaluation world.</param>
            <param name="bindings">A set of variable bindings.</param>
            <returns>True if the binding was successfully done.</returns>
        </member>
        <member name="T:PDDLParser.Exp.Formula.TLPlan.DefinedNumericFunction">
            <summary>
            A defined numeric functions is a defined function which yields a numeric value when
            evaluated.
            </summary>
        </member>
        <member name="F:PDDLParser.Exp.Formula.TLPlan.DefinedNumericFunction.m_functionVariable">
            <summary>
            The local variable corresponding to this function's return value.
            </summary>
        </member>
        <member name="M:PDDLParser.Exp.Formula.TLPlan.DefinedNumericFunction.#ctor(System.String,System.Collections.Generic.List{PDDLParser.Exp.Term.ObjectParameterVariable},System.Collections.Generic.List{PDDLParser.Exp.ILocalVariable})">
            <summary>
            Creates a new defined numeric function with the specified name, arguments,
            and local variables.
            </summary>
            <param name="name">The name of this defined numeric function.</param>
            <param name="arguments">The arguments of this defined numeric function.</param>
            <param name="localVariables">The local variables used in the body of this
            defined numeric function.</param>
        </member>
        <member name="M:PDDLParser.Exp.Formula.TLPlan.DefinedNumericFunction.Evaluate(PDDLParser.World.IReadOnlyOpenWorld,PDDLParser.Exp.Formula.TLPlan.DefinedNumericFunctionApplication)">
            <summary>
            Evaluates this defined numeric function in the specified open world.
            A defined numeric function is evaluated by binding its body's free variables to the
            corresponding arguments of the function application, and then evaluating its
            body using immediate short-circuit.
            If its body evaluates to unknown, the evaluation returns unknown.
            If its body evaluates to undefined, the evaluation returns undefined.
            Else the evaluation returns the final binding of the function variable.
            </summary>
            <param name="world">The evaluation world.</param>
            <param name="formula">A function application with ground (constant) arguments.</param>
            <returns>Undefined, unknown, or the resulting numeric value.</returns>
        </member>
        <member name="M:PDDLParser.Exp.Formula.TLPlan.DefinedNumericFunction.Evaluate(PDDLParser.World.IReadOnlyClosedWorld,PDDLParser.Exp.Formula.TLPlan.DefinedNumericFunctionApplication)">
            <summary>
            Evaluates this defined numeric function in the specified closed world.
            A defined numeric function is evaluated by binding its body's free variables to the
            corresponding arguments of the function application, and then evaluating its
            body using immediate short-circuit.
            If its body evaluates to undefined, the evaluation returns undefined.
            Else the evaluation returns the final binding of the function variable.
            </summary>
            <param name="world">The evaluation world.</param>
            <param name="formula">A function application with ground (constant) arguments.</param>
            <returns>Undefined, or the resulting numeric value.</returns>
        </member>
        <member name="M:PDDLParser.Exp.Formula.TLPlan.DefinedNumericFunction.Instantiate(System.Collections.Generic.List{PDDLParser.Exp.ITerm})">
            <summary>
            Instantiates a formula application associated with this defined numeric function.
            </summary>
            <param name="arguments">Arguments of the formula application to instantiate.</param>
            <returns>A new formula application associated with this defined numeric function.</returns>
        </member>
        <member name="M:PDDLParser.Exp.Formula.TLPlan.DefinedNumericFunction.ToTypedString">
            <summary>
            Returns a typed string representation of this formula.
            </summary>
            <returns>A typed string representation of this formula.</returns>
        </member>
        <member name="P:PDDLParser.Exp.Formula.TLPlan.DefinedNumericFunction.FunctionVariable">
            <summary>
            Gets the local variable corresponding to the function's return value.
            </summary>
        </member>
        <member name="T:PDDLParser.Exp.Constraint.WithinExp">
            <summary>
            Represents the "within" constraint expression of the PDDL language.
            This constraint expression uses timestamps relative to the first time it is progressed.
            </summary>
        </member>
        <member name="M:PDDLParser.Exp.Constraint.WithinExp.#ctor(PDDLParser.Exp.IConstraintExp,System.Double)">
            <summary>
            Creates a new "within" constraint expression.
            </summary>
            <param name="exp">The body of the expression.</param>
            <param name="relativeTimestamp">The timestamp within which the body must be true. This timestamp is
            relative to the first progression of this constraint expression.</param>
        </member>
        <member name="M:PDDLParser.Exp.Constraint.WithinExp.ToString">
            <summary>
            Returns a string representation of this expression.
            </summary>
            <returns>A string representation of this expression.</returns>
        </member>
        <member name="M:PDDLParser.Exp.Constraint.WithinExp.ToTypedString">
            <summary>
            Returns a typed string of this expression.
            </summary>
            <returns>A typed string representation of this expression.</returns>
        </member>
        <member name="T:PDDLParser.Exp.Constraint.TLPlan.WeakUntilExp">
            <summary>
            Represents the "weak-until" operator of the LTL language. This is not part of PDDL; it was rather added
            for TLPlan.
            </summary>
            <remarks>
            Note that (weak-until a b) = (until a (or b (always a))).
            </remarks>
            <seealso cref="T:PDDLParser.Exp.Constraint.TLPlan.UntilExp"/>
        </member>
        <member name="M:PDDLParser.Exp.Constraint.TLPlan.WeakUntilExp.#ctor(PDDLParser.Exp.IConstraintExp,PDDLParser.Exp.IConstraintExp)">
            <summary>
            Creates a new "weak-until" constraint expression.
            </summary>
            <param name="arg1">The first expression, which must always be true until the second one is.</param>
            <param name="arg2">The second expression. When this one becomes true, the value of the first one
            becomes irrelevant. Note that, unlike in the "until" operator, the second expression does not have to
            become true for a trajectory to be valid, so long as the first expression is always true.</param>
            <seealso cref="T:PDDLParser.Exp.Constraint.TLPlan.UntilExp"/>
        </member>
        <member name="M:PDDLParser.Exp.Constraint.TLPlan.WeakUntilExp.EvaluateIdle(PDDLParser.World.IReadOnlyDurativeClosedWorld,PDDLParser.Exp.LocalBindings)">
            <summary>
            Evaluates this constraint expression in an idle world, i.e. a world which
            won't be modified by further updates.
            </summary>
            <param name="idleWorld">The (idle) evaluation world.</param>
            <param name="bindings">A set of variable bindings.</param>
            <returns>True, false, or undefined.</returns>
            <exception cref="T:PDDLParser.Exception.BindingException">A BindingException is thrown if an attempt
            is made to evaluate an unbound variable.</exception>
            <seealso cref="M:PDDLParser.Exp.IConstraintExp.EvaluateIdle(PDDLParser.World.IReadOnlyDurativeClosedWorld,PDDLParser.Exp.LocalBindings)"/>
        </member>
        <member name="M:PDDLParser.Exp.Constraint.TLPlan.WeakUntilExp.ToString">
            <summary>
            Returns a string representation of this expression.
            </summary>
            <returns>A string representation of this expression.</returns>
        </member>
        <member name="M:PDDLParser.Exp.Constraint.TLPlan.WeakUntilExp.ToTypedString">
            <summary>
            Returns a typed string of this expression.
            </summary>
            <returns>A typed string representation of this expression.</returns>
        </member>
        <member name="T:PDDLParser.Exp.Constraint.AlwaysExp">
            <summary>
            Represents an "always" constraint expression of the PDDL language.
            </summary>
        </member>
        <member name="M:PDDLParser.Exp.Constraint.AlwaysExp.#ctor(PDDLParser.Exp.IConstraintExp)">
            <summary>
            Create a new "always" constraint expression with the given body.
            </summary>
            <param name="arg">The constraint expression which must always be true.</param>
        </member>
        <member name="M:PDDLParser.Exp.Constraint.AlwaysExp.Progress(PDDLParser.World.IReadOnlyDurativeClosedWorld,PDDLParser.Exp.LocalBindings)">
            <summary>
            Evaluates the progression of this constraint expression in the next worlds.
            </summary>
            <param name="world">The current world.</param>
            <param name="bindings">A set of variable bindings.</param>
            <returns>True, false, undefined, or a progressed expression.</returns>
            <exception cref="T:PDDLParser.Exception.BindingException">A BindingException is thrown if an attempt
            is made to evaluate an unbound variable.</exception>
            <seealso cref="M:PDDLParser.Exp.IConstraintExp.Progress(PDDLParser.World.IReadOnlyDurativeClosedWorld,PDDLParser.Exp.LocalBindings)"/>
        </member>
        <member name="M:PDDLParser.Exp.Constraint.AlwaysExp.EvaluateIdle(PDDLParser.World.IReadOnlyDurativeClosedWorld,PDDLParser.Exp.LocalBindings)">
            <summary>
            Evaluates this constraint expression in an idle world, i.e. a world which
            won't be modified by further updates.
            </summary>
            <param name="idleWorld">The (idle) evaluation world.</param>
            <param name="bindings">A set of variable bindings.</param>
            <returns>True, false, or undefined.</returns>
            <exception cref="T:PDDLParser.Exception.BindingException">A BindingException is thrown if an attempt
            is made to evaluate an unbound variable.</exception>
            <seealso cref="M:PDDLParser.Exp.IConstraintExp.EvaluateIdle(PDDLParser.World.IReadOnlyDurativeClosedWorld,PDDLParser.Exp.LocalBindings)"/>
        </member>
        <member name="M:PDDLParser.Exp.Constraint.AlwaysExp.ToString">
            <summary>
            Returns a string representation of this expression.
            </summary>
            <returns>A string representation of this expression.</returns>
        </member>
        <member name="M:PDDLParser.Exp.Constraint.AlwaysExp.ToTypedString">
            <summary>
            Returns a typed string representation of this expression.
            </summary>
            <returns>A typed string representation of this expression.</returns>
        </member>
        <member name="T:PDDLParser.ExpController">
            <summary>
            An expression controller supplies high-level methods for manipulating expressions.
            </summary>
        </member>
        <member name="M:PDDLParser.ExpController.Evaluate(PDDLParser.Exp.ILogicalExp,PDDLParser.World.IReadOnlyOpenWorld)">
            <summary>
            Evaluates this logical expression in the specified open world.
            The expression to evaluate must be ground since no bindings are supplied.
            </summary>
            <param name="exp">The logical expression to evaluate.</param>
            <param name="world">The evaluation world.</param>
            <returns>True, false, undefined, or unknown.</returns>
        </member>
        <member name="M:PDDLParser.ExpController.Evaluate(PDDLParser.Exp.ILogicalExp,PDDLParser.World.IReadOnlyOpenWorld,PDDLParser.Exp.LocalBindings)">
            <summary>
            Evaluates this logical expression in the specified open world, with the given
            set of bindings.
            </summary>
            <param name="exp">The logical expression to evaluate.</param>
            <param name="world">The evaluation world.</param>
            <param name="bindings">A given set of bindings.</param>
            <returns>True, false, undefined, or unknown.</returns>
        </member>
        <member name="M:PDDLParser.ExpController.Simplify(PDDLParser.Exp.ILogicalExp,PDDLParser.World.IReadOnlyOpenWorld)">
            <summary>
            Simplifies this logical expression by evaluating its known expression parts.
            The expression to simplify must be ground since no bindings are supplied.
            </summary>
            <param name="exp">The logical expression to simplify.</param>
            <param name="world">The evaluation world.</param>
            <returns>True, false, undefined, or the simplified expression.</returns>
        </member>
        <member name="M:PDDLParser.ExpController.Simplify(PDDLParser.Exp.ILogicalExp,PDDLParser.World.IReadOnlyOpenWorld,PDDLParser.Exp.LocalBindings)">
            <summary>
            Simplifies this logical expression with a given set of bindings by evaluating
            its known expression parts.
            </summary>
            <param name="exp">The logical expression to simplify.</param>
            <param name="world">The evaluation world.</param>
            <param name="bindings">A given set of bindings.</param>
            <returns>True, false, undefined, or the simplified expression.</returns>
        </member>
        <member name="M:PDDLParser.ExpController.Evaluate(PDDLParser.Exp.ILogicalExp,PDDLParser.World.IReadOnlyClosedWorld)">
            <summary>
            Evaluates this logical expression in the specified closed world.
            The expression to evaluate must be ground since no bindings are supplied.
            </summary>
            <param name="exp">The logical expression to evaluate.</param>
            <param name="world">The evaluation world.</param>
            <returns>True or false.</returns>
        </member>
        <member name="M:PDDLParser.ExpController.Evaluate(PDDLParser.Exp.ILogicalExp,PDDLParser.World.IReadOnlyClosedWorld,PDDLParser.Exp.LocalBindings)">
            <summary>
            Evaluates this logical expression in the specified closed world, with the given
            set of bindings.
            </summary>
            <param name="exp">The logical expression to evaluate.</param>
            <param name="world">The evaluation world.</param>
            <param name="bindings">A given set of bindings.</param>
            <returns>True or false.</returns>
        </member>
        <member name="M:PDDLParser.ExpController.EvaluateMetric(PDDLParser.Exp.Metric.MetricExp,PDDLParser.World.IReadOnlyDurativeClosedWorld)">
            <summary>
            Evaluates the given metric against a specified durative closed world.
            Note that a durative world is required to evaluate a metric.
            </summary>
            <param name="metric">The metric to evaluate.</param>
            <param name="world">The evaluation world.</param>
            <returns>True or false.</returns>
        </member>
        <member name="M:PDDLParser.ExpController.Progress(PDDLParser.Exp.IConstraintExp,PDDLParser.World.IReadOnlyDurativeClosedWorld)">
            <summary>
            Evaluates the progression of this constraint expression in the next worlds.
            This function returns false if this constraint expression is not satisfied 
            in the given world;
            it returns true if the progression is always satisfied in the next worlds;
            else it returns the progressed expression.
            The expression to progress must be ground since no bindings are supplied.
            </summary>
            <param name="exp">The constraint expression to progress.</param>
            <param name="world">The current world.</param>
            <returns>True, false, undefined, or a progressed expression.</returns>
        </member>
        <member name="M:PDDLParser.ExpController.Progress(PDDLParser.Exp.IConstraintExp,PDDLParser.World.IReadOnlyDurativeClosedWorld,PDDLParser.Exp.LocalBindings)">
            <summary>
            Evaluates the progression of this constraint expression in the next worlds,
            given a set of bindings.
            This function returns false if this constraint expression is not satisfied 
            in the given world;
            it returns true if the progression is always satisfied in the next worlds;
            else it returns the progressed expression.
            </summary>
            <param name="exp">The constraint expression to progress.</param>
            <param name="world">The current world.</param>
            <param name="bindings">A set of variable bindings.</param>
            <returns>True, false, undefined, or a progressed expression.</returns>
        </member>
        <member name="M:PDDLParser.ExpController.EvaluateIdle(PDDLParser.Exp.IConstraintExp,PDDLParser.World.IReadOnlyDurativeClosedWorld)">
            <summary>
            Evaluates this constraint expression in an idle world, i.e. a world which
            won't be modified by further updates.
            </summary>
            <param name="exp">The constraint expression to evaluate against an idle world.</param>
            <param name="idleWorld">The (idle) evaluation world.</param>
            <returns>True, false, or undefined.</returns>
        </member>
        <member name="M:PDDLParser.ExpController.EvaluateIdle(PDDLParser.Exp.IConstraintExp,PDDLParser.World.IReadOnlyDurativeClosedWorld,PDDLParser.Exp.LocalBindings)">
            <summary>
            Evaluates this constraint expression in an idle world, i.e. a world which
            won't be modified by further updates.
            </summary>
            <param name="exp">The constraint expression to evaluate against an idle world.</param>
            <param name="idleWorld">The (idle) evaluation world.</param>
            <param name="bindings">A set of variable bindings.</param>
            <returns>True, false, or undefined.</returns>
        </member>
        <member name="M:PDDLParser.ExpController.Update(PDDLParser.Exp.IEffect,PDDLParser.World.IReadOnlyOpenWorld,PDDLParser.World.IDurativeOpenWorld)">
            <summary>
            Updates the specified world with this effect.
            </summary>
            <param name="effect">The effect used to update the world.</param>
            <param name="evaluationWorld">The world to evaluate conditions against. Note that this is 
            usually the un-modified version of the world to update.</param>
            <param name="updateWorld">The world to update.</param>
        </member>
        <member name="M:PDDLParser.ExpController.Update(PDDLParser.Exp.IEffect,PDDLParser.World.IReadOnlyOpenWorld,PDDLParser.World.IDurativeOpenWorld,PDDLParser.ActionContext)">
            <summary>
            Updates the specified world with this effect, given an action context.
            </summary>
            <param name="effect">The effect used to update the world.</param>
            <param name="evaluationWorld">The world to evaluate conditions against. Note that this is 
            usually the un-modified version of the world to update.</param>
            <param name="updateWorld">The world to update.</param>
            <param name="actionContext">The action evaluation context.</param>
        </member>
        <member name="M:PDDLParser.ExpController.Update(PDDLParser.Exp.IEffect,PDDLParser.World.IReadOnlyOpenWorld,PDDLParser.World.IDurativeOpenWorld,PDDLParser.ActionContext,PDDLParser.Exp.LocalBindings)">
            <summary>
            Updates the specified world with this effect, given an action context of a set of
            variable bindings.
            </summary>
            <param name="effect">The effect used to update the world.</param>
            <param name="evaluationWorld">The world to evaluate conditions against. Note that this is 
            usually the un-modified version of the world to update.</param>
            <param name="updateWorld">The world to update.</param>
            <param name="actionContext">The action evaluation context.</param>
            <param name="bindings">A set of variable bindings.</param>
        </member>
        <member name="T:PDDLParser.Exception.ParserException">
            <summary>
            A ParserException is thrown if an internal error occurs in parser.
            </summary>
        </member>
        <member name="F:PDDLParser.Exception.ParserException.m_line">
            <summary>
            The line of the error. 
            </summary>
        </member>
        <member name="F:PDDLParser.Exception.ParserException.m_column">
            <summary>
            The column of the error.
            </summary>
        </member>
        <member name="F:PDDLParser.Exception.ParserException.m_file">
            <summary>
            The file where the error was detected.
            </summary>
        </member>
        <member name="M:PDDLParser.Exception.ParserException.#ctor(System.String,System.Exception)">
            <summary>
            Creates a new ParserException with a specific message and cause.
            </summary>
            <param name="message">The exception message.</param>
            <param name="cause">The exception cause.</param>
        </member>
        <member name="M:PDDLParser.Exception.ParserException.#ctor(System.String)">
            <summary>
            Creates a new ParserException with a specific message.
            </summary>
            <param name="message">The exception message.</param>
        </member>
        <member name="M:PDDLParser.Exception.ParserException.#ctor(System.String,System.String,System.Int32,System.Int32)">
            <summary>
            Creates a new ParserException with a specific message and location.
            </summary>
            <param name="message">The exception message.</param>
            <param name="file">The file where the error was detected.</param>
            <param name="line">The line where the error was detected.</param>
            <param name="column">The column where the error was detected.</param>
        </member>
        <member name="M:PDDLParser.Exception.ParserException.GetFile">
            <summary>
            Returns the file where the error was detected.
            </summary>
            <returns>The file where the error was detected.</returns>
        </member>
        <member name="M:PDDLParser.Exception.ParserException.GetColumn">
            <summary>
            Returns the column where the error was detected.
            </summary>
            <returns>The column where the error was detected.</returns>
        </member>
        <member name="M:PDDLParser.Exception.ParserException.GetLine">
            <summary>
            Returns the line where the error was detected.
            </summary>
            <returns>The line where the error was detected.</returns>
        </member>
        <member name="T:PDDLParser.Exception.BindingException">
            <summary>
            A BindingException is thrown if an attempt is made to set to retrieve the value of
            an unbound variable.
            </summary>
        </member>
        <member name="F:PDDLParser.Exception.BindingException.m_cause">
            <summary>
            The variable which caused the exception.
            </summary>
        </member>
        <member name="M:PDDLParser.Exception.BindingException.#ctor(PDDLParser.Exp.Variable)">
            <summary>
            Creates a new BindingException with a specific cause.
            </summary>
            <param name="cause">The expression that caused the exception.</param>
        </member>
        <member name="P:PDDLParser.Exception.BindingException.Message">
            <summary>
            The exception's message.
            </summary>
        </member>
        <member name="T:PDDLParser.Parser.PDDLObject">
            <summary>
            A PDDL object is a data structure representing either a parsed 
            PDDL domain or problem.
            </summary>
        </member>
        <member name="F:PDDLParser.Parser.PDDLObject.m_domainName">
            <summary>
            The domain name of this PDDL object.
            </summary>
        </member>
        <member name="F:PDDLParser.Parser.PDDLObject.m_problemName">
            <summary>
            The problem name of this PDDL object.
            </summary>
        </member>
        <member name="F:PDDLParser.Parser.PDDLObject.m_content">
            <summary>
            The type of PDDL object.
            </summary>
        </member>
        <member name="F:PDDLParser.Parser.PDDLObject.m_requirements">
            <summary>
            The requirements needed to manipulate this PDDL object.
            </summary>
        </member>
        <member name="F:PDDLParser.Parser.PDDLObject.m_constants">
            <summary>
            The constants present in this PDDL object.
            </summary>
        </member>
        <member name="F:PDDLParser.Parser.PDDLObject.m_formulas">
            <summary>
            The root formulas present in this PDDL object.
            </summary>
        </member>
        <member name="F:PDDLParser.Parser.PDDLObject.m_constraints">
            <summary>
            The trajectory constraints defined in this PDDL object.
            </summary>
        </member>
        <member name="F:PDDLParser.Parser.PDDLObject.m_actions">
            <summary>
            The actions defined in this PDDL object.
            </summary>
        </member>
        <member name="F:PDDLParser.Parser.PDDLObject.m_init">
            <summary>
            The list of elements defined in the initial state.
            </summary>
        </member>
        <member name="F:PDDLParser.Parser.PDDLObject.m_goal">
            <summary>
            The goal formulation of this PDDL object.
            </summary>
        </member>
        <member name="F:PDDLParser.Parser.PDDLObject.m_metric">
            <summary>
            The metric specification of this PDDL object.
            </summary>
        </member>
        <member name="F:PDDLParser.Parser.PDDLObject.m_domainFile">
            <summary>
            The file where the domain of this PDDL object is defined.
            </summary>
        </member>
        <member name="F:PDDLParser.Parser.PDDLObject.m_problemFile">
            <summary>
            The file where the problem of this PDDL object is defined.
            </summary>
        </member>
        <member name="F:PDDLParser.Parser.PDDLObject.m_typeSetSet">
            <summary>
            The set of all type sets defined in this PDDL object.
            </summary>
        </member>
        <member name="F:PDDLParser.Parser.PDDLObject.m_getAllGoalWorlds">
            <summary>
            A wrapper over a delegate responsible for fetching goal worlds 
            (for goal modalities expressions).
            This delegate must ultimately be implemented by the linked PDDL object.
            </summary>
        </member>
        <member name="F:PDDLParser.Parser.PDDLObject.m_allGoalWorlds">
            <summary>
            The cached set of goal worlds.
            </summary>
        </member>
        <member name="F:PDDLParser.Parser.PDDLObject.m_containsDurativeActions">
            <summary>
            Verifies whether the domain contains durative actions.
            </summary>
        </member>
        <member name="F:PDDLParser.Parser.PDDLObject.m_uniqueNameCounter">
            <summary>
            Counts the number of dummy formulas created with CreateDummyFormula.
            </summary>
        </member>
        <member name="F:PDDLParser.Parser.PDDLObject.m_createParsableUniqueNames">
            <summary>
            This is only used in testing, in order to parse the dummy formulas created by
            CreateDummyFormula.
            </summary>
        </member>
        <member name="F:PDDLParser.Parser.PDDLObject.m_existingNames">
            <summary>
            This dictionary contains all existing predicates, functions and constants.
            </summary>
        </member>
        <member name="F:PDDLParser.Parser.PDDLObject.m_allPreferences">
            <summary>
            All preferences listed in this PDDL object.
            </summary>
        </member>
        <member name="F:PDDLParser.Parser.PDDLObject.m_allPreferenceCounters">
            <summary>
            The counters associated with the preferences of this PDDL object.
            (Only preferences over actions preconditions have a corresponding counter).
            There is a unique counter per name, hence the storage in a dictionary.
            </summary>
        </member>
        <member name="F:PDDLParser.Parser.PDDLObject.m_constraintPreferences">
            <summary>
            The constraint preferences listed in this PDDL object.
            </summary>
        </member>
        <member name="F:PDDLParser.Parser.PDDLObject.m_allIsViolatedExps">
            <summary>
            The is-violated expressions listed in this PDDL object.
            </summary>
        </member>
        <member name="M:PDDLParser.Parser.PDDLObject.GetAllGoalWorlds">
            <summary>
            Enumerates all the worlds within which this logical expression evaluates to true.
            This method is used to support the goal modality expressions.
            A cache is used to store the hashset of goal worlds.
            </summary>
            <returns>All the worlds satisfying this logical expression.</returns>
        </member>
        <member name="M:PDDLParser.Parser.PDDLObject.#ctor">
            <summary>
            Creates a new PDDL object.
            </summary>
        </member>
        <member name="M:PDDLParser.Parser.PDDLObject.Preprocess">
            <summary>
            Preprocesses this PDDL object.
            This function assigns unique IDs to described formulas, assigns type sets where needed,
            and does a lot of other cool stuff.
            </summary>
        </member>
        <member name="M:PDDLParser.Parser.PDDLObject.GetInvariantDescribedFormulas">
            <summary>
            Retrieves all invariant described formulas in this PDDL object.
            </summary>
            <returns>All invariant described formulas in this PDDL object.</returns>
        </member>
        <member name="M:PDDLParser.Parser.PDDLObject.CreateUniqueName(System.String)">
            <summary>
            Returns a new unique name used by dummy atomic formulas.
            </summary>
            <param name="prefix">The prefix to use.</param>
            <returns>A new unique name used by dummy atomic formulas.</returns>
        </member>
        <member name="M:PDDLParser.Parser.PDDLObject.CreateDummyFormula(System.String,System.Collections.Generic.List{PDDLParser.Exp.Term.ObjectParameterVariable},System.Boolean,System.Boolean)">
            <summary>
            Creates a dummy atomic formula application with the given attributes.
            </summary>
            <param name="prefix">The prefix to use.</param>
            <param name="args">The arguments of the formula.</param>
            <param name="detectCycles">Whether the cycle detection mechanism should use this formula.</param>
            <param name="addToKnownPredicates">Whether to add this formula to the set of known predicates.</param>
            <returns>A new atomic formula application generated from the specified attributes.</returns>
        </member>
        <member name="M:PDDLParser.Parser.PDDLObject.CreateDummyFormula(System.String,System.Boolean,System.Boolean)">
            <summary>
            Creates a dummy atomic formula application with the given attributes.
            </summary>
            <param name="prefix">The prefix to use.</param>
            <param name="detectCycles">Whether the cycle detection mechanism should use this formula.</param>
            <param name="addToKnownPredicates">Whether to add this formula to the set of known predicates.</param>
            <returns>A new atomic formula application generated from the specified attributes.</returns>
        </member>
        <member name="M:PDDLParser.Parser.PDDLObject.CreatePreferenceCounter(System.String)">
            <summary>
            Returns the counter associated with the given preference name, and creates it if necessary.
            Preference counters are only created in domains, since they can only result from the
            transformation of action condition preferences.
            </summary>
            <param name="prefName">Preference name</param>
            <returns>The preference counter</returns>
        </member>
        <member name="M:PDDLParser.Parser.PDDLObject.GetPreferenceCounter(System.String)">
            <summary>
            Returns the counter associated with the given preference name, without creating it.
            </summary>
            <param name="prefName">Preference name</param>
            <returns>The preference counter, or null if it does not exist.</returns>
            <seealso cref="M:PDDLParser.Parser.PDDLObject.CreatePreferenceCounter(System.String)"/>
        </member>
        <member name="M:PDDLParser.Parser.PDDLObject.CreateUnnamedConditionPreference(PDDLParser.Exp.ILogicalExp)">
            <summary>
            Creates a new unnamed condition preference.
            Note that this new condition preference is assigned a unique name.
            </summary>
            <param name="exp">The preference condition.</param>
            <returns>A new condition preference with a generated unique name.</returns>
        </member>
        <member name="M:PDDLParser.Parser.PDDLObject.CreateUnnamedConstraintPreference(PDDLParser.Exp.IConstraintExp,System.Collections.Generic.List{PDDLParser.Exp.Term.ObjectParameterVariable})">
            <summary>
            Creates a new unnamed constraint preference with the given variables.
            Note that this new constraint preference is assigned a unique name.
            </summary>
            <param name="exp">The constraint expression.</param>
            <param name="vars">The list of variables used in the constraint.</param>
            <returns>A new unnamed constraint preference with the given variables</returns>
        </member>
        <member name="M:PDDLParser.Parser.PDDLObject.AddPreference(PDDLParser.Exp.IPrefExp)">
            <summary>
            Adds a new preference to the list of preferences.
            </summary>
            <param name="pref">The new preference to add.</param>
        </member>
        <member name="M:PDDLParser.Parser.PDDLObject.ToDomainString">
            <summary>
            Returns a string representation as a domain.
            </summary>
            <returns>A string representation as a domain.</returns>
        </member>
        <member name="M:PDDLParser.Parser.PDDLObject.ToPartialProblemString">
            <summary>
            Returns a string representation as a partial problem.
            </summary>
            <returns>A string representation as a partial problem.</returns>
        </member>
        <member name="M:PDDLParser.Parser.PDDLObject.ToFullProblemString">
            <summary>
            Returns a string representation as a full problem.
            </summary>
            <returns>A string representation as a full problem.</returns>
        </member>
        <member name="M:PDDLParser.Parser.PDDLObject.RequirementsToString">
            <summary>
            Returns a string representation of the requirements.
            </summary>
            <returns>A string representation of the requirements.</returns>
        </member>
        <member name="M:PDDLParser.Parser.PDDLObject.TypesToString">
            <summary>
            Returns a string representation of all the types.
            </summary>
            <returns>A string representation of all the types.</returns>
        </member>
        <member name="M:PDDLParser.Parser.PDDLObject.ConstantsToString(System.String)">
            <summary>
            Returns a string representation of the constants.
            </summary>
            <param name="label">The label to use.</param>
            <returns>A string representation of the constants.</returns>
        </member>
        <member name="M:PDDLParser.Parser.PDDLObject.PredicatesToString">
            <summary>
            Returns a string representation of the predicates.
            </summary>
            <returns>A string representation of the predicates.</returns>
        </member>
        <member name="M:PDDLParser.Parser.PDDLObject.FluentsToString">
            <summary>
            Returns a string representation of the fluents.
            </summary>
            <returns>A string representation of the fluents.</returns>
        </member>
        <member name="M:PDDLParser.Parser.PDDLObject.ConstraintsToString">
            <summary>
            Returns a string representation of the constraints.
            </summary>
            <returns>A string representation of the constraints.</returns>
        </member>
        <member name="M:PDDLParser.Parser.PDDLObject.DefinedFormulasToString">
            <summary>
            Returns a string representation of the defined formulas.
            </summary>
            <returns>A string representation of the defined formulas.</returns>
        </member>
        <member name="M:PDDLParser.Parser.PDDLObject.ActionsToString">
            <summary>
            Returns a string representation of the actions.
            </summary>
            <returns>A string representation of the actions.</returns>
        </member>
        <member name="M:PDDLParser.Parser.PDDLObject.MetricToString">
            <summary>
            Returns a string representation of the metric.
            </summary>
            <returns>A string representation of the metric.</returns>
        </member>
        <member name="M:PDDLParser.Parser.PDDLObject.InitToString">
            <summary>
            Returns a string representation of the initial elements.
            </summary>
            <returns>A string representation of the initial elements.</returns>
        </member>
        <member name="M:PDDLParser.Parser.PDDLObject.GoalToString">
            <summary>
            Returns a string representation of the goal.
            </summary>
            <returns>A string representation of the goal.</returns>
        </member>
        <member name="M:PDDLParser.Parser.PDDLObject.Equals(System.Object)">
            <summary>
            Returns true if this PDDL object is equal to another object.
            </summary>
            <param name="obj">The other object to test for equality.</param>
            <returns>True if this PDDL object is equal to the other object; otherwise, false.</returns>
        </member>
        <member name="M:PDDLParser.Parser.PDDLObject.GetHashCode">
            <summary>
            Returns the hash code of this PDDL object.
            </summary>
            <returns>The hash code of this PDDL object.</returns>
        </member>
        <member name="M:PDDLParser.Parser.PDDLObject.ToString">
            <summary>
            Returns a string representation of this PDDL object.
            </summary>
            <returns>A string representation of this PDDL object.</returns>
        </member>
        <member name="P:PDDLParser.Parser.PDDLObject.Content">
            <summary>
            The type of PDDL object.
            </summary>
        </member>
        <member name="P:PDDLParser.Parser.PDDLObject.DomainName">
            <summary>
            The domain name.
            </summary>
        </member>
        <member name="P:PDDLParser.Parser.PDDLObject.ProblemName">
            <summary>
            The problem name.
            </summary>
        </member>
        <member name="P:PDDLParser.Parser.PDDLObject.Requirements">
            <summary>
            The requirements needed to manipulate this PDDL object.
            </summary>
        </member>
        <member name="P:PDDLParser.Parser.PDDLObject.Constants">
            <summary>
            The constants present in this PDDL object.
            </summary>
        </member>
        <member name="P:PDDLParser.Parser.PDDLObject.TypeSetSet">
            <summary>
            The set of all type sets defined in this PDDL object.
            </summary>
        </member>
        <member name="P:PDDLParser.Parser.PDDLObject.Formulas">
            <summary>
            The root formulas present in this PDDL object.
            </summary>
        </member>
        <member name="P:PDDLParser.Parser.PDDLObject.InvariantDescribedFormulas">
            <summary>
            Returns all invariant described formulas (described formulas which are never modified
            by actions effects, timed initial literals, or anything else).
            </summary>
        </member>
        <member name="P:PDDLParser.Parser.PDDLObject.VariantDescribedFormulas">
            <summary>
            Returns all variant described formulas (described formulas which can be modified by 
            actions effects, timed initial literals, or something else).
            </summary>
        </member>
        <member name="P:PDDLParser.Parser.PDDLObject.Constraints">
            <summary>
            The trajectory constraints defined in this PDDL object.
            </summary>
        </member>
        <member name="P:PDDLParser.Parser.PDDLObject.Actions">
            <summary>
            The actions defined in this PDDL object.
            </summary>
        </member>
        <member name="P:PDDLParser.Parser.PDDLObject.InitialWorld">
            <summary>
            The list of elements defined in the initial state.
            </summary>
        </member>
        <member name="P:PDDLParser.Parser.PDDLObject.Goal">
            <summary>
            The goal formulation of this PDDL object.
            </summary>
        </member>
        <member name="P:PDDLParser.Parser.PDDLObject.Metric">
            <summary>
            The metric specification of this PDDL object.
            </summary>
        </member>
        <member name="P:PDDLParser.Parser.PDDLObject.DomainFile">
            <summary>
            The file where the domain of this PDDL object is defined.
            </summary>
        </member>
        <member name="P:PDDLParser.Parser.PDDLObject.ProblemFile">
            <summary>
            The file where the problem of this PDDL object is defined.
            </summary>
        </member>
        <member name="P:PDDLParser.Parser.PDDLObject.ContainsDurativeActions">
            <summary>
            Verifies whether the domain contains durative actions.
            </summary>
        </member>
        <member name="P:PDDLParser.Parser.PDDLObject.ExistingNames">
            <summary>
            Returns the dictionary of the names of all existing predicates, functions and constants.
            </summary>
        </member>
        <member name="P:PDDLParser.Parser.PDDLObject.AllPreferences">
            <summary>
            All preferences listed in this PDDL object.
            </summary>
        </member>
        <member name="P:PDDLParser.Parser.PDDLObject.AllPreferenceCounters">
            <summary>
            The counters associated with the preferences of this PDDL object.
            </summary>
        </member>
        <member name="P:PDDLParser.Parser.PDDLObject.ConstraintPreferences">
            <summary>
            The constraint preferences listed in this PDDL object.
            </summary>
        </member>
        <member name="P:PDDLParser.Parser.PDDLObject.AllIsViolatedExpressions">
            <summary>
            The is-violated expressions listed in this PDDL object.
            </summary>
        </member>
        <member name="P:PDDLParser.Parser.PDDLObject.GetAllGoalWorldsInstance">
            <summary>
            A wrapper over a delegate responsible for fetching goal worlds 
            (for goal modalities expressions).
            This delegate must ultimately be implemented by the linked PDDL object.
            </summary>
        </member>
        <member name="T:PDDLParser.Parser.PDDLObject.GetAllGoalWorldsDeferredExecution">
            <summary>
            This class is used to defer the actual assignation of goal modalities delegate function,
            since these are parsed in the domain while their delegate function must point to the
            PDDL problem's function instead.
            </summary>
        </member>
        <member name="M:PDDLParser.Parser.PDDLObject.GetAllGoalWorldsDeferredExecution.getAllGoalWorlds">
            <summary>
            Enumerates all the worlds within which this logical expression evaluates to true.
            This call is simply forwarded to the inner delegate.
            </summary>
            <returns>All the worlds satisfying this logical expression.</returns>
        </member>
        <member name="P:PDDLParser.Parser.PDDLObject.GetAllGoalWorldsDeferredExecution.Del">
            <summary>
            The actual delegate to which the [getAllGoalWorlds()] call must be forwarded.
            </summary>
        </member>
        <member name="T:PDDLParser.Parser.PDDLObject.PDDLContent">
            <summary>
            This enumeration lists all the the possible types of PDDL objects.
            </summary>
        </member>
        <member name="F:PDDLParser.Parser.PDDLObject.PDDLContent.DOMAIN">
            <summary>
            A PDDL domain.
            </summary>
        </member>
        <member name="F:PDDLParser.Parser.PDDLObject.PDDLContent.PARTIAL_PROBLEM">
            <summary>
            A PDDL partial problem.
            </summary>
        </member>
        <member name="F:PDDLParser.Parser.PDDLObject.PDDLContent.FULL_PROBLEM">
            <summary>
            A PDDL full problem (domain + problem information).
            </summary>
        </member>
        <member name="T:PDDLParser.Exp.Numeric.TLPlan.NArityMax">
            <summary>
            This class implements the max function.
            This is not part of PDDL; it was rather added for TLPlan.
            </summary>
        </member>
        <member name="M:PDDLParser.Exp.Numeric.TLPlan.NArityMax.#ctor(System.Collections.Generic.List{PDDLParser.Exp.INumericExp})">
            <summary>
            Creates a new max function with the specified arguments.
            </summary>
            <param name="args">The arguments of the new max function.</param>
        </member>
        <member name="M:PDDLParser.Exp.Numeric.TLPlan.NArityMax.Calculate(System.Double[])">
            <summary>
            Returns the largest argument.
            </summary>
            <param name="args">The arguments to call the function with.</param>
            <returns>The largest argument.</returns>
        </member>
        <member name="T:PDDLParser.Exp.Formula.NumericFluent">
            <summary>
            A numeric fluent is a described formula which is associated with a numeric value.
            </summary>
        </member>
        <member name="M:PDDLParser.Exp.Formula.NumericFluent.#ctor(System.String,System.Collections.Generic.List{PDDLParser.Exp.Term.ObjectParameterVariable},PDDLParser.Exp.Formula.DescribedFormula.Attributes)">
            <summary>
            Creates a new numeric fluent with the specified name and arguments.
            </summary>
            <param name="name">The name of the new numeric fluent.</param>
            <param name="arguments">The arguments of the new numeric fluent.</param>
            <param name="attributes">The new described formula's attributes.</param>
        </member>
        <member name="M:PDDLParser.Exp.Formula.NumericFluent.Instantiate(System.Collections.Generic.List{PDDLParser.Exp.ITerm})">
            <summary>
            Instantiates a formula application associated with this numeric fluent.
            </summary>
            <param name="arguments">Arguments of the formula application to instantiate.</param>
            <returns>A new numeric fluent application associated with this numeric fluent.</returns>
        </member>
        <member name="M:PDDLParser.Exp.Formula.NumericFluent.ToTypedString">
            <summary>
            Returns a typed string representation of this formula.
            </summary>
            <returns>A typed string representation of this formula.</returns>
        </member>
        <member name="T:PDDLParser.Exp.Effect.ForallEffect">
            <summary>
            This class represents a universally quantified effect.
            </summary>
        </member>
        <member name="M:PDDLParser.Exp.Effect.ForallEffect.#ctor(System.Collections.Generic.HashSet{PDDLParser.Exp.Term.ObjectParameterVariable},PDDLParser.Exp.IEffect)">
            <summary>
            Creates a new universally quantified effect.
            </summary>
            <param name="vars">The quantified variables.</param>
            <param name="body">The body of the quantified effect.</param>
        </member>
        <member name="M:PDDLParser.Exp.Effect.ForallEffect.GenerateEquivalentExp">
            <summary>
            Creates an expression equivalent to this universally quantified effect.
            </summary>
            <returns>An expression equivalent to this universally quantified effect.</returns>
        </member>
        <member name="M:PDDLParser.Exp.Effect.ForallEffect.Update(PDDLParser.World.IReadOnlyOpenWorld,PDDLParser.World.IDurativeOpenWorld,PDDLParser.Exp.LocalBindings,PDDLParser.ActionContext)">
            <summary>
            Updates the specified world with this effect.
            A universal effect updates the world for all substitutions of its quantified variables.
            </summary>
            <param name="evaluationWorld">The world to evaluate conditions against.</param>
            <param name="updateWorld">The world to update.</param>
            <param name="bindings">A set of variable bindings.</param>
            <param name="actionContext">The action evaluation context.</param>
        </member>
        <member name="M:PDDLParser.Exp.Effect.ForallEffect.GetModifiedDescribedFormulas">
            <summary>
            Retrieves all the described formulas modified by this effect.
            </summary>
            <returns>All the described formulas modified by this effect.</returns>
        </member>
        <member name="T:PDDLParser.Exp.Constraint.TLPlan.AbsoluteTEventuallyExp">
            <summary>
            Represents the "t-eventually" constraint expression. This is a time-bounded version of
            TLPlan's "eventually" constraint expression, which is equivalent to the  <see cref="T:PDDLParser.Exp.Constraint.SometimeExp"/>
            constraint expression. This is not part of the PDDL language; it was rather added for TLPlan.
            This constraint expression uses absolute timestamps.
            </summary>
            <remarks>
            This object should only be created by <see cref="T:PDDLParser.Exp.Constraint.TLPlan.TEventuallyExp"/> constraint expressions.
            </remarks>
            <seealso cref="T:PDDLParser.Exp.Constraint.TLPlan.TEventuallyExp"/>
        </member>
        <member name="M:PDDLParser.Exp.Constraint.TLPlan.AbsoluteTEventuallyExp.#ctor(PDDLParser.Exp.Struct.TimeInterval,PDDLParser.Exp.IConstraintExp)">
            <summary>
            Creates a new "t-eventually" constraint expression with absolute timestamps.
            </summary>
            <param name="absoluteInterval">The absolute interval.</param>
            <param name="exp">The body of the constraint expression.</param>
        </member>
        <member name="M:PDDLParser.Exp.Constraint.TLPlan.AbsoluteTEventuallyExp.Progress(PDDLParser.World.IReadOnlyDurativeClosedWorld,PDDLParser.Exp.LocalBindings)">
            <summary>
            Evaluates the progression of this constraint expression in the next worlds.
            </summary>
            <param name="world">The current world.</param>
            <param name="bindings">A set of variable bindings.</param>
            <returns>True, false, undefined, or a progressed expression.</returns>
            <exception cref="T:PDDLParser.Exception.BindingException">A BindingException is thrown if an attempt
            is made to evaluate an unbound variable.</exception>
            <seealso cref="M:PDDLParser.Exp.IConstraintExp.Progress(PDDLParser.World.IReadOnlyDurativeClosedWorld,PDDLParser.Exp.LocalBindings)"/>
        </member>
        <member name="M:PDDLParser.Exp.Constraint.TLPlan.AbsoluteTEventuallyExp.EvaluateIdle(PDDLParser.World.IReadOnlyDurativeClosedWorld,PDDLParser.Exp.LocalBindings)">
            <summary>
            Evaluates this constraint expression in an idle world, i.e. a world which
            won't be modified by further updates.
            </summary>
            <param name="idleWorld">The (idle) evaluation world.</param>
            <param name="bindings">A set of variable bindings.</param>
            <returns>True, false, or undefined.</returns>
            <exception cref="T:PDDLParser.Exception.BindingException">A BindingException is thrown if an attempt
            is made to evaluate an unbound variable.</exception>
            <seealso cref="M:PDDLParser.Exp.IConstraintExp.EvaluateIdle(PDDLParser.World.IReadOnlyDurativeClosedWorld,PDDLParser.Exp.LocalBindings)"/>
        </member>
        <member name="P:PDDLParser.Exp.Constraint.TLPlan.AbsoluteTEventuallyExp.AbsoluteTimeInterval">
            <summary>
            Gets the absolute time interval.
            </summary>
        </member>
        <member name="T:PDDLParser.Exp.Comparison.NumericEqualComp">
            <summary>
            This class implements an equality numeric comparison.
            </summary>
        </member>
        <member name="M:PDDLParser.Exp.Comparison.NumericEqualComp.#ctor(PDDLParser.Exp.INumericExp,PDDLParser.Exp.INumericExp)">
            <summary>
            Creates a new equality numeric comparison.
            </summary>
            <param name="arg1">The first argument.</param>
            <param name="arg2">The second argument.</param>
        </member>
        <member name="M:PDDLParser.Exp.Comparison.NumericEqualComp.Compare(PDDLParser.Exp.Struct.Double,PDDLParser.Exp.Struct.Double)">
            <summary>
            Compares the two arguments. This comparison should return undefined if at least
            one of the two arguments is undefined.
            </summary>
            <param name="arg1">The first argument.</param>
            <param name="arg2">The second argument.</param>
            <returns>True, false, or undefined.</returns>
        </member>
        <member name="M:PDDLParser.Exp.Comparison.NumericEqualComp.Compare(PDDLParser.Exp.Struct.FuzzyDouble,PDDLParser.Exp.Struct.FuzzyDouble)">
            <summary>
            Compares the two arguments. This comparison should return undefined if at least one 
            of the two arguments is undefined, or unknown if at least one of the two arguments is 
            unknown.
            </summary>
            <param name="arg1">The first argument.</param>
            <param name="arg2">The second argument.</param>
            <returns>True, false, undefined, or unknown.</returns>
        </member>
        <member name="F:PDDLParser.Parser.Lexer.TokenMgrError.LEXICAL_ERROR">
            Lexical error occured.
        </member>
        <member name="F:PDDLParser.Parser.Lexer.TokenMgrError.STATIC_LEXER_ERROR">
            An attempt wass made to create a second instance of a static token manager.
        </member>
        <member name="F:PDDLParser.Parser.Lexer.TokenMgrError.INVALID_LEXICAL_STATE">
            Tried to change to an invalid lexical state.
        </member>
        <member name="F:PDDLParser.Parser.Lexer.TokenMgrError.LOOP_DETECTED">
            Detected (and bailed out of) an infinite loop in the token manager.
        </member>
        <member name="F:PDDLParser.Parser.Lexer.TokenMgrError.errorCode">
            Indicates the reason why the exception is thrown. It will have
            one of the above 4 values.
        </member>
        <member name="M:PDDLParser.Parser.Lexer.TokenMgrError.addEscapes(System.String)">
            Replaces unprintable characters by their espaced (or unicode escaped)
            equivalents in the given string
        </member>
        <member name="M:PDDLParser.Parser.Lexer.TokenMgrError.LexicalError(System.Boolean,System.Int32,System.Int32,System.Int32,System.String,System.Char)">
            Returns a detailed message for the Error when it is thrown by the
            token manager to indicate a lexical error.
            Parameters : 
               EOFSeen     : indicates if EOF caused the lexicl error
               curLexState : lexical state in which this error occured
               errorLine   : line number when the error occured
               errorColumn : column number when the error occured
               errorAfter  : prefix that was seen before this error occured
               curchar     : the offending character
            Note: You can customize the lexical error message by modifying this method.
        </member>
        <member name="P:PDDLParser.Parser.Lexer.TokenMgrError.Message">
             You can also modify the body of this method to customize your error messages.
             For example, cases like LOOP_DETECTED and INVALID_LEXICAL_STATE are not
             of end-users concern, so you can return something like : 
            
                 "Internal Error : Please file a bug report .... "
            
             from this method for such cases in the release version of your parser.
        </member>
        <member name="T:PDDLParser.Parser.Lexer.ParseException">
             This exception is thrown when parse errors are encountered.
             You can explicitly create objects of this exception type by
             calling the method generateParseException in the generated
             parser.
            
             You can modify this class to customize your error reporting
             mechanisms so long as you retain the public fields.
        </member>
        <member name="M:PDDLParser.Parser.Lexer.ParseException.#ctor(PDDLParser.Parser.Lexer.Token,System.Int64[][],System.String[])">
            This constructor is used by the method "generateParseException"
            in the generated parser.  Calling this constructor generates
            a new object of this type with the fields "currentToken",
            "expectedTokenSequences", and "tokenImage" set.  The bool
            flag "specialConstructor" is also set to true to indicate that
            this constructor was used to create this object.
            This constructor calls its base class with the empty string
            to force the "ToString" method of parent class "System.Exception" to
            print the error message in the form:
                ParseException: &lt;result of getMessage&gt;
        </member>
        <member name="M:PDDLParser.Parser.Lexer.ParseException.#ctor">
            The following constructors are for use by you for whatever
            purpose you can think of.  Constructing the exception in this
            manner makes the exception behave in the normal way - i.e., as
            documented in the class "System.Exception".  The fields "errorToken",
            "expectedTokenSequences", and "tokenImage" do not contain
            relevant information.  The JavaCC generated code does not use
            these constructors.
        </member>
        <member name="F:PDDLParser.Parser.Lexer.ParseException.specialConstructor">
            This variable determines which constructor was used to create
            this object and thereby affects the semantics of the
            "getMessage" method (see below).
        </member>
        <member name="F:PDDLParser.Parser.Lexer.ParseException.currentToken">
            This is the last token that has been consumed successfully.  If
            this object has been created due to a parse error, the token
            followng this token will (therefore) be the first error token.
        </member>
        <member name="F:PDDLParser.Parser.Lexer.ParseException.expectedTokenSequences">
            Each entry in this array is an array of integers.  Each array
            of integers represents a sequence of tokens (by their ordinal
            values) that is expected at this point of the parse.
        </member>
        <member name="F:PDDLParser.Parser.Lexer.ParseException.tokenImage">
            This is a reference to the "tokenImage" array of the generated
            parser within which the parse error occurred.  This array is
            defined in the generated ...Constants interface.
        </member>
        <member name="F:PDDLParser.Parser.Lexer.ParseException.eol">
            The end of line string for this machine.
        </member>
        <member name="M:PDDLParser.Parser.Lexer.ParseException.add_escapes(System.String)">
            Used to convert raw characters to their escaped version
            when these raw version cannot be used as part of an ASCII
            string literal.
        </member>
        <member name="P:PDDLParser.Parser.Lexer.ParseException.Message">
            This method has the standard behavior when this object has been
            created using the standard constructors.  Otherwise, it uses
            "currentToken" and "expectedTokenSequences" to generate a parse
            error message and returns it.  If this object has been created
            due to a parse error, and you do not catch it (it gets thrown
            from the parser), then this method is called during the printing
            of the final stack trace, and hence the correct error message
            gets displayed.
        </member>
        <member name="T:PDDLParser.Exp.Numeric.TLPlan.UnaryRound">
            <summary>
            This class implements the round function.
            This is not part of PDDL; it was rather added for TLPlan.
            </summary>
        </member>
        <member name="M:PDDLParser.Exp.Numeric.TLPlan.UnaryRound.#ctor(PDDLParser.Exp.INumericExp)">
            <summary>
            Creates a new round function with the specified argument.
            </summary>
            <param name="arg">The argument of the new round function.</param>
        </member>
        <member name="M:PDDLParser.Exp.Numeric.TLPlan.UnaryRound.Calculate(System.Double)">
            <summary>
            Rounds the argument to the nearest integer (away from 0).
            </summary>
            <param name="arg">The argument.</param>
            <returns>The argument rounded to the nearest integer (away from 0).</returns>
        </member>
        <member name="T:PDDLParser.Exp.Numeric.TLPlan.NArityMin">
            <summary>
            This class implements the min function.
            This is not part of PDDL; it was rather added for TLPlan.
            </summary>
        </member>
        <member name="M:PDDLParser.Exp.Numeric.TLPlan.NArityMin.#ctor(System.Collections.Generic.List{PDDLParser.Exp.INumericExp})">
            <summary>
            Creates a new min function with the specified arguments.
            </summary>
            <param name="args">The arguments of the new min function.</param>
        </member>
        <member name="M:PDDLParser.Exp.Numeric.TLPlan.NArityMin.Calculate(System.Double[])">
            <summary>
            Returns the smallest argument.
            </summary>
            <param name="args">The arguments to call the function with.</param>
            <returns>The smallest argument.</returns>
        </member>
        <member name="T:PDDLParser.Exp.Formula.NumericFluentApplication">
            <summary>
            A numeric fluent application is an application of a numeric fluent.
            Note that a numeric fluent application is undefined until its value has been set.
            </summary>
        </member>
        <member name="M:PDDLParser.Exp.Formula.NumericFluentApplication.#ctor(PDDLParser.Exp.Formula.NumericFluent,System.Collections.Generic.List{PDDLParser.Exp.ITerm})">
            <summary>
            Creates a new numeric fluent application of a specified numeric fluent and a given
            list of arguments.
            </summary>
            <param name="fluent">The numeric fluent to instantiate.</param>
            <param name="arguments">The arguments of the new numeric fluent application.</param>
        </member>
        <member name="M:PDDLParser.Exp.Formula.NumericFluentApplication.Apply(System.Collections.Generic.List{PDDLParser.Exp.ITerm})">
            <summary>
            Returns a copy of this numeric fluent application with the specified arguments.
            </summary>
            <param name="arguments">The arguments of the new fluent application.</param>
            <returns>A copy of this expression with the given arguments.</returns>
        </member>
        <member name="M:PDDLParser.Exp.Formula.NumericFluentApplication.Evaluate(PDDLParser.World.IReadOnlyOpenWorld,PDDLParser.Exp.LocalBindings)">
            <summary>
            Evaluates this numeric expression in the specified open world.
            A numeric fluent application is evaluated by first evaluating its arguments and then
            by retrieving its value in the specified world.
            </summary>
            <param name="world">The evaluation world.</param>
            <param name="bindings">A set of variable bindings.</param>
            <returns>Undefined, unknown, or the resulting numeric value.</returns>
        </member>
        <member name="M:PDDLParser.Exp.Formula.NumericFluentApplication.Simplify(PDDLParser.World.IReadOnlyOpenWorld,PDDLParser.Exp.LocalBindings)">
            <summary>
            Simplifies this numeric expression by evaluating its known expression parts.
            A numeric fluent application is simplified by first simplifying its arguments and then
            by attempting to retrieve its value in the specified world (if it is ground).
            </summary>
            <param name="world">The evaluation world.</param>
            <param name="bindings">A set of variable bindings.</param>
            <returns>Undefined, a numeric value, or the simplified expression.</returns>
        </member>
        <member name="M:PDDLParser.Exp.Formula.NumericFluentApplication.Evaluate(PDDLParser.World.IReadOnlyClosedWorld,PDDLParser.Exp.LocalBindings)">
            <summary>
            Evaluates this numeric expression in the specified closed world.
            A numeric fluent application is evaluated by first evaluating its arguments and then
            by retrieving its value in the specified world.
            </summary>
            <param name="world">The evaluation world.</param>
            <param name="bindings">A set of variable bindings.</param>
            <returns>Undefined, or the resulting numeric value.</returns>
        </member>
        <member name="M:PDDLParser.Exp.Formula.NumericFluentApplication.CompareTo(PDDLParser.Exp.Formula.NumericFluentApplication)">
            <summary>
            Compares two numeric fluent applications.
            </summary>
            <param name="other">The other numeric fluent application to compare this formula to.</param>
            <returns>An integer representing the total order relation between the two formulas.</returns>
        </member>
        <member name="P:PDDLParser.Exp.Formula.NumericFluentApplication.RootNumericFluent">
            <summary>
            Gets the numeric fluent associated with this numeric fluent application.
            </summary>
        </member>
        <member name="T:PDDLParser.Exp.Effect.Assign.Increase">
            <summary>
            This class represents a fluent increase operation.
            </summary>
        </member>
        <member name="M:PDDLParser.Exp.Effect.Assign.Increase.#ctor(PDDLParser.Exp.Formula.NumericFluentApplication,PDDLParser.Exp.INumericExp)">
            <summary>
            Creates a new fluent increase operation.
            </summary>
            <param name="head">The numeric fluent whose value is to be decreased.</param>
            <param name="body">The numeric value to decrease the fluent by.</param>
        </member>
        <member name="M:PDDLParser.Exp.Effect.Assign.Increase.UpdateWorldWithAssignEffect(PDDLParser.Exp.Formula.FluentApplication,PDDLParser.World.IDurativeOpenWorld,PDDLParser.Exp.LocalBindings)">
            <summary>
            Updates the world with this fluent assignment.
            </summary>
            <param name="head">The evaluated fluent application to update.</param>
            <param name="updateWorld">The world to update.</param>
            <param name="bindings">A set of variable bindings.</param>
        </member>
        <member name="T:PDDLParser.Exp.Effect.Assign.Decrease">
            <summary>
            This class represents a fluent decrease operation.
            </summary>
        </member>
        <member name="M:PDDLParser.Exp.Effect.Assign.Decrease.#ctor(PDDLParser.Exp.Formula.NumericFluentApplication,PDDLParser.Exp.INumericExp)">
            <summary>
            Creates a new fluent decrease operation.
            </summary>
            <param name="head">The numeric fluent whose value is to be decreased.</param>
            <param name="body">The numeric value to decrease the fluent by.</param>
        </member>
        <member name="M:PDDLParser.Exp.Effect.Assign.Decrease.UpdateWorldWithAssignEffect(PDDLParser.Exp.Formula.FluentApplication,PDDLParser.World.IDurativeOpenWorld,PDDLParser.Exp.LocalBindings)">
            <summary>
            Updates the world with this fluent assignment.
            </summary>
            <param name="head">The evaluated fluent application to update.</param>
            <param name="updateWorld">The world to update.</param>
            <param name="bindings">A set of variable bindings.</param>
        </member>
        <member name="T:PDDLParser.Exp.Constraint.TLPlan.EventuallyExp">
            <summary>
            Represents the "eventually" constraint expression. This is equivalent to
            <see cref="T:PDDLParser.Exp.Constraint.SometimeExp"/> constraint expression.
            This is not part of the PDDL language; it was rather added for TLPlan.
            </summary>
        </member>
        <member name="M:PDDLParser.Exp.Constraint.TLPlan.EventuallyExp.#ctor(PDDLParser.Exp.IConstraintExp)">
            <summary>
            Creates a new "eventually" constraint expression.
            </summary>
            <param name="arg">The body of the constraint expression.</param>
        </member>
        <member name="M:PDDLParser.Exp.Constraint.TLPlan.EventuallyExp.ToString">
            <summary>
            Returns a string representation of this expression.
            </summary>
            <returns>A string representation of this expression.</returns>
        </member>
        <member name="M:PDDLParser.Exp.Constraint.TLPlan.EventuallyExp.ToTypedString">
            <summary>
            Returns a typed string of this expression.
            </summary>
            <returns>A typed string representation of this expression.</returns>
        </member>
        <member name="T:PDDLParser.Exp.Constraint.AtEndConstraintExp">
            <summary>
            Represents a constraint expression which must be evaluated at the end of the trajectory.
            </summary>
        </member>
        <member name="M:PDDLParser.Exp.Constraint.AtEndConstraintExp.#ctor(PDDLParser.Exp.ILogicalExp)">
            <summary>
            Creates a new constraint expression which must be evaluated at the end of the trajectory.
            </summary>
            <param name="exp">The logical expression which must be evaluated at the end of the trajectory.</param>
        </member>
        <member name="M:PDDLParser.Exp.Constraint.AtEndConstraintExp.Progress(PDDLParser.World.IReadOnlyDurativeClosedWorld,PDDLParser.Exp.LocalBindings)">
            <summary>
            Evaluates the progression of this constraint expression in the next worlds.
            </summary>
            <param name="world">The current world.</param>
            <param name="bindings">A set of variable bindings.</param>
            <returns>True, false, undefined, or a progressed expression.</returns>
            <exception cref="T:PDDLParser.Exception.BindingException">A BindingException is thrown if an attempt
            is made to evaluate an unbound variable.</exception>
            <seealso cref="M:PDDLParser.Exp.IConstraintExp.Progress(PDDLParser.World.IReadOnlyDurativeClosedWorld,PDDLParser.Exp.LocalBindings)"/>
        </member>
        <member name="M:PDDLParser.Exp.Constraint.AtEndConstraintExp.EvaluateIdle(PDDLParser.World.IReadOnlyDurativeClosedWorld,PDDLParser.Exp.LocalBindings)">
            <summary>
            Evaluates this constraint expression in an idle world, i.e. a world which
            won't be modified by further updates.
            </summary>
            <param name="idleWorld">The (idle) evaluation world.</param>
            <param name="bindings">A set of variable bindings.</param>
            <returns>True, false, or undefined.</returns>
            <exception cref="T:PDDLParser.Exception.BindingException">A BindingException is thrown if an attempt
            is made to evaluate an unbound variable.</exception>
            <seealso cref="M:PDDLParser.Exp.IConstraintExp.EvaluateIdle(PDDLParser.World.IReadOnlyDurativeClosedWorld,PDDLParser.Exp.LocalBindings)"/>
        </member>
        <member name="M:PDDLParser.Exp.Constraint.AtEndConstraintExp.ToString">
            <summary>
            Returns a string representation of this expression.
            </summary>
            <returns>A string representation of this expression.</returns>
        </member>
        <member name="M:PDDLParser.Exp.Constraint.AtEndConstraintExp.ToTypedString">
            <summary>
            Returns a typed string of this expression.
            </summary>
            <returns>A typed string representation of this expression.</returns>
        </member>
        <member name="T:PDDLParser.Exception.NumericException">
            <summary>
            A NumericException is thrown if an attempt is made to perform an illegal
            arithmetic operation (like a division by zero).
            </summary>
        </member>
        <member name="F:PDDLParser.Exception.NumericException.m_cause">
            <summary>
            The expression that caused the exception.
            </summary>
        </member>
        <member name="F:PDDLParser.Exception.NumericException.m_arguments">
            <summary>
            The arguments the function was evaluated with.
            </summary>
        </member>
        <member name="M:PDDLParser.Exception.NumericException.#ctor(PDDLParser.Exp.IExp,System.Collections.Generic.IEnumerable{System.Double})">
            <summary>
            Creates a new NumericException with a specific message and cause.
            </summary>
            <param name="cause">The numeric expression that caused the exception.</param>
            <param name="arguments">The arguments the function was evaluated with.</param>
        </member>
        <member name="P:PDDLParser.Exception.NumericException.Message">
            <summary>
            The exception's message.
            </summary>
        </member>
        <member name="T:PDDLParser.Extensions.ObjectExtentions">
            <summary>
            Represents an extension class for any object or structure.
            </summary>
        </member>
        <member name="M:PDDLParser.Extensions.ObjectExtentions.Once``1(``0)">
            <summary>
            Returns an enumeration containing only the given object.
            </summary>
            <typeparam name="T">The type of the object.</typeparam>
            <param name="obj">The given to wrap in an enumerable.</param>
            <returns>An enumeration containing only the given object.</returns>
        </member>
        <member name="M:PDDLParser.Extensions.ObjectExtentions.EqualsOrBothNull(System.Object,System.Object)">
            <summary>
            Returns whether two objects are equal, or both null.
            </summary>
            <param name="obj">The first object.</param>
            <param name="other">The second object.</param>
            <returns>Whether two objects are equal or both null.</returns>
        </member>
        <member name="T:PDDLParser.Extensions.EnumerableExtensions">
            <summary>
            Represents an extension class for IEnumerable's.
            </summary>
        </member>
        <member name="M:PDDLParser.Extensions.EnumerableExtensions.GetOrderedEnumerableHashCode``1(System.Collections.Generic.IEnumerable{``0})">
            <summary>
            Returns that hashcode of the given enumerable; the hashcode takes into account the order of the elements.
            </summary>
            <typeparam name="T">The enumeration type.</typeparam>
            <param name="enumerable">The enumerable to compute the hashcode for.</param>
            <returns>The order-dependent hashcode of the enumerable.</returns>
        </member>
        <member name="M:PDDLParser.Extensions.EnumerableExtensions.GetUnorderedEnumerableHashCode``1(System.Collections.Generic.IEnumerable{``0})">
            <summary>
            Returns that hashcode of the given enumerable; the hashcode is order-independent.
            </summary>
            <typeparam name="T">The enumeration type.</typeparam>
            <param name="enumerable">The enumerable to compute the hashcode for.</param>
            <returns>The order-independent hashcode of the enumerable.</returns>
        </member>
        <member name="M:PDDLParser.Extensions.EnumerableExtensions.SequenceCompareTo``1(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``0})">
            <summary>
            Compares two enumerables, taking the order into account. Note that comparing the count
            of both enumerables before calling this may be faster.
            </summary>
            <typeparam name="T">The type of the enumerable.</typeparam>
            <param name="enumerable">The current enumerable used to compare.</param>
            <param name="other">The enumerable to compare to.</param>
            <returns>An integer representing the total order relation between the two enumerables.</returns>
        </member>
        <member name="M:PDDLParser.Extensions.EnumerableExtensions.ContainsNull``1(System.Collections.Generic.IEnumerable{``0})">
            <summary>
            Verifies whether the given enumerable contains a null element.
            </summary>
            <typeparam name="T">The type of the enumerable.</typeparam>
            <param name="enumerable">The enumerable to verify.</param>
            <returns>Whether the enumerable contains a null element.</returns>
        </member>
        <member name="M:PDDLParser.Extensions.EnumerableExtensions.IsEmpty``1(System.Collections.Generic.IEnumerable{``0})">
            <summary>
            Returns whether the enumerable is empty. This is more efficient than using the 
            extension Count method, since Count has to traverse the whole enumerable.
            </summary>
            <typeparam name="T">The type of the enumerable.</typeparam>
            <param name="enumerable">The enumerable to check for emptiness.</param>
            <returns>Whether the enumerable is empty.</returns>
        </member>
        <member name="M:PDDLParser.Extensions.EnumerableExtensions.Enumerable``1(``0[])">
            <summary>
            Returns an enumerable containing the given elements.
            </summary>
            <typeparam name="T">The type of the enumerable.</typeparam>
            <param name="values">All the elements to put in the enumerable.</param>
            <returns>An enumerable containing the given elements.</returns>
        </member>
        <member name="M:PDDLParser.Extensions.EnumerableExtensions.Flatten``1(System.Collections.Generic.IEnumerable{System.Collections.Generic.IEnumerable{``0}})">
            <summary>
            Flattens an enumerable of enumerables into a single enumerable. Note that this
            only flattens one "layer" of enumerables, i.e. an enumerable of enumerables of
            enumerables will be flattened in an enumerable of enumerables.
            </summary>
            <typeparam name="T">The type of the flattened enumerable.</typeparam>
            <param name="enumerable">The enumerable of enumerables to flatten.</param>
            <returns>The flattened enumerable.</returns>
        </member>
        <member name="T:PDDLParser.Extensions.ListExtensions">
            <summary>
            Represents extensions methods for lists.
            </summary>
        </member>
        <member name="M:PDDLParser.Extensions.ListExtensions.ListCompareTo``1(System.Collections.Generic.List{``0},System.Collections.Generic.List{``0})">
            <summary>
            Compares two lists, taking the order into account. This first compares the counts, then 
            compares the content. Note that this should not be called from CompareTo methods if
            multiple lists have to be compared; comparing all their counts and then calling
            <see cref="M:PDDLParser.Extensions.ListExtensions.ListContentCompareTo``1(System.Collections.Generic.List{``0},System.Collections.Generic.List{``0})"/> should be faster.
            </summary>
            <typeparam name="T">The type of the list.</typeparam>
            <param name="lst1">The list which will be compared to.</param>
            <param name="lst2">The list to compare to.</param>
            <returns>An integer representing the total order relation between the two lists.</returns>
        </member>
        <member name="M:PDDLParser.Extensions.ListExtensions.ListContentCompareTo``1(System.Collections.Generic.List{``0},System.Collections.Generic.List{``0})">
            <summary>
            Compares the content of two lists, taking the order into account. This asusmes that both
            list have the same number of elements.
            </summary>
            <typeparam name="T">The type of the list.</typeparam>
            <param name="lst1">The list which will be compared to.</param>
            <param name="lst2">The list to compare to.</param>
            <returns>An integer representing the total order relation between the two lists.</returns>
        </member>
        <member name="T:PDDLParser.Extensions.DictionaryExtensions">
            <summary>
            Represents extensions methods for dictionaries.
            </summary>
        </member>
        <member name="M:PDDLParser.Extensions.DictionaryExtensions.DictionaryEqual``2(System.Collections.Generic.IDictionary{``0,``1},System.Collections.Generic.IDictionary{``0,``1})">
            <summary>
            Verifies whether two dictionaries are equals, by comparing each eky/value pair.
            </summary>
            <typeparam name="K">The type of the key.</typeparam>
            <typeparam name="V">The type of the value.</typeparam>
            <param name="dic">The first dictionary.</param>
            <param name="other">The dictionary to compare.</param>
            <returns>Whether the dictionaries are equal.</returns>
        </member>
        <member name="M:PDDLParser.Extensions.DictionaryExtensions.DictionaryGetHashCode``2(System.Collections.Generic.IDictionary{``0,``1})">
            <summary>
            Retrieves the hashcode of a dictionary.
            </summary>
            <typeparam name="K">The type of the key.</typeparam>
            <typeparam name="V">The type of the value.</typeparam>
            <param name="dic">The dictionary used to compute the hashcode.</param>
            <returns>The dictionary's hashcode.</returns>
        </member>
        <member name="M:PDDLParser.Extensions.DictionaryExtensions.DictionaryCompareTo``2(System.Collections.Generic.IDictionary{``0,``1},System.Collections.Generic.IDictionary{``0,``1},System.Collections.Generic.IEnumerable{``0}@,System.Collections.Generic.IEnumerable{``0}@)">
            <summary>
            Compares two dictionaries by sorting their keys (if necessary) and comparing their values one by one. If multiplie dictionaries
            have to be compared, it would be wiser to compare their count prior to calling this methods, as comparing the
            contents of dictionaries can be costly.
            </summary>
            <typeparam name="K">The type of the key.</typeparam>
            <typeparam name="V">The type of the value.</typeparam>
            <param name="dic">The dictionary used to compare.</param>
            <param name="other">The dictionary to compare to.</param>
            <param name="thisSortedKeys">The sorted keys of the first dictionary. This can be null, in which case the the dictionaries key will be sorted.</param>
            <param name="otherSortedKeys">The sorted keys of the second dictionary. This can be null, in which case the the dictionaries key will be sorted.</param>
            <returns>An integer representing the total order relation between the two dictionaries.</returns>
        </member>
        <member name="M:PDDLParser.Extensions.DictionaryExtensions.DictionaryMergeList``2(System.Collections.Generic.IDictionary{``0,System.Collections.Generic.List{``1}},System.Collections.Generic.IDictionary{``0,System.Collections.Generic.List{``1}})">
            <summary>
            Merges two dictionaries of lists.
            </summary>
            <typeparam name="K">The type of the key.</typeparam>
            <typeparam name="V">The type of the value.</typeparam>
            <param name="dic">The dictionary which will contain the merged list.</param>
            <param name="other">The dictionary whose lists will be merged in the other dictionary.</param>
        </member>
        <member name="T:PDDLParser.Extensions.KeyValueExtensions">
            <summary>
            Represents extension methods for KeyValuePair and enumables of KeyValuePair.
            </summary>
        </member>
        <member name="M:PDDLParser.Extensions.KeyValueExtensions.Keys``2(System.Collections.Generic.IEnumerable{System.Collections.Generic.KeyValuePair{``0,``1}})">
            <summary>
            Returns an enumerable over the keys of the KeyValuePair's.
            </summary>
            <typeparam name="K">The type of the key.</typeparam>
            <typeparam name="V">The type of the value.</typeparam>
            <param name="ienum">The enumerable to enumerate over.</param>
            <returns>An enumerable over all the keys.</returns>
        </member>
        <member name="M:PDDLParser.Extensions.KeyValueExtensions.Values``2(System.Collections.Generic.IEnumerable{System.Collections.Generic.KeyValuePair{``0,``1}})">
            <summary>
            Returns an enumerable over the values of the KeyValuePair's.
            </summary>
            <typeparam name="K">The type of the key.</typeparam>
            <typeparam name="V">The type of the value.</typeparam>
            <param name="ienum">The enumerable to enumerate over.</param>
            <returns>An enumerable over all the values.</returns>
        </member>
        <member name="M:PDDLParser.Extensions.KeyValueExtensions.SequenceCompareTo``2(System.Collections.Generic.IEnumerable{System.Collections.Generic.KeyValuePair{``0,``1}},System.Collections.Generic.IEnumerable{System.Collections.Generic.KeyValuePair{``0,``1}})">
            <summary>
            Compares to enumerables of KeyValuePair's, taking the order into account.
            </summary>
            <typeparam name="K">The type of the key.</typeparam>
            <typeparam name="V">The type of the value.</typeparam>
            <param name="ienum">The enumerable used to compare.</param>
            <param name="other">The enumerable to compare to.</param>
            <returns>An integer representing the total order relation between the two enumerables.</returns>
        </member>
        <member name="M:PDDLParser.Parser.Lexer.Lexer.generateErrorMesssage(PDDLParser.Parser.Lexer.ParseException)">
            Creates the error message from a specific parse exception.
            
            @param pe the parse exception.
            @return the error message.
        </member>
        <member name="T:PDDLParser.Parser.ErrorManager">
            <summary>
            The error manager is used to log lexing/parsing errors and warnings.
            </summary>
        </member>
        <member name="F:PDDLParser.Parser.ErrorManager.m_msgs">
            <summary>
            All messages, kept as triplets (file name, message type, actual message).
            </summary>
        </member>
        <member name="F:PDDLParser.Parser.ErrorManager.m_warningStream">
            <summary>
            The warning output stream.
            </summary>
        </member>
        <member name="F:PDDLParser.Parser.ErrorManager.m_errorStream">
            <summary>
            The error output stream.
            </summary>
        </member>
        <member name="M:PDDLParser.Parser.ErrorManager.#ctor">
            <summary>
            Creates a new error manager with the default output streams.
            </summary>
        </member>
        <member name="M:PDDLParser.Parser.ErrorManager.#ctor(System.IO.TextWriter,System.IO.TextWriter)">
            <summary>
            Creates a new error manager with the specified output streams.
            </summary>
            <param name="warningStream">The warning output stream.</param>
            <param name="errorStream">The error output stream.</param>
        </member>
        <member name="M:PDDLParser.Parser.ErrorManager.print(PDDLParser.Parser.ErrorManager.Message)">
            <summary>
            Prints all messages of the specified type.
            </summary>
            <param name="type">The type of messages to print.</param>
        </member>
        <member name="M:PDDLParser.Parser.ErrorManager.print(System.String)">
            <summary>
            Prints all the messages concerning a specific file.
            </summary>
            <param name="file">A file.</param>
        </member>
        <member name="M:PDDLParser.Parser.ErrorManager.print(PDDLParser.Parser.ErrorManager.Message,System.String)">
            <summary>
            Prints all messages of the specified type which concern a specific file.
            </summary>
            <param name="type">The type of messages to print.</param>
            <param name="file">A file.</param>
        </member>
        <member name="M:PDDLParser.Parser.ErrorManager.print(System.Collections.Generic.IEnumerable{System.Collections.Generic.KeyValuePair{PDDLParser.Parser.ErrorManager.Message,System.String}})">
            <summary>
            Print the messages to the appropriate output stream.
            </summary>
            <param name="msgs">The messages to output.</param>
        </member>
        <member name="M:PDDLParser.Parser.ErrorManager.getMessages(PDDLParser.Parser.ErrorManager.Message)">
            <summary>
            Returns all messages of the specified type.
            </summary>
            <param name="type">The type of the messages to return.</param>
            <returns>All the messages of the specified type.</returns>
        </member>
        <member name="M:PDDLParser.Parser.ErrorManager.getUntypedMessages(PDDLParser.Parser.ErrorManager.Message)">
            <summary>
            Returns all messages of the specified type. Note that only the actual messages
            are returned (and not their types).
            </summary>
            <param name="type">The type of the messages to return.</param>
            <returns>All messages of the specified type.</returns>
        </member>
        <member name="M:PDDLParser.Parser.ErrorManager.getMessages(System.String)">
            <summary>
            Returns all messages concerning a specific file.
            </summary>
            <param name="file">A file.</param>
            <returns>All messages concerning a specific file.</returns>
        </member>
        <member name="M:PDDLParser.Parser.ErrorManager.getMessages(PDDLParser.Parser.ErrorManager.Message,System.String)">
            <summary>
            Returns all messages of the specified type which concern a specific file.
            </summary>
            <param name="type">The type of the messages to return.</param>
            <param name="file">A file.</param>
            <returns>All messages of the specified type which concern a specific file.</returns>
        </member>
        <member name="M:PDDLParser.Parser.ErrorManager.clear">
            <summary>
            Reinitializes the error manager.
            </summary>
        </member>
        <member name="M:PDDLParser.Parser.ErrorManager.isEmpty">
            <summary>
            Returns true if the error manager does not contain any message, false otherwise.
            </summary>
            <returns>True if the error manager does not contain any message, false otherwise.</returns>
        </member>
        <member name="M:PDDLParser.Parser.ErrorManager.Contains(PDDLParser.Parser.ErrorManager.Message)">
            <summary>
            Returns true if the error manager contains at least one message of the specified type.
            </summary>
            <param name="type">The type of the messages to look for.</param>
            <returns>True if at least one corresponding message is found.</returns>
        </member>
        <member name="M:PDDLParser.Parser.ErrorManager.logParserError(System.String,System.String)">
            <summary>
            Logs a parser error message.
            </summary>
            <param name="msg">The error message.</param>
            <param name="file">The file where the error was encountered.</param>
        </member>
        <member name="M:PDDLParser.Parser.ErrorManager.logParserError(System.String,System.String,System.Int32,System.Int32)">
            <summary>
            Logs a parser error message.
            </summary>
            <param name="msg">The error message.</param>
            <param name="file">The file where the error was encountered.</param>
            <param name="line">The line where the error was encountered.</param>
            <param name="column">The column where the error was encountered.</param>
        </member>
        <member name="M:PDDLParser.Parser.ErrorManager.logParserWarning(System.String,System.String)">
            <summary>
            Logs a parser warning message.
            </summary>
            <param name="msg">The error message.</param>
            <param name="file">The file where the error was encountered.</param>
        </member>
        <member name="M:PDDLParser.Parser.ErrorManager.logParserWarning(System.String,System.String,System.Int32,System.Int32)">
            <summary>
            Logs a parser warning message.
            </summary>
            <param name="msg">The error message.</param>
            <param name="file">The file where the error was encountered.</param>
            <param name="line">The line where the error was encountered.</param>
            <param name="column">The column where the error was encountered.</param>
        </member>
        <member name="M:PDDLParser.Parser.ErrorManager.logLexicalError(System.String,System.String)">
            <summary>
            Logs a lexical error message.
            </summary>
            <param name="msg">The error message.</param>
            <param name="file">The file where the error was encountered.</param>
        </member>
        <member name="M:PDDLParser.Parser.ErrorManager.logLexicalError(System.String,System.String,System.Int32,System.Int32)">
            <summary>
            Logs a lexical error message.
            </summary>
            <param name="msg">The error message.</param>
            <param name="file">The file where the error was encountered.</param>
            <param name="line">The line where the error was encountered.</param>
            <param name="column">The column where the error was encountered.</param>
        </member>
        <member name="M:PDDLParser.Parser.ErrorManager.logLinkerError(System.String,System.String)">
            <summary>
            Logs a linker error message.
            </summary>
            <param name="msg">The error message.</param>
            <param name="file">The file where the error was encountered.</param>
        </member>
        <member name="M:PDDLParser.Parser.ErrorManager.logLinkerWarning(System.String,System.String)">
            <summary>
            Logs a linker warning message
            </summary>
            <param name="msg">The error message.</param>
            <param name="file">The file where the error was encountered.</param>
        </member>
        <member name="T:PDDLParser.Parser.ErrorManager.Message">
            <summary>
            This enumeration defines the type of message logged in the error manager.
            </summary>
        </member>
        <member name="F:PDDLParser.Parser.ErrorManager.Message.NONE">
            <summary>
            No type.
            </summary>
        </member>
        <member name="F:PDDLParser.Parser.ErrorManager.Message.PARSER_ERROR">
            <summary>
            A parser error.
            </summary>
        </member>
        <member name="F:PDDLParser.Parser.ErrorManager.Message.PARSER_WARNING">
            <summary>
            A parser warning.
            </summary>
        </member>
        <member name="F:PDDLParser.Parser.ErrorManager.Message.LEXICAL_ERROR">
            <summary>
            A lexical error.
            </summary>
        </member>
        <member name="F:PDDLParser.Parser.ErrorManager.Message.LINKER_ERROR">
            <summary>
            A linker error.
            </summary>
        </member>
        <member name="F:PDDLParser.Parser.ErrorManager.Message.LINKER_WARNING">
            <summary>
            A linker warning.
            </summary>
        </member>
        <member name="F:PDDLParser.Parser.ErrorManager.Message.ALL">
            <summary>
            All errors and warnings.
            </summary>
        </member>
        <member name="F:PDDLParser.Parser.ErrorManager.Message.PARSER">
            <summary>
            A parser error or a parser warning.
            </summary>
        </member>
        <member name="F:PDDLParser.Parser.ErrorManager.Message.LINKER">
            <summary>
            A linker error or a linker warning.
            </summary>
        </member>
        <member name="F:PDDLParser.Parser.ErrorManager.Message.ERROR">
            <summary>
            All errors.
            </summary>
        </member>
        <member name="F:PDDLParser.Parser.ErrorManager.Message.WARNING">
            <summary>
            All warnings.
            </summary>
        </member>
        <member name="T:PDDLParser.Parser.ErrorManager.Triplet`3">
            <summary>
            A triplet stores three different values.
            </summary>
            <typeparam name="TFirst">The type of the first value.</typeparam>
            <typeparam name="TSecond">The type of the second value.</typeparam>
            <typeparam name="TThird">The type of the third value.</typeparam>
        </member>
        <member name="M:PDDLParser.Parser.ErrorManager.Triplet`3.#ctor(`0,`1,`2)">
            <summary>
            Creates a new triplet with the specified values.
            </summary>
            <param name="first">The first value.</param>
            <param name="second">The second value.</param>
            <param name="third">The third value.</param>
        </member>
        <member name="M:PDDLParser.Parser.ErrorManager.Triplet`3.ToString">
            <summary>
            Returns a string representation of this triplet.
            </summary>
            <returns>A string representation of this triplet.</returns>
        </member>
        <member name="P:PDDLParser.Parser.ErrorManager.Triplet`3.First">
            <summary>
            The first value.
            </summary>
        </member>
        <member name="P:PDDLParser.Parser.ErrorManager.Triplet`3.Second">
            <summary>
            The second value.
            </summary>
        </member>
        <member name="P:PDDLParser.Parser.ErrorManager.Triplet`3.Third">
            <summary>
            The third value.
            </summary>
        </member>
        <member name="T:PDDLParser.Exp.Term.Type.Type">
            <summary>
            Represents a single, primitive PDDL type. Note that only one instance of 
            <see cref="T:PDDLParser.Exp.Term.Type.Type"/> is to exists for each PDDL 
            primitive type.
            </summary>
        </member>
        <member name="F:PDDLParser.Exp.Term.Type.Type.m_name">
            <summary>
            The name of this type.
            </summary>
        </member>
        <member name="F:PDDLParser.Exp.Term.Type.Type.m_domain">
            <summary>
            The domain of this type.
            </summary>
        </member>
        <member name="F:PDDLParser.Exp.Term.Type.Type.m_subTypes">
            <summary>
            Direct subtypes of this type.
            </summary>
        </member>
        <member name="F:PDDLParser.Exp.Term.Type.Type.m_allSubTypes">
            <summary>
            All direct and indirect subtypes of this type.
            </summary>
        </member>
        <member name="F:PDDLParser.Exp.Term.Type.Type.m_superTypes">
            <summary>
            Direct supertypes of this type.
            </summary>
        </member>
        <member name="F:PDDLParser.Exp.Term.Type.Type.m_allSuperTypes">
            <summary>
            All direct and indirect supertypes of this type.
            </summary>
        </member>
        <member name="F:PDDLParser.Exp.Term.Type.Type.OBJECT_SYMBOL">
            <summary>
            The object type symbol.
            </summary>
        </member>
        <member name="F:PDDLParser.Exp.Term.Type.Type.NUMBER_SYMBOL">
            <summary>
            The number type symbol.
            </summary>
        </member>
        <member name="F:PDDLParser.Exp.Term.Type.Type.Number">
            <summary>
            The number primitive type.
            </summary>
        </member>
        <member name="M:PDDLParser.Exp.Term.Type.Type.CreateTypes(System.Collections.Generic.IDictionary{System.String,System.Collections.Generic.HashSet{System.String}})">
            <summary>
            Creates a hierarchy of types based on a dictionary that maps types to their direct subtypes.
            </summary>
            <param name="hierarchy">The dictionary that maps types to their direct subtypes.</param>
            <returns>A hierarchy of instantiated types.</returns>
            <exception cref="T:PDDLParser.Exception.TypingException">Thrown when a cycle is detected in the type hierarchy, or when another error occurs.</exception>
        </member>
        <member name="M:PDDLParser.Exp.Term.Type.Type.#ctor(System.String)">
            <summary>
            Creates a new primitive type with a given name.
            </summary>
            <param name="name">The name of the primitive type.</param>
        </member>
        <member name="M:PDDLParser.Exp.Term.Type.Type.AddSubType(PDDLParser.Exp.Term.Type.Type)">
            <summary>
            Adds a given direct subtype to this type.
            </summary>
            <param name="type">The direct subtype.</param>
        </member>
        <member name="M:PDDLParser.Exp.Term.Type.Type.AddIndirectSubType(PDDLParser.Exp.Term.Type.Type)">
            <summary>
            Adds a given indirect subtype to this type.
            </summary>
            <param name="type">The indirect subtype.</param>
        </member>
        <member name="M:PDDLParser.Exp.Term.Type.Type.AddSuperType(PDDLParser.Exp.Term.Type.Type)">
            <summary>
            Adds a given direct supertype to this type.
            </summary>
            <param name="type">The direct supertype.</param>
        </member>
        <member name="M:PDDLParser.Exp.Term.Type.Type.AddIndirectSuperType(PDDLParser.Exp.Term.Type.Type)">
            <summary>
            Adds a given indirect supertype to this type.
            </summary>
            <param name="type">The indirect supertype.</param>
        </member>
        <member name="M:PDDLParser.Exp.Term.Type.Type.VerifyCycles(System.Collections.Generic.HashSet{PDDLParser.Exp.Term.Type.Type})">
            <summary>
            Verifies whether a cycle exists in the type hierarchy.
            </summary>
            <param name="encounteredTypes">The type hierarchy.</param>
            <exception cref="T:PDDLParser.Exception.TypingException">Thrown if there is a cycle in the type hierarchy.</exception>
        </member>
        <member name="M:PDDLParser.Exp.Term.Type.Type.CacheSubTypesAndSuperTypes(System.Collections.Generic.HashSet{PDDLParser.Exp.Term.Type.Type},System.Collections.Generic.HashSet{PDDLParser.Exp.Term.Type.Type})">
            <summary>
            Caches all the supertype and subtypes. This is called recursively.
            </summary>
            <param name="subTypes">The subtypes encountered by the callee.</param>
            <param name="superTypes">The supertypes encountered by the caller.</param>
        </member>
        <member name="M:PDDLParser.Exp.Term.Type.Type.FireTypeDomainChanged">
            <summary>
            Fires the <see cref="E:PDDLParser.Exp.Term.Type.Type.TypeDomainChanged"/> event, setting this type as its parameter.
            </summary>
        </member>
        <member name="M:PDDLParser.Exp.Term.Type.Type.Equals(System.Object)">
            <summary>
            Returns true if this primitive type is equal to a specified object.
            Two primitive types are equal if they have the same name.
            </summary>
            <param name="obj">Object to test for equality.</param>
            <returns>True if this primitive type is equal to the specified objet.</returns>
        </member>
        <member name="M:PDDLParser.Exp.Term.Type.Type.GetHashCode">
            <summary>
            Returns the hash code of this primitive type.
            </summary>
            <returns>The hash code of this primitive type.</returns>
        </member>
        <member name="M:PDDLParser.Exp.Term.Type.Type.ToString">
            <summary>
            Returns a string representation of primitive type.
            </summary>
            <returns>A string representation of primitive type.</returns>
        </member>
        <member name="P:PDDLParser.Exp.Term.Type.Type.Name">
            <summary>
            Gets the name of this type.
            </summary>
        </member>
        <member name="P:PDDLParser.Exp.Term.Type.Type.TypeDomain">
            <summary>
            Gets or sets this type's domain.
            </summary>
            <remarks>
            The type's domain contains its own domain as well as all of its subtypes' domains.
            Also note that when setting the type's domain, an event is triggered to warn other objects
            that they will have to clear their domain cache.
            </remarks>
            <seealso cref="T:PDDLParser.Exp.Term.Type.TypeSet"/>
        </member>
        <member name="P:PDDLParser.Exp.Term.Type.Type.SubTypes">
            <summary>
            Gets the direct subtypes of this type.
            </summary>
        </member>
        <member name="P:PDDLParser.Exp.Term.Type.Type.AllSubTypes">
            <summary>
            Gets all direct and indirect supertypes of this type.
            </summary>
        </member>
        <member name="P:PDDLParser.Exp.Term.Type.Type.SuperTypes">
            <summary>
            Gets the direct supertypes of this type.
            </summary>
        </member>
        <member name="P:PDDLParser.Exp.Term.Type.Type.AllSuperTypes">
            <summary>
            Gets all direct and indirect supertypes of this type.
            </summary>
        </member>
        <member name="E:PDDLParser.Exp.Term.Type.Type.TypeDomainChanged">
            <summary>
            This event is triggered whenever the type's domain changes. This is used to clear cached domains.
            </summary>
            <seealso cref="T:PDDLParser.Exp.Term.Type.TypeSet"/>
        </member>
        <member name="T:PDDLParser.Exp.Term.Type.Type.TypeEventHandler">
            <summary>
            A delegate used with the <see cref="E:PDDLParser.Exp.Term.Type.Type.TypeDomainChanged"/> event.
            </summary>
            <param name="sender">The type whose domain has changed.</param>
        </member>
        <member name="T:PDDLParser.Exp.Struct.ShortCircuitBool">
            <summary>
            A ShortCircuitBool represents a boolean value possibly undefined, which makes it similar
            to the regular Bool struct.
            The only difference is that the value ShortCircuitBool.Undefined, just like the value False,
            also shortcircuits conjunctions:
            ShortCircuitBool.Undefined &amp;&amp; ... = ShortCircuitBool.Undefined;
            ShortCircuitBool.False     &amp;&amp; ... = ShortCircuitBool.False.
            Hence conjunction is not commutative:
            ShortCircuitBool.Undefined &amp;&amp; ShortCircuitBool.False     = ShortCircuitBool.Undefined;
            ShortCircuitBool.False     &amp;&amp; ShortCircuitBool.Undefined = ShortCircuitBool.False.
            It is used to evaluate the body of defined formulas.
            </summary>
        </member>
        <member name="F:PDDLParser.Exp.Struct.ShortCircuitBool.False">
            <summary>
            ShortCircuitBool false value.
            </summary>
        </member>
        <member name="F:PDDLParser.Exp.Struct.ShortCircuitBool.Undefined">
            <summary>
            ShortCircuitBool undefined value.
            </summary>
        </member>
        <member name="F:PDDLParser.Exp.Struct.ShortCircuitBool.True">
            <summary>
             ShortCircuitBool true value.
            </summary>
        </member>
        <member name="F:PDDLParser.Exp.Struct.ShortCircuitBool.m_value">
            <summary>
            BoolValue associated with this ShortCircuitBool.
            </summary>
        </member>
        <member name="M:PDDLParser.Exp.Struct.ShortCircuitBool.#ctor(System.Boolean)">
            <summary>
            Creates a new ShortCircuitBool from a specified boolean value.
            </summary>
            <param name="value">A boolean value.</param>
        </member>
        <member name="M:PDDLParser.Exp.Struct.ShortCircuitBool.#ctor(PDDLParser.Exp.Struct.BoolValue)">
            <summary>
            Creates a new ShortCircuitBool from a specified BoolValue.
            This constructor should stay private.
            </summary>
            <param name="value">A BoolValue.</param>
        </member>
        <member name="M:PDDLParser.Exp.Struct.ShortCircuitBool.ToBool">
            <summary>
            Returns the corresponding boolean value of this ShortCircuitBool.
            ShortCircuitBool.True yields true,
            ShortCircuitBool.False and ShortCircuitBool.Undefined both yield false.
            </summary>
            <returns>The boolean value of this ShortCircuitBool.</returns>
        </member>
        <member name="M:PDDLParser.Exp.Struct.ShortCircuitBool.op_Equality(PDDLParser.Exp.Struct.ShortCircuitBool,PDDLParser.Exp.Struct.ShortCircuitBool)">
            <summary>
            Checks whether the two ShortCircuitBool values are equivalent.
            </summary>
            <param name="x">The first ShortCircuitBool value.</param>
            <param name="y">The second ShortCircuitBool value.</param>
            <returns>True if the two ShortCircuitBool values are equivalent.</returns>
        </member>
        <member name="M:PDDLParser.Exp.Struct.ShortCircuitBool.op_Inequality(PDDLParser.Exp.Struct.ShortCircuitBool,PDDLParser.Exp.Struct.ShortCircuitBool)">
            <summary>
            Checks whether the two ShortCircuitBool values are different.
            </summary>
            <param name="x">The first ShortCircuitBool value.</param>
            <param name="y">The second ShortCircuitBool value.</param>
            <returns>True if the two ShortCircuitBool values are different.</returns>
        </member>
        <member name="M:PDDLParser.Exp.Struct.ShortCircuitBool.op_OnesComplement(PDDLParser.Exp.Struct.ShortCircuitBool)">
            <summary>
            Returns the negation of this ShortCircuitBool value.
            ¬False = True
            ¬Undefined = Undefined
            ¬True = True
            </summary>
            <param name="x">The ShortCircuitBool value to negate.</param>
            <returns>The negation of this ShortCircuitBool value.</returns>
        </member>
        <member name="M:PDDLParser.Exp.Struct.ShortCircuitBool.op_LogicalNot(PDDLParser.Exp.Struct.ShortCircuitBool)">
            <summary>
            False shortcircuit operator.
            A ShortCircuitBool value is false if its inner value is ShortCircuitBool.False
            or ShortCircuitBool.Undefined
            </summary>
            <param name="x">The ShortCircuitBool value to test.</param>
            <returns>True if the ShortCircuitBool value is ShortCircuitBool.False or
            ShortCircuitBool.Undefined</returns>
        </member>
        <member name="M:PDDLParser.Exp.Struct.ShortCircuitBool.op_False(PDDLParser.Exp.Struct.ShortCircuitBool)">
            <summary>
            False shortcircuit operator.
            A ShortCircuitBool value is false if its inner value is ShortCircuitBool.False
            or ShortCircuitBool.Undefined
            </summary>
            <param name="x">The ShortCircuitBool value to test.</param>
            <returns>True if the ShortCircuitBool value is ShortCircuitBool.False or
            ShortCircuitBool.Undefined</returns>
        </member>
        <member name="M:PDDLParser.Exp.Struct.ShortCircuitBool.op_True(PDDLParser.Exp.Struct.ShortCircuitBool)">
            <summary>
            True shortcircuit operator.
            A ShortCircuitBool value is true if its inner value is ShortCircuitBool.True
            </summary>
            <param name="x">The ShortCircuitBool value to test.</param>
            <returns>True if the ShortCircuitBool value is ShortCircuitBool.True</returns>
        </member>
        <member name="M:PDDLParser.Exp.Struct.ShortCircuitBool.op_BitwiseOr(PDDLParser.Exp.Struct.ShortCircuitBool,PDDLParser.Exp.Struct.ShortCircuitBool)">
            <summary>
            Returns the disjunction of two ShortCircuitBool values.
            The resulting ShortCircuitBool value corresponds to the maximum BoolValue 
            of the two operands.
            </summary>
            <param name="x">The first ShortCircuitBool value.</param>
            <param name="y">The second ShortCircuitBool value.</param>
            <returns>The disjunction of the two ShortCircuitBool values.</returns>
        </member>
        <member name="M:PDDLParser.Exp.Struct.ShortCircuitBool.op_BitwiseAnd(PDDLParser.Exp.Struct.ShortCircuitBool,PDDLParser.Exp.Struct.ShortCircuitBool)">
            <summary>
            Returns the conjunction of two ShortCircuitBool values.
            The resulting ShortCircuitBool value corresponds to the minimum BoolValue
            of the two operands.
            </summary>
            <param name="x">The first ShortCircuitBool value.</param>
            <param name="y">The second ShortCircuitBool value.</param>
            <returns>The conjunction of the two ShortCircuitBool values.</returns>
        </member>
        <member name="M:PDDLParser.Exp.Struct.ShortCircuitBool.op_ExclusiveOr(PDDLParser.Exp.Struct.ShortCircuitBool,PDDLParser.Exp.Struct.ShortCircuitBool)">
            <summary>
            Returns the exclusive disjunction of two ShortCircuitBool values.
            </summary>
            <param name="x">The first ShortCircuitBool value.</param>
            <param name="y">The second ShortCircuitBool value.</param>
            <returns>The exclusive disjunction of the two ShortCircuitBool values.</returns>
        </member>
        <member name="M:PDDLParser.Exp.Struct.ShortCircuitBool.op_Implicit(PDDLParser.Exp.Struct.ShortCircuitBool)~PDDLParser.Exp.Struct.BoolValue">
            <summary>
            Returns the BoolValue associated with a ShortCircuitBool value.
            </summary>
            <param name="x">The ShortCircuitBool value.</param>
            <returns>The BoolValue associated with the ShortCircuitBool value.</returns>
        </member>
        <member name="M:PDDLParser.Exp.Struct.ShortCircuitBool.Equals(System.Object)">
            <summary>
            Returns true if this ShortCircuitBool value is equal to another object.
            </summary>
            <param name="obj">The other object to test for equality.</param>
            <returns>True if this ShortCircuitBool value is equal to the other object.</returns>
        </member>
        <member name="M:PDDLParser.Exp.Struct.ShortCircuitBool.GetHashCode">
            <summary>
            Returns the hashcode of this ShortCircuitBool value.
            </summary>
            <returns>The hashcode of this ShortCircuitBool value.</returns>
        </member>
        <member name="M:PDDLParser.Exp.Struct.ShortCircuitBool.ToString">
            <summary>
            Returns a string representation of the ShortCircuitBool value.
            </summary>
            <returns>A string representation of the ShortCircuitBool value.</returns>
        </member>
        <member name="P:PDDLParser.Exp.Struct.ShortCircuitBool.Value">
            <summary>
            Gets the BoolValue associated with this ShortCircuitBool. 
            </summary>
        </member>
        <member name="T:PDDLParser.Exp.Struct.ProgressionValue">
            <summary>
            A ProgressionValue represents a constraint expression, a boolean value, or an undefined value.
            </summary>
        </member>
        <member name="F:PDDLParser.Exp.Struct.ProgressionValue.True">
            <summary>
            ProgressionValue true value.
            </summary>
        </member>
        <member name="F:PDDLParser.Exp.Struct.ProgressionValue.False">
            <summary>
            ProgressionValue false value.
            </summary>
        </member>
        <member name="F:PDDLParser.Exp.Struct.ProgressionValue.Undefined">
            <summary>
            ProgressionValue undefined value.
            </summary>
        </member>
        <member name="F:PDDLParser.Exp.Struct.ProgressionValue.NoTimestamp">
            <summary>
            A timestamp value meaning no event of interest has been created by the progression.
            </summary>
        </member>
        <member name="F:PDDLParser.Exp.Struct.ProgressionValue.m_value">
            <summary>
            The Bool value associated with this ProgressionValue.
            Note that this value is not defined if a corresponding constraint expression is defined.
            </summary>
        </member>
        <member name="F:PDDLParser.Exp.Struct.ProgressionValue.m_exp">
            <summary>
            The constraint expression associated with this ProgressionValue.
            </summary>
        </member>
        <member name="F:PDDLParser.Exp.Struct.ProgressionValue.m_nextAbsoluteTimestamp">
            <summary>
            The next "interesting" timestamp, i.e. the timestamp at which the next change occurs.
            </summary>
        </member>
        <member name="M:PDDLParser.Exp.Struct.ProgressionValue.#cctor">
            <summary>
            This static constructor initializes static fields.
            </summary>
        </member>
        <member name="M:PDDLParser.Exp.Struct.ProgressionValue.#ctor(System.Boolean)">
            <summary>
            Creates a new ProgressionValue from a specified bool value.
            </summary>
            <param name="value">A bool value.</param>
        </member>
        <member name="M:PDDLParser.Exp.Struct.ProgressionValue.#ctor(PDDLParser.Exp.Struct.Bool)">
            <summary>
            Creates a new ProgressionValue from a specified Bool value.
            </summary>
            <param name="value">A Bool value.</param>
        </member>
        <member name="M:PDDLParser.Exp.Struct.ProgressionValue.#ctor(PDDLParser.Exp.IConstraintExp,PDDLParser.Exp.Struct.TimeValue)">
            <summary>
            Creates a new ProgressionValue from a specified constraint expression.
            </summary>
            <param name="exp">A constraint expression.</param>
            <param name="nextAbsoluteTimestamp">The next smallest absolute timestamp at which a change occurs.</param>
        </member>
        <member name="M:PDDLParser.Exp.Struct.ProgressionValue.#ctor(PDDLParser.Exp.Struct.Bool,PDDLParser.Exp.IConstraintExp,PDDLParser.Exp.Struct.TimeValue)">
            <summary>
            Creates a new ProgressionValue from a specified result and constraint expression.
            Note that this constructor should stay private.
            </summary>
            <param name="value">A Bool value.</param>
            <param name="exp">A constraint expression.</param>
            <param name="nextAbsoluteTimestamp">The next smallest absolute timestamp at which a change occurs.</param>
        </member>
        <member name="M:PDDLParser.Exp.Struct.ProgressionValue.GetEquivalentExp">
            <summary>
            Returns a constraint expression equivalent to this ProgressionValue.
            If this ProgressionValue corresponds to a Bool value, an equivalent constant expression
            is returned (false -> FalseExp, Undefined -> UndefinedExp, True -> TrueExp).
            </summary>
            <returns>A constraint expression equivalent to this ProgressionValue.</returns>
        </member>
        <member name="M:PDDLParser.Exp.Struct.ProgressionValue.IsFalse">
            <summary>
            Returns whether this progression value evaluates to false, i.e. if its value
            is Bool.False or Bool.Undefined
            </summary>
            <returns>Whether this progression value evaluates to false.</returns>
        </member>
        <member name="M:PDDLParser.Exp.Struct.ProgressionValue.IsTrue">
            <summary>
            Returns whether this progression value evaluates to true, i.e. if its value
            is Bool.True
            </summary>
            <returns>Whether this progression value evaluates to true.</returns>
        </member>
        <member name="M:PDDLParser.Exp.Struct.ProgressionValue.op_Equality(PDDLParser.Exp.Struct.ProgressionValue,PDDLParser.Exp.Struct.ProgressionValue)">
            <summary>
            Checks whether the two ProgressionValue values are equivalent, i.e. they both contain
            the same constraint expression and timestamp or their Bool values are equal.
            </summary>
            <param name="x">The first ProgressionValue value.</param>
            <param name="y">The second ProgressionValue value.</param>
            <returns>True if the two ProgressionValue values are equivalent.</returns>
        </member>
        <member name="M:PDDLParser.Exp.Struct.ProgressionValue.op_Inequality(PDDLParser.Exp.Struct.ProgressionValue,PDDLParser.Exp.Struct.ProgressionValue)">
            <summary>
            Checks whether the two ProgressionValue values are different, i.e. they do not contain
            the same constraint expression and timestamp or their Bool values are different.
            </summary>
            <param name="x">The first ProgressionValue value.</param>
            <param name="y">The second ProgressionValue value.</param>
            <returns>True if the two ProgressionValue values are different.</returns>
        </member>
        <member name="M:PDDLParser.Exp.Struct.ProgressionValue.op_OnesComplement(PDDLParser.Exp.Struct.ProgressionValue)">
            <summary>
            Returns the negation of this ProgressionValue.
            ¬False = True
            ¬Undefined = Undefined
            ¬True = False
            ¬Expression = (not (Expression))
            </summary>
            <param name="x">The ProgressionValue to negate.</param>
            <returns>The negation of this ProgressionValue.</returns>
        </member>
        <member name="M:PDDLParser.Exp.Struct.ProgressionValue.op_LogicalNot(PDDLParser.Exp.Struct.ProgressionValue)">
            <summary>
            False shortcircuit operator.
            A ProgressionValue is false if its inner value is Bool.False
            </summary>
            <param name="x">The ProgressionValue to test.</param>
            <returns>True if the ProgressionValue value is Bool.False</returns>
        </member>
        <member name="M:PDDLParser.Exp.Struct.ProgressionValue.op_False(PDDLParser.Exp.Struct.ProgressionValue)">
            <summary>
            False shortcircuit operator.
            A ProgressionValue is false if its inner value is Bool.False
            </summary>
            <param name="x">The ProgressionValue to test.</param>
            <returns>True if the ProgressionValue value is Bool.False</returns>
        </member>
        <member name="M:PDDLParser.Exp.Struct.ProgressionValue.op_True(PDDLParser.Exp.Struct.ProgressionValue)">
            <summary>
            True shortcircuit operator.
            A ProgressionValue is true if its inner value is Bool.True
            </summary>
            <param name="x">The ProgressionValue to test.</param>
            <returns>True if the ProgressionValue value is Bool.True</returns>
        </member>
        <member name="M:PDDLParser.Exp.Struct.ProgressionValue.op_BitwiseOr(PDDLParser.Exp.Struct.ProgressionValue,PDDLParser.Exp.Struct.ProgressionValue)">
            <summary>
            Returns the disjunction of two ProgressionValues.
            Exp1 | Exp2 = (or Exp1 Exp2)
            Exp | False = Exp
            Exp | Undefined = (or Exp Undefined)
            Exp | True = True
            else the disjunction is computed using the two inner Bool values.
            </summary>
            <param name="x">The first ProgressionValue.</param>
            <param name="y">The second ProgressionValue</param>
            <returns>The disjunction of the two ProgressionValue.</returns>
        </member>
        <member name="M:PDDLParser.Exp.Struct.ProgressionValue.op_BitwiseAnd(PDDLParser.Exp.Struct.ProgressionValue,PDDLParser.Exp.Struct.ProgressionValue)">
            <summary>
            Returns the conjunction of two ProgressionValues.
            Exp1 &amp; Exp2 = (and Exp1 Exp2)
            Exp &amp; False = False
            Exp &amp; Undefined = (and Exp Undefined)
            Exp &amp; True = Exp
            else the conjunction is computed using the two inner Bool values.
            </summary>
            <param name="x">The first ProgressionValue.</param>
            <param name="y">The second ProgressionValue</param>
            <returns>The conjunction of the two ProgressionValue.</returns>
        </member>
        <member name="M:PDDLParser.Exp.Struct.ProgressionValue.Equals(System.Object)">
            <summary>
            Returns true if this ProgressionValue is equal to another object.
            </summary>
            <param name="obj">The other object to test for equality.</param>
            <returns>True if this ProgressionValue is equal to the other object.</returns>
        </member>
        <member name="M:PDDLParser.Exp.Struct.ProgressionValue.GetHashCode">
            <summary>
            Returns the hashcode of this ProgressionValue.
            </summary>
            <returns>The hashcode of this ProgressionValue.</returns>
        </member>
        <member name="M:PDDLParser.Exp.Struct.ProgressionValue.ToString">
            <summary>
            Returns a string representation of this ProgressionValue.
            </summary>
            <returns>A string representation of this ProgressionValue.</returns>
        </member>
        <member name="P:PDDLParser.Exp.Struct.ProgressionValue.Exp">
            <summary>
            Returns the constraint expression stored in this ProgressionValue.
            Note that this constraint expression may be null.
            </summary>
        </member>
        <member name="P:PDDLParser.Exp.Struct.ProgressionValue.Value">
            <summary>
            Returns the Bool value stored in this ProgressionValue.
            This value should only be accessed if the expression is null.
            </summary>
        </member>
        <member name="P:PDDLParser.Exp.Struct.ProgressionValue.NextAbsoluteTimestamp">
            <summary>
            Returns the next (smallest) absolute timestamp at which a change will occur.
            </summary>
        </member>
        <member name="T:PDDLParser.Exp.Numeric.TLPlan.UnaryTruncate">
            <summary>
            This class implements a truncate function.
            This is not part of PDDL; it was rather added for TLPlan.
            </summary>
        </member>
        <member name="M:PDDLParser.Exp.Numeric.TLPlan.UnaryTruncate.#ctor(PDDLParser.Exp.INumericExp)">
            <summary>
            Creates a new truncate function with the specified argument.
            </summary>
            <param name="arg">The argument of the new truncate function.</param>
        </member>
        <member name="M:PDDLParser.Exp.Numeric.TLPlan.UnaryTruncate.Calculate(System.Double)">
            <summary>
            Truncates the argument to the nearest integer (toward 0).
            </summary>
            <param name="arg">The argument.</param>
            <returns>The nearest integer toward 0.</returns>
        </member>
        <member name="T:PDDLParser.Exp.Numeric.NAritySubstract">
            <summary>
            This class implements a n-ary substraction.
            If only one argument is present, then the result is its additive inverse.
            </summary>
        </member>
        <member name="M:PDDLParser.Exp.Numeric.NAritySubstract.#ctor(System.Collections.Generic.List{PDDLParser.Exp.INumericExp})">
            <summary>
            Creates a new substraction function with the specified arguments.
            </summary>
            <param name="args">The arguments of the new substraction function.</param>
        </member>
        <member name="M:PDDLParser.Exp.Numeric.NAritySubstract.Calculate(System.Double[])">
            <summary>
            Calculates the left-associative difference of all arguments.
            If only one argument is present, then the result is its additive inverse.
            </summary>
            <param name="args">The arguments to call the function with.</param>
            <returns>The left-associative difference of all arguments.</returns>
        </member>
        <member name="T:PDDLParser.Exp.Metric.ConditionPrefExp">
            <summary>
            Represents a conditional preference expression of the PDDL language, i.e. a preference
            that lies in an action's conditions or in a goal.
            </summary>
        </member>
        <member name="F:PDDLParser.Exp.Metric.ConditionPrefExp.m_isGoalPreference">
            <summary>
            Whether this is a goal preference.
            </summary>
        </member>
        <member name="M:PDDLParser.Exp.Metric.ConditionPrefExp.#ctor(System.String,PDDLParser.Exp.ILogicalExp,System.Boolean)">
            <summary>
            Creates a new condition preference expression.
            </summary>
            <param name="name">The name of this preference.</param>
            <param name="exp">The body of the preference.</param>
            <param name="unnamed">Whether this preference is unnamed.</param>
        </member>
        <member name="M:PDDLParser.Exp.Metric.ConditionPrefExp.#ctor(System.String,PDDLParser.Exp.ILogicalExp)">
            <summary>
            Creates a new named condition preference expression.
            </summary>
            <param name="name">The name of this preference.</param>
            <param name="exp">The body of the preference.</param>
        </member>
        <member name="M:PDDLParser.Exp.Metric.ConditionPrefExp.ConvertToEffect(PDDLParser.Exp.Formula.NumericFluentApplication)">
            <summary>
            Converts an action condition preference into the appropriate effect, which will increment the preference's
            counter every time the action is used.
            </summary>
            <param name="counter">The preference's counter</param>
            <returns>The effect to append to the action's effects.</returns>
        </member>
        <member name="M:PDDLParser.Exp.Metric.ConditionPrefExp.GetViolationCondition">
            <summary>
            Returns the violation condition of this preference. This is only to be used on goal preferences.
            The violation condition is true if the preference has been violated.
            </summary>
            <returns>The violation condition of the preference.</returns>
        </member>
        <member name="M:PDDLParser.Exp.Metric.ConditionPrefExp.GetAllSubstitutedConditionPreferences">
            <summary>
            Returns all substituted preferences in their simplest form.
            </summary>
            <returns>An enumeration containing only this preference.</returns>
            <seealso cref="M:PDDLParser.Exp.IConditionPrefExp.GetAllSubstitutedConditionPreferences"/>
        </member>
        <member name="M:PDDLParser.Exp.Metric.ConditionPrefExp.GetCondition">
            <summary>
            Returns the original condition of the preference.
            </summary>
            <returns>The original condition of the preference.</returns>
        </member>
        <member name="P:PDDLParser.Exp.Metric.ConditionPrefExp.IsGoalPreference">
            <summary>
            Gets or sets whether this is a goal preference. Goal preferences are only evaluated on a goal world.
            </summary>
        </member>
        <member name="T:PDDLParser.Exp.LocalBindings">
            <summary>
            This class extends the ParameterBindings class by adding local variables bindings.
            </summary>
        </member>
        <member name="F:PDDLParser.Exp.LocalBindings.m_previous">
            <summary>
            The previous set of parameter bindings in the hierarchy. This is used when, for
            example, a quantified expression is nested inside another quantified expression.
            </summary>
        </member>
        <member name="F:PDDLParser.Exp.LocalBindings.m_objectBindings">
            <summary>
            The set of local object variables bindings. Note that a local object variable can be
            bound to an undefined value.
            </summary>
        </member>
        <member name="F:PDDLParser.Exp.LocalBindings.m_numericBindings">
            <summary>
            The set of local numeric variables bindings. Note that a local numeric variable can be
            bound to an undefined value.
            </summary>
        </member>
        <member name="F:PDDLParser.Exp.LocalBindings.m_booleanBindings">
            <summary>
            The set of local boolean variables bindings. Note that a local boolean variable can be
            bound to an undefined value.
            </summary>
        </member>
        <member name="F:PDDLParser.Exp.LocalBindings.s_emptyBindings">
            <summary>
            The empty set of bindings
            </summary>
        </member>
        <member name="M:PDDLParser.Exp.LocalBindings.#ctor">
            <summary>
            Creates a new empty set of local/parameter bindings.
            </summary>
        </member>
        <member name="M:PDDLParser.Exp.LocalBindings.#ctor(PDDLParser.Exp.ParameterBindings)">
            <summary>
            Creates a new empty set of local/parameter bindings with a specified parent set.
            </summary>
            <param name="previous">The parent set of parameter bindings.</param>
        </member>
        <member name="M:PDDLParser.Exp.LocalBindings.TryGetBinding(PDDLParser.Exp.Term.ObjectParameterVariable,PDDLParser.Exp.Term.Constant@)">
            <summary>
            Retrieves the constant value associated with the specified parameter variable.
            This function returns true if the specified parameter variable is bound, else
            it returns false and the returned binding is not defined. Note that if the
            current binding can not be found in this set of bindings, it is searched for
            in the parent set.
            </summary>
            <param name="var">The parameter variable for which the binding must be retrieved.
            </param>
            <param name="binding">If found, returns the constant value associated with the
            parameter variable.</param>
            <returns>True if the specified parameter variable is bound.</returns>
        </member>
        <member name="M:PDDLParser.Exp.LocalBindings.GetBinding(PDDLParser.Exp.Formula.TLPlan.LocalVar.ObjectLocalVariable)">
            <summary>
            Returns the constant (or undefined) value associated with the specified 
            object local variable.
            </summary>
            <param name="var">The object local variable for which the binding must be 
            retrieved.</param>
            <returns>The constant (or undefined) value associated with the object 
            local variable.</returns>
            <exception cref="T:PDDLParser.Exception.BindingException">A BindingException is thrown if the
            specified object local variable is not bound.</exception>
        </member>
        <member name="M:PDDLParser.Exp.LocalBindings.TryGetBinding(PDDLParser.Exp.Formula.TLPlan.LocalVar.ObjectLocalVariable,PDDLParser.Exp.Struct.ConstantExp@)">
            <summary>
            Retrieves the constant (or undefined) value associated with the specified 
            object local variable.
            This function returns true if the specified object local variable is bound, 
            else it returns false and the returned binding is not defined.
            </summary>
            <param name="var">The object local variable for which the binding must be 
            retrieved.</param>
            <param name="binding">If found, returns the constant (or undefined) value 
            associated with the object local variable.</param>
            <returns>True if the specified object local variable is bound.</returns>
        </member>
        <member name="M:PDDLParser.Exp.LocalBindings.Bind(PDDLParser.Exp.Formula.TLPlan.LocalVar.ObjectLocalVariable,PDDLParser.Exp.Struct.ConstantExp)">
            <summary>
            Binds the specified object local variable to a constant (or undefined) value.
            </summary>
            <param name="var">The object local variable to bind.</param>
            <param name="value">The constant (or undefined) value to bind the local 
            variable to.</param>
        </member>
        <member name="M:PDDLParser.Exp.LocalBindings.GetBinding(PDDLParser.Exp.Formula.TLPlan.LocalVar.NumericLocalVariable)">
            <summary>
            Returns the numeric (or undefined) value associated with the specified 
            numeric local variable.
            </summary>
            <param name="var">The numeric local variable for which the binding must 
            be retrieved.</param>
            <returns>The numeric (or undefined) value associated with the numeric 
            local variable.</returns>
            <exception cref="T:PDDLParser.Exception.BindingException">A BindingException is thrown if the
            specified numeric local variable is not bound.</exception>
        </member>
        <member name="M:PDDLParser.Exp.LocalBindings.TryGetBinding(PDDLParser.Exp.Formula.TLPlan.LocalVar.NumericLocalVariable,PDDLParser.Exp.Struct.Double@)">
            <summary>
            Retrieves the numeric (or undefined) value associated with the specified 
            numeric local variable.
            This function returns true if the specified numeric local variable is bound, 
            else it returns false and the returned binding is not defined.
            </summary>
            <param name="var">The numeric local variable for which the binding must be 
            retrieved.</param>
            <param name="binding">If found, returns the numeric (or undefined) value 
            associated with the numeric local variable.</param>
            <returns>True if the specified numeric local variable is bound.</returns>
        </member>
        <member name="M:PDDLParser.Exp.LocalBindings.Bind(PDDLParser.Exp.Formula.TLPlan.LocalVar.NumericLocalVariable,PDDLParser.Exp.Struct.Double)">
            <summary>
            Binds the specified numeric local variable to a numeric (or undefined) value.
            </summary>
            <param name="var">The numeric local variable to bind.</param>
            <param name="value">The numeric (or undefined) value to bind the local 
            variable to.</param>
        </member>
        <member name="M:PDDLParser.Exp.LocalBindings.GetBinding(PDDLParser.Exp.Formula.TLPlan.LocalVar.BooleanLocalVariable)">
            <summary>
            Returns the boolean (or undefined) value associated with the specified 
            boolean local variable.
            </summary>
            <param name="var">The boolean local variable for which the binding must 
            be retrieved.</param>
            <returns>The boolean (or undefined) value associated with the boolean 
            local variable.</returns>
            <exception cref="T:PDDLParser.Exception.BindingException">A BindingException is thrown if the
            specified boolean local variable is not bound.</exception>
        </member>
        <member name="M:PDDLParser.Exp.LocalBindings.TryGetBinding(PDDLParser.Exp.Formula.TLPlan.LocalVar.BooleanLocalVariable,PDDLParser.Exp.Struct.Bool@)">
            <summary>
            Retrieves the boolean (or undefined) value associated with the specified 
            boolean local variable.
            This function returns true if the specified boolean local variable is bound, 
            else it returns false and the returned binding is not defined.
            </summary>
            <param name="var">The boolean local variable for which the binding must be 
            retrieved.</param>
            <param name="binding">If found, returns the boolean (or undefined) value 
            associated with the boolean local variable.</param>
            <returns>True if the specified boolean local variable is bound.</returns>
        </member>
        <member name="M:PDDLParser.Exp.LocalBindings.Bind(PDDLParser.Exp.Formula.TLPlan.LocalVar.BooleanLocalVariable,PDDLParser.Exp.Struct.Bool)">
            <summary>
            Binds the specified boolean local variable to a boolean (or undefined) value.
            </summary>
            <param name="var">The boolean local variable to bind.</param>
            <param name="value">The boolean (or undefined) value to bind the local 
            variable to.</param>
        </member>
        <member name="M:PDDLParser.Exp.LocalBindings.Clone">
            <summary>
            Returns a clone of this set of local/parameter bindings.
            </summary>
            <returns>A clone of this set of local/parameter bindings.</returns>
        </member>
        <member name="M:PDDLParser.Exp.LocalBindings.Equals(System.Object)">
            <summary>
            Returns whether this set of local/parameter bindings is equal to another object.
            </summary>
            <param name="obj">The other object to compare this set of bindings to.</param>
            <returns>True if this set of local/parameter bindings is equal to another object.</returns>
        </member>
        <member name="M:PDDLParser.Exp.LocalBindings.GetHashCode">
            <summary>
            Returns the hash code of this set of local/parameter bindings.
            </summary>
            <returns>The hash code of this set of local/parameter bindings.</returns>
        </member>
        <member name="M:PDDLParser.Exp.LocalBindings.ToString">
            <summary>
            Returns a string representation of this set of local/parameter bindings.
            </summary>
            <returns>A string representation of this set of local/parameter bindings.</returns>
        </member>
        <member name="M:PDDLParser.Exp.LocalBindings.ToTypedString">
            <summary>
            Returns a typed string representation of this set of local/parameter bindings.
            </summary>
            <returns>A typed string representation of this set of local/parameter bindings.</returns>
        </member>
        <member name="P:PDDLParser.Exp.LocalBindings.EmptyBindings">
            <summary>
            Gets the empty set of bindings.
            </summary>
        </member>
        <member name="T:PDDLParser.Exp.Formula.TLPlan.DefinedNumericFunctionApplication">
            <summary>
            A defined numeric function application is an application of a defined numeric function.
            </summary>
        </member>
        <member name="M:PDDLParser.Exp.Formula.TLPlan.DefinedNumericFunctionApplication.#ctor(PDDLParser.Exp.Formula.TLPlan.DefinedNumericFunction,System.Collections.Generic.List{PDDLParser.Exp.ITerm})">
            <summary>
            Creates a new defined numeric function application of a specified defined numeric function
            with a given list of arguments.
            </summary>
            <param name="numericFunction">The defined numeric function to instantiate.</param>
            <param name="arguments">The arguments of the new defined numeric function.</param>
        </member>
        <member name="M:PDDLParser.Exp.Formula.TLPlan.DefinedNumericFunctionApplication.Apply(System.Collections.Generic.List{PDDLParser.Exp.ITerm})">
            <summary>
            Returns a copy of this formula application with the specified arguments.
            </summary>
            <param name="arguments">The arguments of the new formula application.</param>
            <returns>A copy of this expression with the given arguments.</returns>
        </member>
        <member name="M:PDDLParser.Exp.Formula.TLPlan.DefinedNumericFunctionApplication.Evaluate(PDDLParser.World.IReadOnlyOpenWorld,PDDLParser.Exp.LocalBindings)">
            <summary>
            Evaluates this numeric expression in the specified open world.
            A defined numeric function application is evaluated by first evaluating its arguments
            and then evaluating the corresponding defined function's body with the appropriate bindings.
            </summary>
            <param name="world">The evaluation world.</param>
            <param name="bindings">A set of variable bindings.</param>
            <returns>Undefined, unknown, or the resulting numeric value.</returns>
        </member>
        <member name="M:PDDLParser.Exp.Formula.TLPlan.DefinedNumericFunctionApplication.Simplify(PDDLParser.World.IReadOnlyOpenWorld,PDDLParser.Exp.LocalBindings)">
            <summary>
            Simplifies this numeric expression by evaluating its known expression parts.
            A defined numeric function application is simplified by first simplifying its arguments 
            and then by attempting to evaluate the corresponding defined function's body (if all
            its arguments are ground).
            </summary>
            <param name="world">The evaluation world.</param>
            <param name="bindings">A set of variable bindings.</param>
            <returns>Undefined, a numeric value, or the simplified expression.</returns>
        </member>
        <member name="M:PDDLParser.Exp.Formula.TLPlan.DefinedNumericFunctionApplication.Evaluate(PDDLParser.World.IReadOnlyClosedWorld,PDDLParser.Exp.LocalBindings)">
            <summary>
            Evaluates this numeric expression in the specified closed world.
            A defined numeric function application is evaluated by first evaluating its arguments
            and then evaluating the corresponding defined function's body with the appropriate bindings.
            </summary>
            <param name="world">The evaluation world.</param>
            <param name="bindings">A set of variable bindings.</param>
            <returns>Undefined, or the resulting numeric value.</returns>
        </member>
        <member name="P:PDDLParser.Exp.Formula.TLPlan.DefinedNumericFunctionApplication.RootFunction">
            <summary>
            Returns the defined numeric function corresponding to this function application.
            </summary>
            <returns>The defined numeric function corresponding to this function application.</returns>
        </member>
        <member name="T:PDDLParser.Exp.Constraint.TLPlan.AbstractIfThenElseExp`1">
            <summary>
            Represents a conditional expression which is equivalent to 
            (and (implies e1 e2) (implies (not e1) e3)). This is not part 
            of PDDL; it was rather added for TLPlan.
            </summary>
            <typeparam name="T">The type of the expressions.</typeparam>
        </member>
        <member name="F:PDDLParser.Exp.Constraint.TLPlan.AbstractIfThenElseExp`1.m_ifExp">
            <summary>
            The condition of the if-then-else expression.
            </summary>
        </member>
        <member name="F:PDDLParser.Exp.Constraint.TLPlan.AbstractIfThenElseExp`1.m_thenExp">
            <summary>
            The consequence of the if-then-else expression (the "then" clause).
            </summary>
        </member>
        <member name="F:PDDLParser.Exp.Constraint.TLPlan.AbstractIfThenElseExp`1.m_elseExp">
            <summary>
            The alternate consequence of the if-then-else expression (the "else" clause).
            </summary>
        </member>
        <member name="M:PDDLParser.Exp.Constraint.TLPlan.AbstractIfThenElseExp`1.#ctor(`0,`0,`0)">
            <summary>
            Creates a new if-then-else expression with the specified condition, consequence and
            alternate consequence.
            </summary>
            <param name="ifExp">The condition.</param>
            <param name="thenExp">The consequence (the then clause).</param>
            <param name="elseExp">The alternate consequence (the else clause).</param>
        </member>
        <member name="M:PDDLParser.Exp.Constraint.TLPlan.AbstractIfThenElseExp`1.Apply(PDDLParser.Exp.ParameterBindings)">
            <summary>
            Substitutes all occurrences of the variables that occur in this
            expression by their corresponding bindings.
            </summary>
            <param name="bindings">A set of variable bindings.</param>
            <returns>A substituted copy of this expression.</returns>
        </member>
        <member name="M:PDDLParser.Exp.Constraint.TLPlan.AbstractIfThenElseExp`1.Standardize(System.Collections.Generic.IDictionary{System.String,System.String})">
            <summary>
            Standardizes all occurrences of the variables that occur in this
            expression. The IDictionary argument is used to store the variable already
            standardized. Remember that free variables are existentially quantified.
            </summary>
            <param name="images">The object that maps old variable images to the standardize
            image.</param>
            <returns>A standardized copy of this expression.</returns>
        </member>
        <member name="M:PDDLParser.Exp.Constraint.TLPlan.AbstractIfThenElseExp`1.IsGround">
            <summary>
            Returns true if the expression is ground, i.e. it does not contain any variables.
            </summary>
            <returns>Whether the expression is ground.</returns>
        </member>
        <member name="M:PDDLParser.Exp.Constraint.TLPlan.AbstractIfThenElseExp`1.Equals(System.Object)">
            <summary>
            Returns true if this expression is equal to a specified object.
            </summary>
            <param name="obj">Object to test for equality.</param>
            <returns>True if this expression is equal to the specified objet.</returns>
        </member>
        <member name="M:PDDLParser.Exp.Constraint.TLPlan.AbstractIfThenElseExp`1.GetHashCode">
            <summary>
            Returns the hash code of this expression.
            </summary>
            <returns>The hash code of this expression.</returns>
        </member>
        <member name="M:PDDLParser.Exp.Constraint.TLPlan.AbstractIfThenElseExp`1.GetFreeVariables">
            <summary>
            Returns the free variables in this expression.
            </summary>
            <returns>The free variables in this expression.</returns>
        </member>
        <member name="M:PDDLParser.Exp.Constraint.TLPlan.AbstractIfThenElseExp`1.ToString">
            <summary>
            Returns a string representation of this expression.
            </summary>
            <returns>A string representation of this expression.</returns>
        </member>
        <member name="M:PDDLParser.Exp.Constraint.TLPlan.AbstractIfThenElseExp`1.ToTypedString">
            <summary>
            Returns a typed string representation of this expression.
            </summary>
            <returns>A typed string representation of this expression.</returns>
        </member>
        <member name="M:PDDLParser.Exp.Constraint.TLPlan.AbstractIfThenElseExp`1.CompareTo(PDDLParser.Exp.IExp)">
            <summary>
            Compares this expression with another expression.
            </summary>
            <param name="other">The other expression to compare this expression to.</param>
            <returns>An integer representing the total order relation between the two expressions.</returns>
        </member>
        <member name="T:PDDLParser.Exp.Constraint.TLPlan.IfThenElseConstraintExp">
            <summary>
            Represents a conditional constraint expression which is equivalent
            to (and (implies e1 e2) (implies (not e1) e3)). This is not part 
            of PDDL; it was rather added for TLPlan.
            </summary>
        </member>
        <member name="M:PDDLParser.Exp.Constraint.TLPlan.IfThenElseConstraintExp.#ctor(PDDLParser.Exp.IConstraintExp,PDDLParser.Exp.IConstraintExp,PDDLParser.Exp.IConstraintExp)">
            <summary>
            Creates a new if-then-else expression with the specified condition, consequence and
            alternate consequence.
            </summary>
            <param name="ifExp">The condition.</param>
            <param name="thenExp">The consequence (the then clause).</param>
            <param name="elseExp">The alternate consequence (the else clause).</param>
        </member>
        <member name="M:PDDLParser.Exp.Constraint.TLPlan.IfThenElseConstraintExp.Progress(PDDLParser.World.IReadOnlyDurativeClosedWorld,PDDLParser.Exp.LocalBindings)">
            <summary>
            Evaluates the progression of this constraint expression in the next worlds.
            </summary>
            <param name="world">The current world.</param>
            <param name="bindings">A set of variable bindings.</param>
            <returns>True, false, undefined, or a progressed expression.</returns>
            <exception cref="T:PDDLParser.Exception.BindingException">A BindingException is thrown if an attempt
            is made to evaluate an unbound variable.</exception>
            <seealso cref="M:PDDLParser.Exp.IConstraintExp.Progress(PDDLParser.World.IReadOnlyDurativeClosedWorld,PDDLParser.Exp.LocalBindings)"/>
        </member>
        <member name="M:PDDLParser.Exp.Constraint.TLPlan.IfThenElseConstraintExp.EvaluateIdle(PDDLParser.World.IReadOnlyDurativeClosedWorld,PDDLParser.Exp.LocalBindings)">
            <summary>
            Evaluates this constraint expression in an idle world, i.e. a world which
            won't be modified by further updates.
            </summary>
            <param name="idleWorld">The (idle) evaluation world.</param>
            <param name="bindings">A set of variable bindings.</param>
            <returns>True, false, or undefined.</returns>
            <exception cref="T:PDDLParser.Exception.BindingException">A BindingException is thrown if an attempt
            is made to evaluate an unbound variable.</exception>
            <seealso cref="M:PDDLParser.Exp.IConstraintExp.EvaluateIdle(PDDLParser.World.IReadOnlyDurativeClosedWorld,PDDLParser.Exp.LocalBindings)"/>
        </member>
        <member name="T:PDDLParser.Exp.Constraint.AndConstraintExp">
            <summary>
            This class represents a conjunction of constraint expressions.
            </summary>
        </member>
        <member name="M:PDDLParser.Exp.Constraint.AndConstraintExp.#ctor(System.Collections.Generic.IEnumerable{PDDLParser.Exp.IConstraintExp})">
            <summary>
            Creates a new conjunction of constraint expressions.
            </summary>
            <param name="exps">The constraint expressions associated with the new conjunctive 
            expression.</param>
        </member>
        <member name="M:PDDLParser.Exp.Constraint.AndConstraintExp.#ctor(PDDLParser.Exp.IConstraintExp[])">
            <summary>
            Creates a new conjunction of constraint expressions.
            </summary>
            <param name="exps">The constraint expressions associated with the new conjunctive 
            expression.</param>
        </member>
        <member name="M:PDDLParser.Exp.Constraint.AndConstraintExp.Progress(PDDLParser.World.IReadOnlyDurativeClosedWorld,PDDLParser.Exp.LocalBindings)">
            <summary>
            Evaluates the progression of this constraint expression in the next worlds.
            The algorithm is: Progress(and formula1 ...) =&gt; (and Progress(formula1) ...)
            </summary>
            <param name="world">The current world.</param>
            <param name="bindings">A set of variable bindings.</param>
            <returns>True, false, undefined, or a progressed expression.</returns>
            <seealso cref="M:PDDLParser.Exp.IConstraintExp.Progress(PDDLParser.World.IReadOnlyDurativeClosedWorld,PDDLParser.Exp.LocalBindings)"/>
        </member>
        <member name="M:PDDLParser.Exp.Constraint.AndConstraintExp.EvaluateIdle(PDDLParser.World.IReadOnlyDurativeClosedWorld,PDDLParser.Exp.LocalBindings)">
            <summary>
            Evaluates this constraint expression in an idle world, i.e. a world which
            won't be modified by further updates.
            </summary>
            <param name="idleWorld">The (idle) evaluation world.</param>
            <param name="bindings">A set of variable bindings.</param>
            <returns>True, false, or undefined.</returns>
            <seealso cref="M:PDDLParser.Exp.IConstraintExp.EvaluateIdle(PDDLParser.World.IReadOnlyDurativeClosedWorld,PDDLParser.Exp.LocalBindings)"/>
        </member>
        <member name="T:PDDLParser.Exp.Constraint.AlwaysWithinExp">
            <summary>
            Represents the "always-within" constraint expression of the PDDL language.
            This constraint expression uses timestamps relative to the first time it is progressed.
            </summary>
            <seealso cref="T:PDDLParser.Exp.Constraint.AlwaysExp"/>
            <seealso cref="T:PDDLParser.Exp.Constraint.WithinExp"/>
        </member>
        <member name="F:PDDLParser.Exp.Constraint.AlwaysWithinExp.m_exp">
            <summary>
            The trigger expression, i.e. the expression which triggers the "within" part of the expression.
            </summary>
        </member>
        <member name="F:PDDLParser.Exp.Constraint.AlwaysWithinExp.m_impliedExp">
            <summary>
            The constraint which must be satisfied once the "within" part has been triggered.
            </summary>
            <seealso cref="F:PDDLParser.Exp.Constraint.AlwaysWithinExp.m_exp"/>
        </member>
        <member name="F:PDDLParser.Exp.Constraint.AlwaysWithinExp.m_relativeTimestamp">
            <summary>
            The time limit within which the constraint must be satisfied.
            </summary>
            <remarks>
            This value is relative to the time at which the "within" part was triggered. For example,
            if this value is 10, and the "within" part is triggered at absolute time 3, then the 
            constraint must be satisfied before absolute time 13.
            </remarks>
        </member>
        <member name="M:PDDLParser.Exp.Constraint.AlwaysWithinExp.#ctor(PDDLParser.Exp.IConstraintExp,PDDLParser.Exp.IConstraintExp,System.Double)">
            <summary>
            Creates a new "always-within" constraint expression.
            </summary>
            <param name="exp">The trigger expression, i.e. the expression which triggers the "within" part.</param>
            <param name="impliedExp">The constraint which must be satisfied in the "within" part.</param>
            <param name="relativeTimestamp">The relative time limit of the within part.</param>
        </member>
        <member name="M:PDDLParser.Exp.Constraint.AlwaysWithinExp.GenerateEquivalentExp">
            <summary>
            Generates and returns the compound constraint expression equivalent to this expression.
            In this case, (always-within ts exp1 exp2) = (always (imply (exp1 (within ts exp2)))).
            </summary>
            <returns>An equivalent constraint expression to this expression.</returns>
        </member>
        <member name="M:PDDLParser.Exp.Constraint.AlwaysWithinExp.Standardize(System.Collections.Generic.IDictionary{System.String,System.String})">
            <summary>
            Standardizes all occurrences of the variables that occur in this
            expression. The IDictionary argument is used to store the variable already
            standardized. Remember that free variables are existentially quantified.
            The base implementation is to simply clone the object.
            </summary>
            <param name="images">The object that maps old variable images to the standardize
            image.</param>
            <returns>A standardized copy of this expression.</returns>
        </member>
        <member name="M:PDDLParser.Exp.Constraint.AlwaysWithinExp.Apply(PDDLParser.Exp.ParameterBindings)">
            <summary>
            Substitutes all occurrences of the variables that occur in this
            expression by their corresponding bindings.
            The base implementation is to simply clone the object.
            </summary>
            <param name="bindings">The bindings.</param>
            <returns>A substituted copy of this expression.</returns>
        </member>
        <member name="M:PDDLParser.Exp.Constraint.AlwaysWithinExp.Equals(System.Object)">
            <summary>
            Returns true if this expression is equal to a specified object.
            </summary>
            <param name="obj">Object to test for equality.</param>
            <returns>True if this expression is equal to the specified objet.</returns>
        </member>
        <member name="M:PDDLParser.Exp.Constraint.AlwaysWithinExp.GetHashCode">
            <summary>
            Returns the hash code of this expression.
            </summary>
            <returns>The hash code of this expression.</returns>
        </member>
        <member name="M:PDDLParser.Exp.Constraint.AlwaysWithinExp.ToString">
            <summary>
            Returns a string representation of this expression.
            </summary>
            <returns>A string representation of this expression.</returns>
        </member>
        <member name="M:PDDLParser.Exp.Constraint.AlwaysWithinExp.ToTypedString">
            <summary>
            Returns a typed string of this expression.
            </summary>
            <returns>A typed string representation of this expression.</returns>
        </member>
        <member name="M:PDDLParser.Exp.Constraint.AlwaysWithinExp.CompareTo(PDDLParser.Exp.IExp)">
            <summary>
            Compares this abstract expression with another expression.
            </summary>
            <param name="other">The other expression to compare this abstract expression to.</param>
            <returns>An integer representing the total order relation between the two expressions.</returns>
        </member>
        <member name="T:PDDLParser.Exception.TypingException">
            <summary>
            A typing exception is thrown when an error involving types occurs, for example if a cycle
            is found in the cycle hierarchy.
            </summary>
        </member>
        <member name="F:PDDLParser.Exception.TypingException.m_type">
            <summary>
            The type that caused the exception.
            </summary>
        </member>
        <member name="M:PDDLParser.Exception.TypingException.#ctor(PDDLParser.Exp.Term.Type.Type)">
            <summary>
            Creates a new typing exception involving the specified type.
            </summary>
            <param name="type">The type which caused the exception.</param>
        </member>
        <member name="P:PDDLParser.Exception.TypingException.Message">
            <summary>
            The message of this exception.
            </summary>
        </member>
        <member name="M:PDDLParser.Parser.Lexer.Node.jjtOpen">
            This method is called after the node has been made the current
                      node.  It indicates that child nodes can now be added to it. 
        </member>
        <member name="M:PDDLParser.Parser.Lexer.Node.jjtClose">
            This method is called after all the child nodes have been
                      added. 
        </member>
        <member name="M:PDDLParser.Parser.Lexer.Node.jjtSetParent(PDDLParser.Parser.Lexer.Node)">
            This pair of methods are used to inform the node of its
                      parent. 
        </member>
        <member name="M:PDDLParser.Parser.Lexer.Node.jjtAddChild(PDDLParser.Parser.Lexer.Node,System.Int32)">
            This method tells the node to add its argument to the node's
                      list of children.  
        </member>
        <member name="M:PDDLParser.Parser.Lexer.Node.jjtGetChild(System.Int32)">
            This method returns a child node.  The children are numbered
                       from zero, left to right. 
        </member>
        <member name="M:PDDLParser.Parser.Lexer.Node.jjtGetNumChildren">
            Return the number of children the node has. 
        </member>
        <member name="M:PDDLParser.Parser.Lexer.SimpleNode.GetImage">
            @return Returns the image.
        </member>
        <member name="M:PDDLParser.Parser.Lexer.SimpleNode.setImage(System.String)">
            @param image The image to set.
        </member>
        <member name="T:PDDLParser.Exp.Numeric.TLPlan.BinaryLogarithm">
            <summary>
            This class implements the logarithm function.
            This is not part of PDDL; it was rather added for TLPlan.
            </summary>
        </member>
        <member name="M:PDDLParser.Exp.Numeric.TLPlan.BinaryLogarithm.#ctor(PDDLParser.Exp.INumericExp,PDDLParser.Exp.INumericExp)">
            <summary>
            Creates a new logarithm function with the specified number and base.
            </summary>
            <param name="n">A number.</param>
            <param name="lBase">The logarithm base.</param>
        </member>
        <member name="M:PDDLParser.Exp.Numeric.TLPlan.BinaryLogarithm.Calculate(System.Double,System.Double)">
            <summary>
            Calculates the logarithm of a given number in a given base.
            </summary>
            <param name="n">The number.</param>
            <param name="lBase">The logarithm base.</param>
            <returns>The logarithm of a given number in a given base.</returns>
            <exception cref="T:PDDLParser.Exception.NumericException">A NumericException is thrown if the base is less than 
            or equal to 1 or the number is less than or equal to 0.</exception>
        </member>
        <member name="T:PDDLParser.Exp.Logical.TLPlan.IfThenElseExp">
            <summary>
            An If-then-else expression is a conditional expression derived from implication expressions.
            (if-then-else e1 e2 e3) is actually a shortcut for (and (implies e1 e2) (implies (not e1) e3)),
            but only in the particular case where e1, e2 and e3 can only be true or false
            (not unknown nor undefined).
            If the condition e1 evaluates to unknown or undefined, the evaluation immediately exits and
            returns the aforementioned value.
            This is not part of PDDL; it was rather added for TLPlan.
            </summary>
        </member>
        <member name="M:PDDLParser.Exp.Logical.TLPlan.IfThenElseExp.#ctor(PDDLParser.Exp.ILogicalExp,PDDLParser.Exp.ILogicalExp,PDDLParser.Exp.ILogicalExp)">
            <summary>
            Creates a new IfThenElse expression with the specified condition, consequence and
            alternate consequence.
            </summary>
            <param name="ifExp">The condition.</param>
            <param name="thenExp">The consequence (the then clause).</param>
            <param name="elseExp">The alternate consequence (the else clause).</param>
        </member>
        <member name="M:PDDLParser.Exp.Logical.TLPlan.IfThenElseExp.Evaluate(PDDLParser.World.IReadOnlyOpenWorld,PDDLParser.Exp.LocalBindings)">
            <summary>
            Evaluates this logical expression in the specified open world.
            </summary>
            <param name="world">The evaluation world.</param>
            <param name="bindings">A set of variable bindings.</param>
            <returns>True, false, undefined, or unknown.</returns>
        </member>
        <member name="M:PDDLParser.Exp.Logical.TLPlan.IfThenElseExp.EvaluateWithImmediateShortCircuit(PDDLParser.World.IReadOnlyOpenWorld,PDDLParser.Exp.LocalBindings)">
            <summary>
            Evaluates this logical expression in the specified open world.
            In addition to False, Undefined and Unknown also shortcircuit conjunctions.
            In addition to True, Unknown also shortcircuits disjunctions.
            </summary>
            <param name="world">The evaluation world.</param>
            <param name="bindings">A set of variable bindings.</param>
            <returns>True, false, undefined, or unknown.</returns>
        </member>
        <member name="M:PDDLParser.Exp.Logical.TLPlan.IfThenElseExp.Simplify(PDDLParser.World.IReadOnlyOpenWorld,PDDLParser.Exp.LocalBindings)">
            <summary>
            Simplifies this logical expression by evaluating its known expression parts.
            </summary>
            <param name="world">The evaluation world.</param>
            <param name="bindings">A set of variable bindings.</param>
            <returns>True, false, undefined, or the simplified expression.</returns>
        </member>
        <member name="M:PDDLParser.Exp.Logical.TLPlan.IfThenElseExp.Evaluate(PDDLParser.World.IReadOnlyClosedWorld,PDDLParser.Exp.LocalBindings)">
            <summary>
            Evaluates this logical expression in the specified closed world.
            </summary>
            <param name="world">The evaluation world.</param>
            <param name="bindings">A set of variable bindings.</param>
            <returns>True, false, or undefined.</returns>
        </member>
        <member name="M:PDDLParser.Exp.Logical.TLPlan.IfThenElseExp.EvaluateWithImmediateShortCircuit(PDDLParser.World.IReadOnlyClosedWorld,PDDLParser.Exp.LocalBindings)">
            <summary>
            Evaluates this logical expression in the specified closed world.
            In addition to False, Undefined also shortcircuit conjunctions.
            </summary>
            <param name="world">The evaluation world.</param>
            <param name="bindings">A set of variable bindings.</param>
            <returns>True, false, or undefined.</returns>
        </member>
        <member name="M:PDDLParser.Exp.Logical.TLPlan.IfThenElseExp.EnumerateAllSatisfyingWorlds">
            <summary>
            Enumerates all the worlds within which this logical expression evaluates to true.
            This method is used to support the goal modality expressions.
            </summary>
            <returns>All the worlds satisfying this logical expression.</returns>
        </member>
        <member name="M:PDDLParser.Exp.Logical.TLPlan.IfThenElseExp.GenerateEquivalentExp">
            <summary>
            Creates a new ground expression equivalent to this if-then-else expression.
            </summary>
            <returns>A new ground expression equivalent to this if-then-else expression.</returns>
        </member>
        <member name="M:PDDLParser.Exp.Logical.TLPlan.IfThenElseExp.Progress(PDDLParser.World.IReadOnlyDurativeClosedWorld,PDDLParser.Exp.LocalBindings)">
            <summary>
            Evaluates the progression of this constraint expression in the next worlds.
            This function returns false if this constraint expression is not satisfied 
            in the given world;
            it returns true if the progression is always satisfied in the next worlds;
            else it returns the progressed expression.
            </summary>
            <param name="world">The current world.</param>
            <param name="bindings">A set of variable bindings.</param>
            <returns>True, false, undefined, or a progressed expression.</returns>
        </member>
        <member name="M:PDDLParser.Exp.Logical.TLPlan.IfThenElseExp.EvaluateIdle(PDDLParser.World.IReadOnlyDurativeClosedWorld,PDDLParser.Exp.LocalBindings)">
            <summary>
            Evaluates this constraint expression in an idle world, i.e. a world which
            won't be modified by further updates.
            </summary>
            <param name="idleWorld">The (idle) evaluation world.</param>
            <param name="bindings">A set of variable bindings.</param>
            <returns>True, false, or undefined.</returns>
        </member>
        <member name="T:PDDLParser.Exp.Formula.TLPlan.DefinedPredicateApplication">
            <summary>
            A defined predicate application is an application of a defined predicate.
            </summary>
        </member>
        <member name="M:PDDLParser.Exp.Formula.TLPlan.DefinedPredicateApplication.#ctor(PDDLParser.Exp.Formula.TLPlan.DefinedPredicate,System.Collections.Generic.List{PDDLParser.Exp.ITerm})">
            <summary>
            Creates a new defined predicate application of a specified defined predicate with
            a given list of arguments.
            </summary>
            <param name="root">The defined predicate to instantiate.</param>
            <param name="arguments">The arguments of this defined predicate application.</param>
        </member>
        <member name="M:PDDLParser.Exp.Formula.TLPlan.DefinedPredicateApplication.getDefinedPredicate">
            <summary>
            Returns the defined predicate associated with this defined predicate application.
            </summary>
            <returns>The defined predicate associated with this defined predicate application.
            </returns>
        </member>
        <member name="M:PDDLParser.Exp.Formula.TLPlan.DefinedPredicateApplication.Apply(System.Collections.Generic.List{PDDLParser.Exp.ITerm})">
            <summary>
            Returns a copy of this formula application with the specified arguments.
            </summary>
            <param name="arguments">The arguments of the new formula application.</param>
            <returns>A copy of this expression with the given arguments.</returns>
        </member>
        <member name="M:PDDLParser.Exp.Formula.TLPlan.DefinedPredicateApplication.Evaluate(PDDLParser.World.IReadOnlyOpenWorld,PDDLParser.Exp.LocalBindings)">
            <summary>
            Evaluates this logical expression in the specified open world.
            A defined predicate application is evaluated by first evaluating its arguments 
            and then evaluating the corresponding defined predicate's body with the appropriate
            bindings.
            </summary>
            <param name="world">The evaluation world.</param>
            <param name="bindings">A set of variable bindings.</param>
            <returns>True, false, undefined, or unknown.</returns>
        </member>
        <member name="M:PDDLParser.Exp.Formula.TLPlan.DefinedPredicateApplication.EvaluateWithImmediateShortCircuit(PDDLParser.World.IReadOnlyOpenWorld,PDDLParser.Exp.LocalBindings)">
            <summary>
            Evaluates this logical expression in the specified open world.
            In addition to False, Undefined and Unknown also shortcircuit conjunctions.
            In addition to True, Unknown also shortcircuits disjunctions.
            A defined predicate application is evaluated by first evaluating its arguments 
            and then evaluating the corresponding defined predicate's body with the appropriate
            bindings.
            </summary>
            <param name="world">The evaluation world.</param>
            <param name="bindings">A set of variable bindings.</param>
            <returns>True, false, undefined, or unknown.</returns>
        </member>
        <member name="M:PDDLParser.Exp.Formula.TLPlan.DefinedPredicateApplication.Simplify(PDDLParser.World.IReadOnlyOpenWorld,PDDLParser.Exp.LocalBindings)">
            <summary>
            Simplifies this logical expression by evaluating its known expression parts.
            A defined predicate application is simplified by first simplifying its arguments
            and then by attempting to evaluate the corresponding defined predicate's body (if all
            its arguments are ground).
            </summary>
            <param name="world">The evaluation world.</param>
            <param name="bindings">A set of variable bindings.</param>
            <returns>True, false, undefined, or the simplified expression.</returns>
        </member>
        <member name="M:PDDLParser.Exp.Formula.TLPlan.DefinedPredicateApplication.Evaluate(PDDLParser.World.IReadOnlyClosedWorld,PDDLParser.Exp.LocalBindings)">
            <summary>
            Evaluates this logical expression in the specified closed world.
            A defined predicate application is evaluated by first evaluating its arguments 
            and then evaluating the corresponding defined predicate's body with the appropriate
            bindings.
            </summary>
            <param name="world">The evaluation world.</param>
            <param name="bindings">A set of variable bindings.</param>
            <returns>True, false, or undefined.</returns>
        </member>
        <member name="M:PDDLParser.Exp.Formula.TLPlan.DefinedPredicateApplication.EvaluateWithImmediateShortCircuit(PDDLParser.World.IReadOnlyClosedWorld,PDDLParser.Exp.LocalBindings)">
            <summary>
            Evaluates this logical expression in the specified closed world.
            In addition to False, Undefined also shortcircuit conjunctions.
            A defined predicate application is evaluated by first evaluating its arguments 
            and then evaluating the corresponding defined predicate's body with the appropriate
            bindings.
            </summary>
            <param name="world">The evaluation world.</param>
            <param name="bindings">A set of variable bindings.</param>
            <returns>True, false, or undefined.</returns>
        </member>
        <member name="M:PDDLParser.Exp.Formula.TLPlan.DefinedPredicateApplication.EnumerateAllSatisfyingWorlds">
            <summary>
            This function is not supported.
            </summary>
            <returns>Throws an exception.</returns>
            <exception cref="T:System.NotSupportedException">A NotSupportedException is always thrown
            since this function is not supported.</exception>
        </member>
        <member name="M:PDDLParser.Exp.Formula.TLPlan.DefinedPredicateApplication.Progress(PDDLParser.World.IReadOnlyDurativeClosedWorld,PDDLParser.Exp.LocalBindings)">
            <summary>
            Evaluates the progression of this constraint expression in the next worlds.
            </summary>
            <param name="world">The current world.</param>
            <param name="bindings">A set of variable bindings.</param>
            <returns>True, false, or undefined.</returns>
        </member>
        <member name="M:PDDLParser.Exp.Formula.TLPlan.DefinedPredicateApplication.EvaluateIdle(PDDLParser.World.IReadOnlyDurativeClosedWorld,PDDLParser.Exp.LocalBindings)">
            <summary>
            Evaluates this constraint expression in an idle world, i.e. a world which
            won't be modified by further updates.
            </summary>
            <param name="idleWorld">The (idle) evaluation world.</param>
            <param name="bindings">A set of variable bindings.</param>
            <returns>True, false, or undefined.</returns>
        </member>
        <member name="T:PDDLParser.Exp.Constraint.TLPlan.AbsoluteTAlwaysExp">
            <summary>
            Represents the "t-always" constraint expression. This is not part of PDDL; it was rather added
            for TLPLan.
            This constraint expression uses absolute timestamps.
            </summary>
            <remarks>
            This object should only be created by <see cref="T:PDDLParser.Exp.Constraint.TLPlan.TAlwaysExp"/> constraint expressions.
            </remarks>
            <seealso cref="T:PDDLParser.Exp.Constraint.TLPlan.TAlwaysExp"/>
        </member>
        <member name="M:PDDLParser.Exp.Constraint.TLPlan.AbsoluteTAlwaysExp.#ctor(PDDLParser.Exp.Struct.TimeInterval,PDDLParser.Exp.IConstraintExp)">
            <summary>
            Creates a new "t-always" constraint expression with absolute timestamps.
            </summary>
            <param name="absoluteInterval">The absolute interval.</param>
            <param name="exp">The body of the constraint expression.</param>
        </member>
        <member name="M:PDDLParser.Exp.Constraint.TLPlan.AbsoluteTAlwaysExp.Progress(PDDLParser.World.IReadOnlyDurativeClosedWorld,PDDLParser.Exp.LocalBindings)">
            <summary>
            Evaluates the progression of this constraint expression in the next worlds.
            </summary>
            <param name="world">The current world.</param>
            <param name="bindings">A set of variable bindings.</param>
            <returns>True, false, undefined, or a progressed expression.</returns>
            <exception cref="T:PDDLParser.Exception.BindingException">A BindingException is thrown if an attempt
            is made to evaluate an unbound variable.</exception>
            <seealso cref="M:PDDLParser.Exp.IConstraintExp.Progress(PDDLParser.World.IReadOnlyDurativeClosedWorld,PDDLParser.Exp.LocalBindings)"/>
        </member>
        <member name="M:PDDLParser.Exp.Constraint.TLPlan.AbsoluteTAlwaysExp.EvaluateIdle(PDDLParser.World.IReadOnlyDurativeClosedWorld,PDDLParser.Exp.LocalBindings)">
            <summary>
            Evaluates this constraint expression in an idle world, i.e. a world which
            won't be modified by further updates.
            </summary>
            <param name="idleWorld">The (idle) evaluation world.</param>
            <param name="bindings">A set of variable bindings.</param>
            <returns>True, false, or undefined.</returns>
            <exception cref="T:PDDLParser.Exception.BindingException">A BindingException is thrown if an attempt
            is made to evaluate an unbound variable.</exception>
            <seealso cref="M:PDDLParser.Exp.IConstraintExp.EvaluateIdle(PDDLParser.World.IReadOnlyDurativeClosedWorld,PDDLParser.Exp.LocalBindings)"/>
        </member>
        <member name="P:PDDLParser.Exp.Constraint.TLPlan.AbsoluteTAlwaysExp.AbsoluteTimeInterval">
            <summary>
            Gets the absolute time interval.
            </summary>
        </member>
        <member name="T:PDDLParser.Exp.Constraint.ImplyConstraintExp">
            <summary>
            Represents an implication constraint expression.
            </summary>
        </member>
        <member name="M:PDDLParser.Exp.Constraint.ImplyConstraintExp.#ctor(PDDLParser.Exp.IConstraintExp,PDDLParser.Exp.IConstraintExp)">
            <summary>
            Creates a new implication constraint expression with the specified antecedent and consequent.
            </summary>
            <param name="antecedent">The antecedent of the implication.</param>
            <param name="consequent">The consequent of the implication.</param>
        </member>
        <member name="M:PDDLParser.Exp.Constraint.ImplyConstraintExp.Progress(PDDLParser.World.IReadOnlyDurativeClosedWorld,PDDLParser.Exp.LocalBindings)">
            <summary>
            Evaluates the progression of this constraint expression in the next worlds.
            </summary>
            <param name="world">The current world.</param>
            <param name="bindings">A set of variable bindings.</param>
            <returns>True, false, undefined, or a progressed expression.</returns>
            <exception cref="T:PDDLParser.Exception.BindingException">A BindingException is thrown if an attempt
            is made to evaluate an unbound variable.</exception>
            <seealso cref="M:PDDLParser.Exp.IConstraintExp.Progress(PDDLParser.World.IReadOnlyDurativeClosedWorld,PDDLParser.Exp.LocalBindings)"/>
        </member>
        <member name="M:PDDLParser.Exp.Constraint.ImplyConstraintExp.EvaluateIdle(PDDLParser.World.IReadOnlyDurativeClosedWorld,PDDLParser.Exp.LocalBindings)">
            <summary>
            Evaluates this constraint expression in an idle world, i.e. a world which
            won't be modified by further updates.
            </summary>
            <param name="idleWorld">The (idle) evaluation world.</param>
            <param name="bindings">A set of variable bindings.</param>
            <returns>True, false, or undefined.</returns>
            <exception cref="T:PDDLParser.Exception.BindingException">A BindingException is thrown if an attempt
            is made to evaluate an unbound variable.</exception>
            <seealso cref="M:PDDLParser.Exp.IConstraintExp.EvaluateIdle(PDDLParser.World.IReadOnlyDurativeClosedWorld,PDDLParser.Exp.LocalBindings)"/>
        </member>
        <member name="T:PDDLParser.Exp.Comparison.ObjectEqualComp">
            <summary>
            This class implements an object equality comparison.
            </summary>
        </member>
        <member name="M:PDDLParser.Exp.Comparison.ObjectEqualComp.#ctor(PDDLParser.Exp.ITerm,PDDLParser.Exp.ITerm)">
            <summary>
            Creates a new object equality comparison.
            </summary>
            <param name="arg1">The first argument.</param>
            <param name="arg2">The second argument.</param>
        </member>
        <member name="M:PDDLParser.Exp.Comparison.ObjectEqualComp.Evaluate(PDDLParser.World.IReadOnlyOpenWorld,PDDLParser.Exp.LocalBindings)">
            <summary>
            Evaluates this logical expression in the specified open world.
            </summary>
            <param name="world">The evaluation world.</param>
            <param name="bindings">A set of variable bindings.</param>
            <returns>True, false, undefined, or unknown.</returns>
        </member>
        <member name="M:PDDLParser.Exp.Comparison.ObjectEqualComp.EvaluateWithImmediateShortCircuit(PDDLParser.World.IReadOnlyOpenWorld,PDDLParser.Exp.LocalBindings)">
            <summary>
            Evaluates this logical expression in the specified open world.
            In addition to False, Undefined and Unknown also shortcircuit conjunctions.
            In addition to True, Unknown also shortcircuits disjunctions.
            </summary>
            <param name="world">The evaluation world.</param>
            <param name="bindings">A set of variable bindings.</param>
            <returns>True, false, undefined, or unknown.</returns>
        </member>
        <member name="M:PDDLParser.Exp.Comparison.ObjectEqualComp.Simplify(PDDLParser.World.IReadOnlyOpenWorld,PDDLParser.Exp.LocalBindings)">
            <summary>
            Simplifies this logical expression by evaluating its known expression parts.
            </summary>
            <param name="world">The evaluation world.</param>
            <param name="bindings">A set of variable bindings.</param>
            <returns>True, false, undefined, or the simplified expression.</returns>
        </member>
        <member name="M:PDDLParser.Exp.Comparison.ObjectEqualComp.Evaluate(PDDLParser.World.IReadOnlyClosedWorld,PDDLParser.Exp.LocalBindings)">
            <summary>
            Evaluates this logical expression in the specified closed world.
            </summary>
            <param name="world">The evaluation world.</param>
            <param name="bindings">A set of variable bindings.</param>
            <returns>True, false, or undefined.</returns>
        </member>
        <member name="M:PDDLParser.Exp.Comparison.ObjectEqualComp.EvaluateWithImmediateShortCircuit(PDDLParser.World.IReadOnlyClosedWorld,PDDLParser.Exp.LocalBindings)">
            <summary>
            Evaluates this logical expression in the specified closed world.
            In addition to False, Undefined also shortcircuit conjunctions.
            </summary>
            <param name="world">The evaluation world.</param>
            <param name="bindings">A set of variable bindings.</param>
            <returns>True, false, or undefined.</returns>
        </member>
    </members>
</doc>

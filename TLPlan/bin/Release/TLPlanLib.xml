<?xml version="1.0"?>
<doc>
    <assembly>
        <name>TLPlanLib</name>
    </assembly>
    <members>
        <member name="T:TLPlan.Validator.ValidatorOptions">
            <summary>
            Represents the options of the PDDL3.0 plan validator.
            </summary>
        </member>
        <member name="F:TLPlan.Validator.ValidatorOptions.m_validatorPath">
            <summary>
            The path of the validator executable. Default is "./validator.exe".
            </summary>
        </member>
        <member name="F:TLPlan.Validator.ValidatorOptions.m_concurrencyTolerance">
            <summary>
            The time difference used to distinguish whether actions are simultaneous. Actions with a time
            difference smaller than this value will be considered simultaneous. This defaults to 0.001.
            </summary>
        </member>
        <member name="F:TLPlan.Validator.ValidatorOptions.m_verbose">
            <summary>
            Specifies whether the validator output should be verbose.
            </summary>
        </member>
        <member name="M:TLPlan.Validator.ValidatorOptions.#ctor">
            <summary>
            Creates an instance of this class with default values.
            </summary>
        </member>
        <member name="M:TLPlan.Validator.ValidatorOptions.#ctor(System.String)">
            <summary>
            Creates an instance of this class with the specified validator executable path.
            </summary>
            <param name="validatorPath">The path of the validator program.</param>
        </member>
        <member name="M:TLPlan.Validator.ValidatorOptions.SetValidatorPath(System.String)">
            <summary>
            Sets the validator executable paths.
            </summary>
            <param name="path">The path to the validator executable.</param>
            <exception cref="T:System.ArgumentException">Thrown if the file does not exist.</exception>
        </member>
        <member name="M:TLPlan.Validator.ValidatorOptions.SetConcurrencyTolerance(System.Double)">
            <summary>
            Set the concurrency tolerance to the given value. The concurrenty tolerance is used to
            determine whether two actions should be considered as simultaneous.
            </summary>
            <param name="tolerance">The tolerance threshold.</param>
        </member>
        <member name="M:TLPlan.Validator.ValidatorOptions.UnsetConcurrencyTolerance">
            <summary>
            Unsets the concurrency tolerance, using the validator's default value.
            </summary>
        </member>
        <member name="M:TLPlan.Validator.ValidatorOptions.ToString">
            <summary>
            Returns a string representation of these validator options.
            </summary>
            <returns>A string representation of these validator options.</returns>
        </member>
        <member name="P:TLPlan.Validator.ValidatorOptions.ValidatorPath">
            <summary>
            Returns the path of the validator executable.
            </summary>
        </member>
        <member name="P:TLPlan.Validator.ValidatorOptions.Verbose">
            <summary>
            Gets/sets a value indicating whether the validator output should be verbose.
            </summary>
        </member>
        <member name="T:TLPlan.TLPlanOptions">
            <summary>
            This class regroups all possible TLPlan options.
            </summary>
            <remarks>
            The DifferentBehavior attribute indicates that changing this option may have an effect
            on the planner's search mechanism. Hence the search graph may be explored differently and
            different plans may be found.
            On the other hand, the SameBehavior attribute indicates that changing this attribute should have no effect
            on the search mechanism, but it may slow or speed up the search, depending on the
            problem. The same plan should always be returned.
            </remarks>
        </member>
        <member name="F:TLPlan.TLPlanOptions.m_graphSearchStrategy">
            <summary>
            The graph search strategy to use.
            </summary>
        </member>
        <member name="M:TLPlan.TLPlanOptions.#ctor">
            <summary>
            Initializes the set of options to default values.
            </summary>
        </member>
        <member name="M:TLPlan.TLPlanOptions.GetPossibleTLPlanOptions``1(TLPlan.TLPlanOptions,System.Boolean)">
            <summary>
            Retrieves all properties bearing the [OptionType] attribute.
            </summary>
            <typeparam name="OptionType">The type of attributes, which must be BehaviorAttribute or 
            some subclass.</typeparam>
            <param name="baseOptions">The base set of options to use.</param>
            <param name="allSubstitutions">Return all possible substitutions or change all the
            options against the base set.</param>
            <returns>All properties bearing the [OptionType] attribute.</returns>
        </member>
        <member name="M:TLPlan.TLPlanOptions.GetAllOptions``1(System.Collections.Generic.List{System.Reflection.PropertyInfo},System.Int32,TLPlan.TLPlanOptions,System.Boolean)">
            <summary>
            Enumerates all possible options.
            </summary>
            <typeparam name="OptionType">The type of attributes, which must be BehaviorAttribute or 
            some subclass.</typeparam>
            <param name="properties">The list of option's properties.</param>
            <param name="currentIndex">The current property.</param>
            <param name="options">The options instance to return.</param>
            <param name="allSubstitutions">Return all possible substitutions or change all the
            options against the base set.</param>
            <returns>An enumerable over all options substitutions.</returns>
        </member>
        <member name="M:TLPlan.TLPlanOptions.SetDomain(System.String)">
            <summary>
            Sets the domain file.
            </summary>
            <param name="domain">The domain file.</param>
        </member>
        <member name="M:TLPlan.TLPlanOptions.SetProblem(System.String)">
            <summary>
            Sets the problem file.
            </summary>
            <param name="problem">The problem file.</param>
        </member>
        <member name="M:TLPlan.TLPlanOptions.SetValidationDomain(System.String)">
            <summary>
            Sets the validation domain file.
            </summary>
            <param name="domain">The validation domain file.</param>
        </member>
        <member name="M:TLPlan.TLPlanOptions.SetSearchStrategy(System.String)">
            <summary>
            Sets the search strategy, given its string representation.
            </summary>
            <param name="strategy">The string representation of the search strategy.</param>
        </member>
        <member name="M:TLPlan.TLPlanOptions.SetStructureImplementation(System.String)">
            <summary>
            Sets the structure implementation, given its string representation.
            </summary>
            <param name="imp">The string representation of the structure implementation.</param>
        </member>
        <member name="M:TLPlan.TLPlanOptions.SetWorldImplementation(System.String)">
            <summary>
            Sets the world implementation, given its string representation.
            </summary>
            <param name="imp">The string representation of the world implementation.</param>
        </member>
        <member name="M:TLPlan.TLPlanOptions.SetFactsContainerImplementation(System.String)">
            <summary>
            Sets the facts container implementation, given its string representation.
            </summary>
            <param name="imp">The string representation of the facts container implementation.</param>
        </member>
        <member name="M:TLPlan.TLPlanOptions.SetFluentsContainerImplementation(System.String)">
            <summary>
            Sets the fluents container implementation, given its string representation.
            </summary>
            <param name="imp">The string representation of the fluents container implementation.</param>
        </member>
        <member name="M:TLPlan.TLPlanOptions.SetPreprocessingLevel(System.String)">
            <summary>
            Sets the preprocessing level, given its string representation.
            </summary>
            <param name="imp">The string representation of the processing level.</param>
        </member>
        <member name="M:TLPlan.TLPlanOptions.ValidateOptions">
            <summary>
            Validates the options.
            </summary>
            <returns>True if the options are valid.</returns>
        </member>
        <member name="M:TLPlan.TLPlanOptions.Reset">
            <summary>
            Resets the options to their default values.
            </summary>
        </member>
        <member name="M:TLPlan.TLPlanOptions.CreateSet``1">
            <summary>
            Creates the appropriate set given the set implementation.
            </summary>
            <typeparam name="Value">The type of the elements in the set.</typeparam>
            <returns>A set of the given implementation.</returns>
        </member>
        <member name="M:TLPlan.TLPlanOptions.CreateDictionary``2">
            <summary>
            Creates the appropriate dictionary given the dictionary implementation.
            </summary>
            <typeparam name="Key">The type of the keys in the set.</typeparam>
            <typeparam name="Value">The type of the values in the set.</typeparam>
            <returns>A dictionary of the given implementation.</returns>
        </member>
        <member name="M:TLPlan.TLPlanOptions.CreateWorld(PDDLParser.Parser.PDDLObject)">
            <summary>
            Creates a new open world used to store the values of the predicates and fluents of the
            given PDDL problem. The world is created according to this set of options.
            </summary>
            <param name="problem">The PDDL problem to solve.</param>
            <returns>A new open world.</returns>
        </member>
        <member name="M:TLPlan.TLPlanOptions.CreateWorld(System.Collections.Generic.IEnumerable{PDDLParser.Exp.Formula.DescribedFormula})">
            <summary>
            Creates a new open world responsible for storing the values of the specified 
            described formulas (and no other formulas).
            </summary>
            <param name="formulas">The described formulas whose value must be stored.</param>
            <returns>A new open world.</returns>
        </member>
        <member name="M:TLPlan.TLPlanOptions.CreateInvariantWorld(PDDLParser.Parser.PDDLObject)">
            <summary>
            Creates a new invariant world used to store the values of all the invariant predicates 
            and fluents of the given PDDL problem.
            </summary>
            <param name="problem">The PDDL problem to solve.</param>
            <returns>The invariant world for the given PDDL problem.</returns>
        </member>
        <member name="M:TLPlan.TLPlanOptions.CreateFactsContainer(System.Collections.Generic.IEnumerable{PDDLParser.Exp.Formula.AtomicFormula})">
            <summary>
            Creates an empty facts container according to this set of options.
            </summary>
            <param name="predicates">All the predicates whose values must be stored.</param>
            <returns>An empty facts container.</returns>
        </member>
        <member name="M:TLPlan.TLPlanOptions.CreateFluentsContainer(System.Collections.Generic.IEnumerable{PDDLParser.Exp.Formula.Fluent})">
            <summary>
            Creates an empty fluents container according to this set of options.
            </summary>
            <param name="fluents">All the fluents whose value must be stored.</param>
            <returns>An empty fluents container.</returns>
        </member>
        <member name="M:TLPlan.TLPlanOptions.GetDefinitionInterval``1(System.Collections.Generic.IEnumerable{``0})">
            <summary>
            Returns the sum of all filtered described formulas' domain cardinality.
            </summary>
            <typeparam name="T">The type of formulas.</typeparam>
            <param name="formulas">An enumeartion of the formulas whose domain cardinality is to sum.</param>
            <returns>The sum of all filtered described formulas' domain cardinality.</returns>
        </member>
        <member name="M:TLPlan.TLPlanOptions.ToString">
            <summary>
            Returns a string representation of the options.
            </summary>
            <returns>A string representation of the options.</returns>
        </member>
        <member name="M:TLPlan.TLPlanOptions.Clone">
            <summary>
            Returns a clone of these options.
            </summary>
            <returns>A clone of these options.</returns>
        </member>
        <member name="P:TLPlan.TLPlanOptions.Domain">
            <summary>
            The domain file to use.
            </summary>
        </member>
        <member name="P:TLPlan.TLPlanOptions.Problem">
            <summary>
            The problem file to use.
            </summary>
        </member>
        <member name="P:TLPlan.TLPlanOptions.SearchStrategy">
            <summary>
            The graph search strategy to use.
            </summary>
        </member>
        <member name="P:TLPlan.TLPlanOptions.WorldImp">
            <summary>
            The world implementation to use.
            </summary>
        </member>
        <member name="P:TLPlan.TLPlanOptions.FactsContainerImp">
            <summary>
            The facts container implementation to use. Note that this is only defined if the world
            implementation is custom.
            </summary>
        </member>
        <member name="P:TLPlan.TLPlanOptions.FluentsContainerImp">
            <summary>
            The fluents container implementation to use. Note that this is only defined if the world
            implementation is custom.
            </summary>
        </member>
        <member name="P:TLPlan.TLPlanOptions.SetStructureImp">
            <summary>
            The sets implementation. This is used to generate the appropriate
            implementation for the open and closed set needed in certain search strategies.
            </summary>
        </member>
        <member name="P:TLPlan.TLPlanOptions.ComputeInvariants">
            <summary>
            Whether invariants should be computed and stored separately from the each 
            world generated during the search process.
            </summary>
        </member>
        <member name="P:TLPlan.TLPlanOptions.PreprocessLevel">
            <summary>
            The level of preprocessing to complete before starting the actual graph search process.
            The preprocessing phase is used to simplify actions preconditions.
            </summary>
        </member>
        <member name="P:TLPlan.TLPlanOptions.ImmediatelyPruneSuccessors">
            <summary>
            If true, immediately prune successors using the temporal control formula.
            Else, discard successors only when they are the next ones to be explored.
            </summary>
        </member>
        <member name="P:TLPlan.TLPlanOptions.CycleChecking">
            <summary>
            Whether to check for cycles when exploring the graph.
            If set to false, the search may never return since it may explore cycles 
            ad vitam eternam.
            </summary>
        </member>
        <member name="P:TLPlan.TLPlanOptions.UseBacktracking">
            <summary>
            Whether to use backtracking when exploring the graph.
            If set to false, all successors of a world, except the first one, are discarded.
            </summary>
        </member>
        <member name="P:TLPlan.TLPlanOptions.ConcurrentActions">
            <summary>
            Whether to support concurrency in planning.
            If set to false, only sequential plans are generated.
            </summary>
        </member>
        <member name="P:TLPlan.TLPlanOptions.AllowUndefinedFluents">
            <summary>
            Whether to allow the use of undefined fluents.
            If set to false, the program throws an exception whenever an undefined fluent is
            evaluated.
            </summary>
        </member>
        <member name="P:TLPlan.TLPlanOptions.OrderActionsByPriority">
            <summary>
            Whether to sort actions by priority.
            Two search strategies, i.e. breadth-first-priority and depth-first-priority sort
            actions by priority.
            </summary>
        </member>
        <member name="P:TLPlan.TLPlanOptions.ElideWaitEvent">
            <summary>
            Whether to hide the wait-for-next-event in plans.
            </summary>
        </member>
        <member name="P:TLPlan.TLPlanOptions.TraceLevel">
            <summary>
            The trace level represents the amount of trace information output by the
            search algorithm.
            0 - No tracing.
            1 - Print the world being expanded and the successors being generated.
            2 - Print the level 1 information and the progressed constraints.
            </summary>
        </member>
        <member name="P:TLPlan.TLPlanOptions.SearchLimit">
            <summary>
            The maximum number of worlds to visit during the search.
            Set this value to 0 for no limit.
            </summary>
        </member>
        <member name="P:TLPlan.TLPlanOptions.HasSearchLimit">
            <summary>
            Whether there is a search limit.
            </summary>
        </member>
        <member name="P:TLPlan.TLPlanOptions.TimeLimit">
            <summary>
            The maximum time limit during the search.
            Set this value to 0 for no limit.
            </summary>
        </member>
        <member name="P:TLPlan.TLPlanOptions.HasTimeLimit">
            <summary>
            Whether there is a time limit.
            </summary>
        </member>
        <member name="P:TLPlan.TLPlanOptions.ValidatePlan">
            <summary>
            Whether to validate the plan (using the validator) when one is found.
            </summary>
        </member>
        <member name="P:TLPlan.TLPlanOptions.ValidationDomain">
            <summary>
            The PDDL domain used for validation. This domain must be PDDL3.0-compliant
            (no TLPlan special operators, no object fluents, ...).
            </summary>
        </member>
        <member name="T:TLPlan.TLPlanOptions.DefinedIf">
            <summary>
            Indicates that a property is defined only if a certain other property has a specific value.
            </summary>
        </member>
        <member name="F:TLPlan.TLPlanOptions.DefinedIf.m_propertyName">
            <summary>
            The name of the parent property.
            </summary>
        </member>
        <member name="F:TLPlan.TLPlanOptions.DefinedIf.m_propertyValue">
            <summary>
            The value the parent property must take for the other property to be defined.
            </summary>
        </member>
        <member name="M:TLPlan.TLPlanOptions.DefinedIf.#ctor(System.String,System.Object)">
            <summary>
            Creates a new DefinedIf instance with the specified parent property name and value.
            </summary>
            <param name="propertyName">The parent property name.</param>
            <param name="propertyValue">The parent property value.</param>
        </member>
        <member name="M:TLPlan.TLPlanOptions.DefinedIf.isDefined(TLPlan.TLPlanOptions)">
            <summary>
            Returns whether the other property is defined, given the options instance.
            </summary>
            <param name="instance">An options instance.</param>
            <returns>Whether the other property is defined.</returns>
        </member>
        <member name="T:TLPlan.TLPlanOptions.BehaviorAttribute">
            <summary>
            Base class for behavior attributes.
            </summary>
        </member>
        <member name="F:TLPlan.TLPlanOptions.BehaviorAttribute.m_conditions">
            <summary>
            The conditions indicating when this property is defined.
            </summary>
        </member>
        <member name="M:TLPlan.TLPlanOptions.BehaviorAttribute.#ctor">
            <summary>
            Creates a new behavior attribute.
            </summary>
        </member>
        <member name="M:TLPlan.TLPlanOptions.BehaviorAttribute.#ctor(System.String,System.Object)">
            <summary>
            Creates a new behavior attribute. The property is defined only if a parent
            property takes a specific value.
            </summary>
            <param name="propertyName">The parent property name.</param>
            <param name="propertyValue">The parent property value it must take for this property
            to be defined.</param>
        </member>
        <member name="M:TLPlan.TLPlanOptions.BehaviorAttribute.IsDefined(TLPlan.TLPlanOptions)">
            <summary>
            Returns whether this property is defined, given an options instance.
            </summary>
            <param name="instance">An options instance.</param>
            <returns>Whether this property is defined.</returns>
        </member>
        <member name="T:TLPlan.TLPlanOptions.SameBehaviorAttribute">
            <summary>
            This attribute indicates that the property should not modify the behavior of 
            the planner, i.e. the same plan should always be found.
            </summary>
        </member>
        <member name="M:TLPlan.TLPlanOptions.SameBehaviorAttribute.#ctor">
            <summary>
            Creates a new attribute indicating that the property does not modify the 
            planner behavior.
            </summary>
        </member>
        <member name="M:TLPlan.TLPlanOptions.SameBehaviorAttribute.#ctor(System.String,System.Object)">
            <summary>
            Creates a new attribute indicating that the property does not modify the 
            planner behavior. Furthermore, the property is defined only if a parent property 
            takes a specific value.     
            </summary>
            <param name="propertyName">The parent property name.</param>
            <param name="propertyValue">The parent property value it must take for this property
            to be defined.</param>
        </member>
        <member name="T:TLPlan.TLPlanOptions.SameBehaviorSameStatsAttribute">
            <summary>
            This attribute indicates that the property should not modify the behavior of 
            the planner, i.e. the same plan should always be found.
            </summary>
        </member>
        <member name="M:TLPlan.TLPlanOptions.SameBehaviorSameStatsAttribute.#ctor">
            <summary>
            Creates a new attribute indicating that the property does not modify neither
            the planner behavior nor the stats produced.
            </summary>
        </member>
        <member name="M:TLPlan.TLPlanOptions.SameBehaviorSameStatsAttribute.#ctor(System.String,System.Object)">
            <summary>
            Creates a new attribute indicating that the property does not modify neither
            the planner behavior nor the stats produced. Furthermore, the property is 
            defined only if a parent property takes a specific value.     
            </summary>
            <param name="propertyName">The parent property name.</param>
            <param name="propertyValue">The parent property value it must take for this property
            to be defined.</param>
        </member>
        <member name="T:TLPlan.TLPlanOptions.SameBehaviorDifferentStatsAttribute">
            <summary>
            This attribute indicates that the property should not modify the behavior of 
            the planner, i.e. the same plan should always be found.
            </summary>
        </member>
        <member name="M:TLPlan.TLPlanOptions.SameBehaviorDifferentStatsAttribute.#ctor">
            <summary>
            Creates a new attribute indicating that the property does not modify 
            the planner behavior but does modify the stats produced.
            </summary>
        </member>
        <member name="M:TLPlan.TLPlanOptions.SameBehaviorDifferentStatsAttribute.#ctor(System.String,System.Object)">
            <summary>
            Creates a new attribute indicating that the property does not modify 
            the planner behavior but does modify the stats produced. Furthermore, the 
            property is defined only if a parent property takes a specific value.     
            </summary>
            <param name="propertyName">The parent property name.</param>
            <param name="propertyValue">The parent property value it must take for this property
            to be defined.</param>
        </member>
        <member name="T:TLPlan.TLPlanOptions.DifferentBehaviorAttribute">
            <summary>
            This attribute indicates that the property modifies the planner's search mechanism, 
            hence the search graph is explored differently and a different plan may be found.
            </summary>
        </member>
        <member name="M:TLPlan.TLPlanOptions.DifferentBehaviorAttribute.#ctor">
            <summary>
            Creates a new attribute indicating that the property modifies the behavior of the
            planner.
            </summary>
        </member>
        <member name="M:TLPlan.TLPlanOptions.DifferentBehaviorAttribute.#ctor(System.String,System.Object)">
            <summary>
            Creates a new attribute indicating that the property modifies the behavior of the
            planner. Furthermore, the property is defined only if a parent property 
            takes a specific value. 
            </summary>
            <param name="propertyName">The parent property name.</param>
            <param name="propertyValue">The parent property value it must take for this property
            to be defined.</param>
        </member>
        <member name="T:TLPlan.TLPlanOptions.GraphSearchStrategy">
            <summary>
            All possible graph search strategies.
            </summary>
        </member>
        <member name="F:TLPlan.TLPlanOptions.GraphSearchStrategy.BEST_FIRST">
            <summary>
            Explores the most promising worlds first.
            </summary>
        </member>
        <member name="F:TLPlan.TLPlanOptions.GraphSearchStrategy.BREADTH_FIRST">
            <summary>
            Explores all neighborhing nodes first.
            </summary>
        </member>
        <member name="F:TLPlan.TLPlanOptions.GraphSearchStrategy.BREADTH_FIRST_PRIORITY">
            <summary>
            Explores all neighborhing nodes first, try the actions with the highest priority first.
            </summary>
        </member>
        <member name="F:TLPlan.TLPlanOptions.GraphSearchStrategy.DEPTH_FIRST">
            <summary>
            Explores as far as possible along each branch before backtracking.
            </summary>
        </member>
        <member name="F:TLPlan.TLPlanOptions.GraphSearchStrategy.DEPTH_FIRST_PRIORITY">
            <summary>
            Explores as far as possible along each branch before backtracking, 
            try the actions with the highest priority first.
            </summary>
        </member>
        <member name="F:TLPlan.TLPlanOptions.GraphSearchStrategy.DEPTH_FIRST_NO_BACKTRACKING">
            <summary>
            Explores as far as possible along a single branch. The search fails if a node
            has no valid successors.
            </summary>
        </member>
        <member name="F:TLPlan.TLPlanOptions.GraphSearchStrategy.DEPTH_BEST_FIRST">
            <summary>
            Explores as far as possible along each branch before backtracking,
            try the most promising worlds first.
            </summary>
        </member>
        <member name="T:TLPlan.TLPlanOptions.WorldType">
            <summary>
            All possible world types.
            </summary>
        </member>
        <member name="F:TLPlan.TLPlanOptions.WorldType.QUALIFIED">
            <summary>
            A qualified world uses a hashset of qualified predicates and fluents.
            </summary>
        </member>
        <member name="F:TLPlan.TLPlanOptions.WorldType.CUSTOM">
            <summary>
            A custom world may be initialized with any combination of facts/fluents container.
            </summary>
        </member>
        <member name="T:TLPlan.TLPlanOptions.FactsContainerType">
            <summary>
            All possible facts container types. Note that the facts container type is 
            defined only if the world type is Custom.
            </summary>
        </member>
        <member name="F:TLPlan.TLPlanOptions.FactsContainerType.BITSET">
            <summary>
            A bitset facts container stores predicates in a fixed bitset.
            </summary>
        </member>
        <member name="F:TLPlan.TLPlanOptions.FactsContainerType.HASHSET">
            <summary>
            A hashset facts container stores predicates in a hashset.
            </summary>
        </member>
        <member name="F:TLPlan.TLPlanOptions.FactsContainerType.TREESET">
            <summary>
            A treeset facts container stores predicates in a treeset.
            </summary>
        </member>
        <member name="T:TLPlan.TLPlanOptions.FluentsContainerType">
            <summary>
            All possible fluents container types. Note that the fluents container type is
            defined only if the world type is Custom.
            </summary>
        </member>
        <member name="F:TLPlan.TLPlanOptions.FluentsContainerType.ARRAY">
            <summary>
            An array fluents container stores fluents in a fixed array.
            </summary>
        </member>
        <member name="F:TLPlan.TLPlanOptions.FluentsContainerType.HASHMAP">
            <summary>
            A hashmap fluents container stores fluents in a hashmap.
            </summary>
        </member>
        <member name="F:TLPlan.TLPlanOptions.FluentsContainerType.TREEMAP">
            <summary>
            A treemap fluents container stores fluents in a treemap.
            </summary>
        </member>
        <member name="T:TLPlan.TLPlanOptions.SetImplementationType">
            <summary>
            All possible sets implementation type. This is used to generate the appropriate
            implementation for the open and closed set needed in certain search strategies.
            </summary>
        </member>
        <member name="F:TLPlan.TLPlanOptions.SetImplementationType.HASHSET">
            <summary>
            Generates hashsets, whose elements are not sorted.
            </summary>
        </member>
        <member name="F:TLPlan.TLPlanOptions.SetImplementationType.TREESET">
            <summary>
            Generates treesets, whose elements are sorted.
            </summary>
        </member>
        <member name="T:TLPlan.TLPlanOptions.PreprocessingLevel">
            <summary>
            All possible levels of preprocessing. The preprocessing phase takes place before the
            actual graph search process and uses the invariants to simplify actions preconditions.
            </summary>
        </member>
        <member name="F:TLPlan.TLPlanOptions.PreprocessingLevel.NONE">
            <summary>
            Do not preprocess preconditions.
            </summary>
        </member>
        <member name="F:TLPlan.TLPlanOptions.PreprocessingLevel.ALL_EXCEPT_DEFINED_FORMULAS">
            <summary>
            Preprocess all preconditions except the defined formulas.
            </summary>
        </member>
        <member name="F:TLPlan.TLPlanOptions.PreprocessingLevel.ALL">
            <summary>
            Preprocess all preconditions.
            </summary>
        </member>
        <member name="T:TLPlan.Statistics">
            <summary>
            Represents statistics gathered during the parsing and solving of a PDDL problem.
            </summary>
        </member>
        <member name="F:TLPlan.Statistics.m_aborted">
            <summary>
            Whether the planning was aborted.
            </summary>
        </member>
        <member name="F:TLPlan.Statistics.m_parseWatch">
            <summary>
            A watch that keeps track of parsing time.
            </summary>
        </member>
        <member name="F:TLPlan.Statistics.m_solveWatch">
            <summary>
            A watch that keeps track of solving time.
            </summary>
        </member>
        <member name="F:TLPlan.Statistics.m_extractNodeWatch">
            <summary>
            A watch that keeps track of node extraction time.
            </summary>
        </member>
        <member name="F:TLPlan.Statistics.m_operatorsWatch">
            <summary>
            A watch that keeps track of operator creation time.
            </summary>
        </member>
        <member name="F:TLPlan.Statistics.m_operatorCount">
            <summary>
            The total number of operators to create.
            </summary>
        </member>
        <member name="F:TLPlan.Statistics.m_filteredOperatorCount">
            <summary>
            The number of operators actually created (simplification may occur, depedinng on the options).
            </summary>
        </member>
        <member name="F:TLPlan.Statistics.m_successorCount">
            <summary>
            The total number of generated successors.
            </summary>
        </member>
        <member name="F:TLPlan.Statistics.m_successorsDiscardedConstraints">
            <summary>
            The number of successor discarded because of violated constraints.
            </summary>
        </member>
        <member name="F:TLPlan.Statistics.m_successorsDiscardedApplication">
            <summary>
            The number of successors discarded because of violated action conditions during application.
            </summary>
        </member>
        <member name="F:TLPlan.Statistics.m_successorsDiscardedCycle">
            <summary>
            The number of successors discarded because they caused a cycle.
            </summary>
        </member>
        <member name="F:TLPlan.Statistics.m_successorsBetterOpen">
            <summary>
            The number of successors which replaced a worse node in open.
            </summary>
        </member>
        <member name="F:TLPlan.Statistics.m_successorsBetterClosed">
            <summary>
            The number of successors which were added in open to replace a worse node in closed.
            </summary>
        </member>
        <member name="F:TLPlan.Statistics.m_successorsCallCount">
            <summary>
            The number of world for which successors were generated.
            </summary>
        </member>
        <member name="F:TLPlan.Statistics.m_verifySuccessorWatch">
            <summary>
            A watch that keeps track of the time it takes to generate and insert successors in the search graph.
            </summary>
        </member>
        <member name="F:TLPlan.Statistics.m_goalWatch">
            <summary>
            A watch that keeps track of goal verification time.
            </summary>
        </member>
        <member name="F:TLPlan.Statistics.m_goalCallCount">
            <summary>
            The number of worlds which were verified to be goals.
            </summary>
        </member>
        <member name="F:TLPlan.Statistics.m_nodeCount">
            <summary>
            The total number of examined node.
            </summary>
        </member>
        <member name="F:TLPlan.Statistics.m_openCount">
            <summary>
            The total number of nodes in open.
            </summary>
        </member>
        <member name="F:TLPlan.Statistics.m_closedCount">
            <summary>
            The total number of nodes in closed.
            </summary>
        </member>
        <member name="F:TLPlan.Statistics.m_failure">
            <summary>
            The reason why the planning failed.
            </summary>
        </member>
        <member name="F:TLPlan.Statistics.m_options">
            <summary>
            The options which were passed to the planner.
            </summary>
        </member>
        <member name="M:TLPlan.Statistics.#ctor">
            <summary>
            Creates a new, empty instance of the statistics.
            </summary>
        </member>
        <member name="M:TLPlan.Statistics.Reset">
            <summary>
            Resets all values and stopwatches to zero.
            </summary>
        </member>
        <member name="M:TLPlan.Statistics.ResetSolve">
            <summary>
            Resets all values to zero and all stopwatches except the one for parsing to zero.
            </summary>
        </member>
        <member name="M:TLPlan.Statistics.StartParse">
            <summary>
            Start measuring parse time.
            </summary>
        </member>
        <member name="M:TLPlan.Statistics.StopParse">
            <summary>
            Stop measuring parse time.
            </summary>
        </member>
        <member name="M:TLPlan.Statistics.StartSolve">
            <summary>
            Start measuring solve time.
            </summary>
        </member>
        <member name="M:TLPlan.Statistics.StopSolve">
            <summary>
            Stop measuring solve time.
            </summary>
        </member>
        <member name="M:TLPlan.Statistics.StartExtractNode">
            <summary>
            Start measuring node extraction time.
            </summary>
        </member>
        <member name="M:TLPlan.Statistics.StopExtractNode">
            <summary>
            Stop measuring node extraction time.
            </summary>
        </member>
        <member name="M:TLPlan.Statistics.StartOperators">
            <summary>
            Start measuring operator creation time.
            </summary>
        </member>
        <member name="M:TLPlan.Statistics.StopOperators">
            <summary>
            Stop measuring operator creation time.
            </summary>
        </member>
        <member name="M:TLPlan.Statistics.SuccessorGenerated">
            <summary>
            Count one more successor generated.
            </summary>
        </member>
        <member name="M:TLPlan.Statistics.SuccessorDiscardedConstraints">
            <summary>
            Count one more successor generated and discarded because of violated constraints.
            </summary>
        </member>
        <member name="M:TLPlan.Statistics.SuccessorDiscardedApplication">
            <summary>
            Count one more successor generated and discarded because of violated action conditions in application.
            </summary>
        </member>
        <member name="M:TLPlan.Statistics.SuccessorDiscardedCycle">
            <summary>
            Count one more successor discarded because it caused a cycle.
            </summary>
        </member>
        <member name="M:TLPlan.Statistics.SuccessorBetterOpen">
            <summary>
            Count one more successor replacing a worse one was in open.
            </summary>
        </member>
        <member name="M:TLPlan.Statistics.SuccessorBetterClosed">
            <summary>
            Count one more successor added to open to replace a worse one was in closed.
            </summary>
        </member>
        <member name="M:TLPlan.Statistics.StartVerifySuccessors">
            <summary>
            Start measuring the time it takes to generate and insert successors in the search graph and count one more world for which successors were generated.
            </summary>
        </member>
        <member name="M:TLPlan.Statistics.StopVerifySuccessors">
            <summary>
            Stop measuring the time it takes to generate and insert successors in the search graph.
            </summary>
        </member>
        <member name="M:TLPlan.Statistics.StartGoal">
            <summary>
            Start measuring goal verification time.
            </summary>
        </member>
        <member name="M:TLPlan.Statistics.StopGoal">
            <summary>
            Stop measuring goal verification time and count one more world verified to be a goal.
            </summary>
        </member>
        <member name="M:TLPlan.Statistics.NodeExamined">
            <summary>
            Count one more node examined.
            </summary>
        </member>
        <member name="M:TLPlan.Statistics.ToString">
            <summary>
            Returns a string representation of all the statistics compiled up to now.
            </summary>
            <returns>A string representation of all the statistics compiled up to now.</returns>
        </member>
        <member name="P:TLPlan.Statistics.FailureReason">
            <summary>
            Gets or sets the reason why the planning failed. A value of "None" means
            the planning did not fail.
            </summary>
        </member>
        <member name="P:TLPlan.Statistics.Aborted">
            <summary>
            Gets or sets whether the planning was aborted.
            </summary>
        </member>
        <member name="P:TLPlan.Statistics.PlanFound">
            <summary>
            Verifies whether a plan was found.
            </summary>
        </member>
        <member name="P:TLPlan.Statistics.OperatorCount">
            <summary>
            Gets or sets the total number of operators to create.
            </summary>
        </member>
        <member name="P:TLPlan.Statistics.FilteredOperatorCount">
            <summary>
            Gets to sets the actual number of operators created (simplification can occur).
            </summary>
        </member>
        <member name="P:TLPlan.Statistics.OpenCount">
            <summary>
            Gets or sets the number of nodes in open.
            </summary>
        </member>
        <member name="P:TLPlan.Statistics.ClosedCount">
            <summary>
            Gets or sets the number of nodes in closed.
            </summary>
        </member>
        <member name="P:TLPlan.Statistics.ExaminedNodeCount">
            <summary>
            Returns the number of examined nodes.
            </summary>
        </member>
        <member name="P:TLPlan.Statistics.SuccessorCount">
            <summary>
            Returns the numbers of worlds for which successors were generated.
            </summary>
        </member>
        <member name="P:TLPlan.Statistics.SuccessorCountDiscardedAfterApplication">
            <summary>
            Returns the number of successors which were discarded because of violated action conditions during application.
            </summary>
        </member>
        <member name="P:TLPlan.Statistics.ParseTime">
            <summary>
            Returns the time it took to parse the problem.
            </summary>
        </member>
        <member name="P:TLPlan.Statistics.SolveTime">
            <summary>
            Returns the time it took to solve the problem.
            </summary>
        </member>
        <member name="P:TLPlan.Statistics.Options">
            <summary>
            Gets or sets the options used by the planner.
            </summary>
        </member>
        <member name="T:TLPlan.Statistics.FailureCause">
            <summary>
            Represents the reason why the planning failed. A value of "None" means
            the planning did not fail.
            </summary>
        </member>
        <member name="F:TLPlan.Statistics.FailureCause.None">
            <summary>
            The search has not failed yet.
            </summary>
        </member>
        <member name="F:TLPlan.Statistics.FailureCause.Stopped">
            <summary>
            The search was stopped by an external event.
            </summary>
        </member>
        <member name="F:TLPlan.Statistics.FailureCause.SearchLimitReached">
            <summary>
            The search limit was reached and no plan was found yet.
            </summary>
        </member>
        <member name="F:TLPlan.Statistics.FailureCause.TimeLimitReached">
            <summary>
            The time limit was reached and no plan was found yet.
            </summary>
        </member>
        <member name="F:TLPlan.Statistics.FailureCause.NoWorldsLeftToExplore">
            <summary>
            There is no world left to explore and no plan was found.
            </summary>
        </member>
        <member name="F:TLPlan.Statistics.FailureCause.IncompatibleOptions">
            <summary>
            The options specified are not compatible with the domain or problem.
            </summary>
        </member>
        <member name="T:TLPlan.DurativeOperator">
            <summary>
            Represents a durative operator.
            </summary>
        </member>
        <member name="T:TLPlan.AbstractOperator">
            <summary>
            Represents the common part of all instantiated operators.
            </summary>
        </member>
        <member name="T:TLPlan.IOperator">
            <summary>
            Represents the instantiation of a parsed PDDL action with ground parameters.
            </summary>
        </member>
        <member name="M:TLPlan.IOperator.IsApplicable(TLPlan.World.TLPlanReadOnlyDurativeClosedWorld)">
            <summary>
            Returns whether this operator is applicable to the given world, i.e. if it's preconditions are met.
            </summary>
            <param name="world">The world in which the verification occurs.</param>
            <returns>True if the operator's preconditions are met in the given world.</returns>
        </member>
        <member name="M:TLPlan.IOperator.Apply(TLPlan.World.TLPlanReadOnlyDurativeClosedWorld)">
            <summary>
            Applies the effects of this operator on a copy of the given world.
            </summary>
            <param name="world">The world on which effects must be applied.</param>
            <returns>A copy of the given world on which the effects of this operator have been applied, or null,
            if the application failed.</returns>
        </member>
        <member name="M:TLPlan.IOperator.GetDuration(TLPlan.World.TLPlanReadOnlyDurativeClosedWorld)">
            <summary>
            Returns the duration of this operator as evaluated in the given world.
            The operator might have no duration, upon which case an exception is thrown.
            </summary>
            <param name="world">The world in which the duration must be calculated.</param>
            <exception cref="T:System.NotSupportedException">
            The operator has no duration. Call <see cref="P:TLPlan.IOperator.HasDuration"/> to verify if the operator has a duration.
            - OR -
            The durative operator contains unsupported time constraints (duration inequalities, timed-specific duration
            constraint or no duration constraint at all).
            </exception>
            <exception cref="T:PDDLParser.Exception.UndefinedExpException">The evaluation of duration encoutered an undefined value.</exception>
            <returns>The duration of this operator as evaluated in the given world.</returns>
        </member>
        <member name="P:TLPlan.IOperator.Name">
            <summary>
            Gets the name of this operator.
            </summary>
        </member>
        <member name="P:TLPlan.IOperator.IsElided">
            <summary>
            Verify whether this operator should be elided from plans, i.e. if it should not be shown in them.
            </summary>
        </member>
        <member name="P:TLPlan.IOperator.HasDuration">
            <summary>
            Verify whether this operator has a duration.
            </summary>
        </member>
        <member name="F:TLPlan.AbstractOperator.m_name">
            <summary>
            The name of this operator.
            </summary>
        </member>
        <member name="F:TLPlan.AbstractOperator.m_isElided">
            <summary>
            Whether this operator should be elided from plans.
            </summary>
        </member>
        <member name="M:TLPlan.AbstractOperator.#ctor(System.String,System.Boolean)">
            <summary>
            Creates an new instantiated operator.
            </summary>
            <param name="name">The name of the operator.</param>
            <param name="isElided">Whether the operator should be elided from plans.</param>
        </member>
        <member name="M:TLPlan.AbstractOperator.ApplyInternal(TLPlan.World.TLPlanReadOnlyDurativeClosedWorld)">
            <summary>
            Applies the effects of this operator on a copy of the given world.
            </summary>
            <param name="world">The world on which effects must be applied.</param>
            <returns>A copy of the given world on which the effects of this operator have been applied.</returns>
        </member>
        <member name="M:TLPlan.AbstractOperator.Apply(TLPlan.World.TLPlanReadOnlyDurativeClosedWorld)">
            <summary>
            Applies the effects of this operator on a copy of the given world. This also verifies whether the new world
            violates any action conditions, and applies overall effects to it.
            </summary>
            <param name="world">The world on which effects must be applied.</param>
            <returns>A copy of the given world on which the effects of this operator have been applied, or null,
            if the new world violates an action conditon.</returns>
        </member>
        <member name="M:TLPlan.AbstractOperator.IsApplicable(TLPlan.World.TLPlanReadOnlyDurativeClosedWorld)">
            <summary>
            Returns whether this operator is applicable to the given world, i.e. if it's preconditions are met.
            </summary>
            <param name="world">The world in which the verification occurs.</param>
            <returns>True if the operator's preconditions are met in the given world.</returns>
        </member>
        <member name="M:TLPlan.AbstractOperator.GetDuration(TLPlan.World.TLPlanReadOnlyDurativeClosedWorld)">
            <summary>
            Returns the duration of this operator as evaluated in the given world.
            The operator might have no duration, upon which case an exception is thrown.
            </summary>
            <param name="world">The world in which the duration must be calculated.</param>
            <exception cref="T:System.NotSupportedException">
            The operator has no duration. Call <see cref="P:TLPlan.AbstractOperator.HasDuration"/> to verify if the operator has a duration.
            </exception>
            <returns>The duration of this operator as evaluated in the given world.</returns>
        </member>
        <member name="M:TLPlan.AbstractOperator.CompareTo(TLPlan.IOperator)">
            <summary>
            Compares this operator with another operator.
            </summary>
            <param name="op">The other operator to compare this operator to.</param>
            <returns>An integer representing the total order relation between the two operators.</returns>
        </member>
        <member name="M:TLPlan.AbstractOperator.ToString">
            <summary>
            Returns a string representation of this operator.
            </summary>
            <returns>A string representation of this operator.</returns>
        </member>
        <member name="P:TLPlan.AbstractOperator.Name">
            <summary>
            Gets the name of this operator.
            </summary>
        </member>
        <member name="P:TLPlan.AbstractOperator.IsElided">
            <summary>
            Verify whether this operator should be elided from plans, i.e. if it should not be shown in them.
            </summary>
        </member>
        <member name="P:TLPlan.AbstractOperator.HasDuration">
            <summary>
            Verify whether this operator has a duration.
            </summary>
        </member>
        <member name="F:TLPlan.DurativeOperator.m_durationExp">
            <summary>
            The duration expression of this operator.
            </summary>
        </member>
        <member name="F:TLPlan.DurativeOperator.m_startCondition">
            <summary>
            The start condition of this operator.
            </summary>
        </member>
        <member name="F:TLPlan.DurativeOperator.m_overallCondition">
            <summary>
            The overall condition of this operator.
            </summary>
        </member>
        <member name="F:TLPlan.DurativeOperator.m_endCondition">
            <summary>
            The end condition of this operator.
            </summary>
        </member>
        <member name="F:TLPlan.DurativeOperator.m_startEffect">
            <summary>
            The start effect of this operator.
            </summary>
        </member>
        <member name="F:TLPlan.DurativeOperator.m_continuousEffect">
            <summary>
            The continuous effect of this operator.
            </summary>
        </member>
        <member name="F:TLPlan.DurativeOperator.m_overallEffect">
            <summary>
            The overall effect of this operator.
            As of now, this is only used for "over all" preferences.
            </summary>
        </member>
        <member name="F:TLPlan.DurativeOperator.m_endEffect">
            <summary>
            The end effect of this operator.
            </summary>
        </member>
        <member name="F:TLPlan.DurativeOperator.m_isConcurrent">
            <summary>
            Whether multiple operators can be used concurrently.
            </summary>
        </member>
        <member name="M:TLPlan.DurativeOperator.#ctor(System.String,PDDLParser.Exp.ILogicalExp,PDDLParser.Exp.ILogicalExp,PDDLParser.Exp.ILogicalExp,PDDLParser.Exp.ILogicalExp,PDDLParser.Exp.IEffect,PDDLParser.Exp.IEffect,PDDLParser.Exp.IEffect,PDDLParser.Exp.IEffect,System.Boolean,System.Boolean)">
            <summary>
            Creates a new durative operator with the given name, duration, conditions, and effects.
            </summary>
            <param name="name">The name of the operator.</param>
            <param name="duration">The duration expression of the operator.</param>
            <param name="startCondition">The start condition of the operator.</param>
            <param name="overallCondition">The overall condition of the operator.</param>
            <param name="endCondition">The end condition of the operator.</param>
            <param name="startEffect">The start effect of the operator.</param>
            <param name="continuousEffect">The continuous effect of the operator.</param>
            <param name="overallEffect">The overall effect of the operator.</param>
            <param name="endEffect">The end effect of the operator.</param>
            <param name="isConcurrent">Whether multiple operator can be used concurrently when planning.</param>
            <param name="isElided">Whether this operator should be elided from plans.</param>
        </member>
        <member name="M:TLPlan.DurativeOperator.GetDuration(TLPlan.World.TLPlanReadOnlyDurativeClosedWorld)">
            <summary>
            Returns the duration of this operator as evaluated in the given world.
            </summary>
            <param name="world">The world in which the duration must be calculated.</param>
            <exception cref="T:System.NotSupportedException">
            The durative operator contains unsupported time constraints (duration inequalities, timed-specific duration
            constraint or no duration constraint at all).
            </exception>
            <exception cref="T:PDDLParser.Exception.UndefinedExpException">The evaluation of duration encoutered an undefined value.</exception>
            <returns>The duration of this operator as evaluated in the given world.</returns>
        </member>
        <member name="M:TLPlan.DurativeOperator.ApplyInternal(TLPlan.World.TLPlanReadOnlyDurativeClosedWorld)">
            <summary>
            Applies the effects of this operator on a copy of the given world. If planning is concurrent, only
            the start effects are applied and other effects are scheduled for later application. If planning is not
            concurrent, all effects are applied at once.
            </summary>
            <param name="world">The world on which effects must be applied.</param>
            <returns>A copy of the given world on which the effects of this operator have been applied.</returns>
        </member>
        <member name="M:TLPlan.DurativeOperator.IsApplicable(TLPlan.World.TLPlanReadOnlyDurativeClosedWorld)">
            <summary>
            Returns whether this durative operator is applicable to the given world, i.e. if it's start conditions are met.
            </summary>
            <param name="world">The world in which the verification occurs.</param>
            <returns>True if the durative operator's start conditions are met in the given world.</returns>
        </member>
        <member name="T:TLPlan.Algorithms.GraphSearch">
            <summary>
            Base class for graph search algorithms.
            The Solve() method is implemented as a template method design pattern.
            </summary>
        </member>
        <member name="F:TLPlan.Algorithms.GraphSearch.m_options">
            <summary>
            TLPlan options.
            </summary>
        </member>
        <member name="F:TLPlan.Algorithms.GraphSearch.m_statistics">
            <summary>
            Search statistics.
            </summary>
        </member>
        <member name="F:TLPlan.Algorithms.GraphSearch.m_goal">
            <summary>
            The problem's goal formulation.
            </summary>
        </member>
        <member name="F:TLPlan.Algorithms.GraphSearch.m_metric">
            <summary>
            The problem's metric.
            </summary>
        </member>
        <member name="F:TLPlan.Algorithms.GraphSearch.m_paused">
            <summary>
            Whether the search is currently paused.
            </summary>
        </member>
        <member name="F:TLPlan.Algorithms.GraphSearch.m_pauseOnGoal">
            <summary>
            Whether the search should be paused when the goal world is found.
            </summary>
        </member>
        <member name="F:TLPlan.Algorithms.GraphSearch.m_stopped">
            <summary>
            Whether the search is stopped.
            </summary>
        </member>
        <member name="F:TLPlan.Algorithms.GraphSearch.m_currentNode">
            <summary>
            The current node (necessary for the GUI).
            </summary>
        </member>
        <member name="F:TLPlan.Algorithms.GraphSearch.m_traceStream">
            <summary>
            The stream to which trace information is output.
            </summary>
        </member>
        <member name="F:TLPlan.Algorithms.GraphSearch.m_pauseEvent">
            <summary>
            The pause event is used to pause/resume the search from the GUI.
            </summary>
        </member>
        <member name="M:TLPlan.Algorithms.GraphSearch.#ctor(TLPlan.TLPlanOptions,TLPlan.Statistics,TLPlan.Utils.TraceWriter)">
            <summary>
            Creates a new graph search algorithm with the specified options.
            </summary>
            <param name="options">Search options.</param>
            <param name="statistics">Statistics object to use.</param>
            <param name="traceWriter">The stream to which traces are to be written.</param>
        </member>
        <member name="M:TLPlan.Algorithms.GraphSearch.FireStarted">
            <summary>
            Fires the Started event.
            </summary>
        </member>
        <member name="M:TLPlan.Algorithms.GraphSearch.FirePaused">
            <summary>
            Fires the Paused event.
            </summary>
        </member>
        <member name="M:TLPlan.Algorithms.GraphSearch.FireUnpaused">
            <summary>
            Fires the Unpaused event.
            </summary>
        </member>
        <member name="M:TLPlan.Algorithms.GraphSearch.FireStopped">
            <summary>
            Fires the Stopped event.
            </summary>
        </member>
        <member name="M:TLPlan.Algorithms.GraphSearch.FireSolved(TLPlan.Plan)">
            <summary>
            Fires the Solved event.
            </summary>
            <param name="plan">The plan which solves the problem.</param>
        </member>
        <member name="M:TLPlan.Algorithms.GraphSearch.FireNotSolved">
            <summary>
            Fires the PlanningFinished event with arguments indicating the problem was not solved.
            </summary>
        </member>
        <member name="M:TLPlan.Algorithms.GraphSearch.Pause">
            <summary>
            Pauses the search.
            </summary>
            <returns>True if search was not already paused.</returns>
        </member>
        <member name="M:TLPlan.Algorithms.GraphSearch.Unpause">
            <summary>
            Resumes the search.
            </summary>
            <returns>True if the search was paused.</returns>
        </member>
        <member name="M:TLPlan.Algorithms.GraphSearch.Stop">
            <summary>
            Stops the search.
            </summary>
        </member>
        <member name="M:TLPlan.Algorithms.GraphSearch.Reset">
            <summary>
            Resets the search.
            </summary>
        </member>
        <member name="M:TLPlan.Algorithms.GraphSearch.Initialize(TLPlan.Node)">
            <summary>
            Initializes the search with the initial node.
            </summary>
            <param name="initialNode">The initial node.</param>
        </member>
        <member name="M:TLPlan.Algorithms.GraphSearch.GetNextNode">
            <summary>
            Returns the next node to explore.
            </summary>
            <returns>The next node to explore.</returns>
        </member>
        <member name="M:TLPlan.Algorithms.GraphSearch.CloseNode(TLPlan.Node)">
            <summary>
            Closes the given node.
            </summary>
            <param name="node">The node to close.</param>
        </member>
        <member name="M:TLPlan.Algorithms.GraphSearch.CausesCycle(TLPlan.Node)">
            <summary>
            This function returns whether the given node was already examined and thus
            represents a cycle in the search graph.
            </summary>
            <param name="node">The node to check for cycles.</param>
            <returns>Whether the given node has already been examined.</returns>
        </member>
        <member name="M:TLPlan.Algorithms.GraphSearch.AddSuccessor(TLPlan.Node)">
            <summary>
            Signals a new node to be explored eventually.
            This function returns whether to continue adding successors.
            </summary>
            <param name="successor">The new node to be explored.</param>
            <returns>Whether to continue adding successors.</returns>
        </member>
        <member name="M:TLPlan.Algorithms.GraphSearch.HasNextNode">
            <summary>
            Returns whether there is at least one node left to explore.
            </summary>
            <returns>Whether there is at least one node left to explore.</returns>
        </member>
        <member name="M:TLPlan.Algorithms.GraphSearch.GetOpenCount">
            <summary>
            Returns the number of nodes in the open set, i.e. nodes which should 
            eventually be explored.
            This function is used for computing statistics.
            </summary>
            <returns>The number of nodes in the open set.</returns>
        </member>
        <member name="M:TLPlan.Algorithms.GraphSearch.GetClosedCount">
            <summary>
            Returns the number of nodes in the closed set, i.e. nodes which have already
            been explored and whose successors have been generated.
            This function is used for computing statistics.
            </summary>
            <returns>The number of nodes in the closed set.</returns>
        </member>
        <member name="M:TLPlan.Algorithms.GraphSearch.ResetAlgorithm">
            <summary>
            Resets the search.
            All data structures should be reinitialized.
            </summary>
        </member>
        <member name="M:TLPlan.Algorithms.GraphSearch.IsGoal(TLPlan.Node)">
            <summary>
            Returns whether the given node is a goal node.
            If this function returns true, the search completes successfully by computing
            the plan associated with the node's predecessors.
            The default implementation returns true if all events have been processed, if 
            the node  satisfies the goal formulation (obviously), and if the world idles 
            correctly with respect to the trajectory constraints.
            </summary>
            <param name="node">The node to test.</param>
            <returns>Whether the given node is a goal node.</returns>
        </member>
        <member name="M:TLPlan.Algorithms.GraphSearch.GetSuccessors(System.Collections.Generic.IEnumerable{TLPlan.IOperator},TLPlan.Node)">
            <summary>
            Returns the valid successors of a given node.
            Note that successors are computed only when needed (i.e. when iterating over
            the enumerable), so very few processing has to be done to retrieve the enumerable
            itself.
            </summary>
            <param name="operators">The operators to use.</param>
            <param name="node">The current node.</param>
            <returns>The successors of the given node.</returns>
        </member>
        <member name="M:TLPlan.Algorithms.GraphSearch.CreateIdleGoalNode(TLPlan.Node)">
            <summary>
            Creates a new node (and world) in which the violated preferences have an impact
            over the node's metric evaluation.
            </summary>
            <param name="goalNode">The goal node to idle.</param>
            <returns>A new idle goal node with the updated metric evaluation.</returns>
        </member>
        <member name="M:TLPlan.Algorithms.GraphSearch.LogTraceMessage(System.String)">
            <summary>
            Logs a trace message.
            </summary>
            <param name="message">Message to log.</param>
        </member>
        <member name="M:TLPlan.Algorithms.GraphSearch.LogWorld(TLPlan.Node,TLPlan.World.WorldUtils.PrintWorldPart)">
            <summary>
            Logs the specified parts of the given world.
            </summary>
            <param name="node">The node containing the world to log.</param>
            <param name="worldParts">The world parts to log.</param>
        </member>
        <member name="M:TLPlan.Algorithms.GraphSearch.Solve(TLPlan.World.TLPlanDurativeClosedWorld,System.Collections.Generic.List{TLPlan.IOperator},PDDLParser.Exp.ILogicalExp,PDDLParser.Exp.Metric.MetricExp)">
            <summary>
            Attempts to solve a given problem.
            </summary>
            <param name="initialWorld">The initial world.</param>
            <param name="operators">The list of operators to use.</param>
            <param name="goal">The goal formulation.</param>
            <param name="metric">The metric evaluation function.</param>
            <returns>A plan that solves the problem, or null if no plan was found.</returns>
        </member>
        <member name="M:TLPlan.Algorithms.GraphSearch.CalculateGCost(TLPlan.Node)">
            <summary>
            Calculates the g-cost of a node, i.e. the cumulative cost from the initial node up
            to this point.
            The problem's metric is used to calculate the cost.
            </summary>
            <param name="node">The node whose g-cost must be set.</param>
        </member>
        <member name="M:TLPlan.Algorithms.GraphSearch.CalculateHCost(TLPlan.Node)">
            <summary>
            Calculates the h-cost of a node, i.e. an estimate of the cost to go until the 
            final node.
            </summary>
            <param name="node">The node whose h-cost must be set.</param>
        </member>
        <member name="E:TLPlan.Algorithms.GraphSearch.Started">
            <summary>
            The Started event is fired when the search starts.
            </summary>
        </member>
        <member name="E:TLPlan.Algorithms.GraphSearch.Paused">
            <summary>
            The Paused event is fired when the search is paused.
            </summary>
        </member>
        <member name="E:TLPlan.Algorithms.GraphSearch.Unpaused">
            <summary>
            The Unpaused event is fired when the search is resumed.
            </summary>
        </member>
        <member name="E:TLPlan.Algorithms.GraphSearch.Stopped">
            <summary>
            The Stopped event is fired when the search is stopped.
            </summary>
        </member>
        <member name="E:TLPlan.Algorithms.GraphSearch.PlanningFinished">
            <summary>
            The PlanningFinished event is fired when the planning is finished.
            </summary>
        </member>
        <member name="P:TLPlan.Algorithms.GraphSearch.IsPaused">
            <summary>
            Whether the search is currently paused.
            </summary>
        </member>
        <member name="P:TLPlan.Algorithms.GraphSearch.IsStopped">
            <summary>
            Whether the search is currently stopped.
            </summary>
        </member>
        <member name="P:TLPlan.Algorithms.GraphSearch.CurrentNode">
            <summary>
            The current node.
            </summary>
        </member>
        <member name="P:TLPlan.Algorithms.GraphSearch.PauseOnGoalWorld">
            <summary>
            Whether the search should be paused when the goal world is found.
            </summary>
        </member>
        <member name="T:TLPlan.World.Implementations.ArrayFluentsContainer">
            <summary>
            An array fluents container holds fluents in a fixed array.
            Since each fluent application is assigned a unique fluent ID, it is possible to
            store all possible fluents in a lookup table (indexed by their ID). This approach 
            may be more memory-expensive than other methods but it allows for constant-time 
            retrieval of fluents' value.
            </summary>
        </member>
        <member name="T:TLPlan.World.Implementations.FluentsContainer">
            <summary>
            A fluents container is responsible for holding and updating both numeric
            and object fluents.
            </summary>
        </member>
        <member name="M:TLPlan.World.Implementations.FluentsContainer.Copy">
            <summary>
            Copies this fluent container.
            </summary>
            <returns>A copy of this fluent container.</returns>
        </member>
        <member name="M:TLPlan.World.Implementations.FluentsContainer.GetNumericFluent(System.Int32)">
            <summary>
            Returns the value of the specified numeric fluent in this world.
            </summary>
            <param name="fluentID">A numeric fluent ID.</param>
            <returns>Unknown, undefined, or the value of the numeric fluent.</returns>
        </member>
        <member name="M:TLPlan.World.Implementations.FluentsContainer.GetObjectFluent(System.Int32)">
            <summary>
            Returns the value of the specified object fluent in this world.
            </summary>
            <param name="fluentID">An object fluent ID.</param>
            <returns>Unknown, undefined, or a constant representing the value of the 
            object fluent.</returns>
        </member>
        <member name="M:TLPlan.World.Implementations.FluentsContainer.SetNumericFluent(System.Int32,System.Double)">
            <summary>
            Sets the new value of the specified numeric fluent.
            </summary>
            <param name="fluentID">A numeric fluent ID.</param>
            <param name="value">The new value of the numeric fluent.</param>
        </member>
        <member name="M:TLPlan.World.Implementations.FluentsContainer.SetObjectFluent(System.Int32,PDDLParser.Exp.Term.Constant)">
            <summary>
            Sets the new value of the specified object fluent.
            </summary>
            <param name="fluentID">An object fluent ID.</param>
            <param name="value">The constant representing the new value of the object fluent.
            </param>
        </member>
        <member name="M:TLPlan.World.Implementations.FluentsContainer.UndefineObjectFluent(System.Int32)">
            <summary>
            Sets the specified object fluent to undefined.
            </summary>
            <param name="fluentID">An object fluent ID.</param>
        </member>
        <member name="M:TLPlan.World.Implementations.FluentsContainer.Equals(System.Object)">
            <summary>
            Returns whether this fluents container is equal to another fluents container.
            </summary>
            <param name="obj">The other object to test for equality.</param>
            <returns>Whether this fluents container is equal to the other object.</returns>
        </member>
        <member name="M:TLPlan.World.Implementations.FluentsContainer.GetHashCode">
            <summary>
            Returns the hash code of this fluents container.
            </summary>
            <returns>The hash code of this fluents container.</returns>
        </member>
        <member name="M:TLPlan.World.Implementations.FluentsContainer.CompareTo(TLPlan.World.Implementations.FluentsContainer)">
            <summary>
            Compares this fluents container with another fluents container.
            </summary>
            <param name="other">The other fluents container to compare this fluents container to.</param>
            <returns>An integer representing the total order relation between the two fluents containers.
            </returns>
        </member>
        <member name="F:TLPlan.World.Implementations.ArrayFluentsContainer.m_numericFluents">
            <summary>
            The fixed lookup table of numeric fluents.
            </summary>
        </member>
        <member name="F:TLPlan.World.Implementations.ArrayFluentsContainer.m_numericOffset">
            <summary>
            The offset (in a lookup table) corresponding to the numeric fluent at index 0 in 
            the numeric fluents array.
            </summary>
        </member>
        <member name="F:TLPlan.World.Implementations.ArrayFluentsContainer.m_objectFluents">
            <summary>
            The fixed lookup table of object fluents.
            </summary>
        </member>
        <member name="F:TLPlan.World.Implementations.ArrayFluentsContainer.m_objectOffset">
            <summary>
            The offset (in a lookup table) corresponding to the object fluent at index 0 in 
            the object fluents array.
            </summary>
        </member>
        <member name="F:TLPlan.World.Implementations.ArrayFluentsContainer.m_hashCode">
            <summary>
            The hash code of this fluents container.
            </summary>
        </member>
        <member name="M:TLPlan.World.Implementations.ArrayFluentsContainer.#ctor(TLPlan.Utils.IntegerInterval,TLPlan.Utils.IntegerInterval)">
            <summary>
            Creates a new array fluents container of the specified length.
            </summary>
            <param name="numericInterval">The interval of numeric fluents ID whose value are stored 
            in this new fluents container.</param>
            <param name="objectInterval">The interval of object fluents ID whose value are stored 
            in this new fluents container.</param>
        </member>
        <member name="M:TLPlan.World.Implementations.ArrayFluentsContainer.Copy">
            <summary>
            Copies this fluent container.
            </summary>
            <returns>A copy of this fluent container.</returns>
        </member>
        <member name="M:TLPlan.World.Implementations.ArrayFluentsContainer.GetNumericFluent(System.Int32)">
            <summary>
            Returns the value of the specified numeric fluent in this world.
            The fluent's value is retrieved from the lookup table.
            </summary>
            <param name="fluentID">A numeric fluent ID.</param>
            <returns>Unknown, undefined, or the value of the numeric fluent.</returns>
        </member>
        <member name="M:TLPlan.World.Implementations.ArrayFluentsContainer.GetObjectFluent(System.Int32)">
            <summary>
            Returns the value of the specified object fluent in this world.
            The fluent's value is retrieved from the lookup table.
            </summary>
            <param name="fluentID">An object fluent ID.</param>
            <returns>Unknown, undefined, or a constant representing the value of the 
            object fluent.</returns>
        </member>
        <member name="M:TLPlan.World.Implementations.ArrayFluentsContainer.SetNumericFluent(System.Int32,System.Double)">
            <summary>
            Sets the new value of the specified numeric fluent.
            </summary>
            <param name="fluentID">A numeric fluent ID.</param>
            <param name="value">The new value of the numeric fluent.</param>
        </member>
        <member name="M:TLPlan.World.Implementations.ArrayFluentsContainer.SetObjectFluent(System.Int32,PDDLParser.Exp.Term.Constant)">
            <summary>
            Sets the new value of the specified object fluent.
            </summary>
            <param name="fluentID">An object fluent ID.</param>
            <param name="value">The constant representing the new value of the object fluent.
            </param>
        </member>
        <member name="M:TLPlan.World.Implementations.ArrayFluentsContainer.UndefineObjectFluent(System.Int32)">
            <summary>
            Sets the specified object fluent to undefined.
            </summary>
            <param name="fluentID">An object fluent ID.</param>
        </member>
        <member name="M:TLPlan.World.Implementations.ArrayFluentsContainer.Equals(System.Object)">
            <summary>
            Returns whether this fluents container is equal to another fluents container.
            Two array fluent containers are equal if all their respective fluents have the
            same value pairwise.
            </summary>
            <param name="obj">The other object to test for equality.</param>
            <returns>Whether this fluents container is equal to the other object.</returns>
        </member>
        <member name="M:TLPlan.World.Implementations.ArrayFluentsContainer.GetHashCode">
            <summary>
            Returns the hash code of this fluents container.
            </summary>
            <returns>The hash code of this fluents container.</returns>
        </member>
        <member name="M:TLPlan.World.Implementations.ArrayFluentsContainer.CompareTo(TLPlan.World.Implementations.FluentsContainer)">
            <summary>
            Compares this fluents container with another fluents container.
            Comparison is done first on the hash code, then on the individual fluents.
            </summary>
            <param name="other">The other fluents container to compare this fluents container to.</param>
            <returns>An integer representing the total order relation between the two fluents containers.
            </returns>
        </member>
        <member name="P:TLPlan.World.Implementations.ArrayFluentsContainer.NumericFluentDefinitionInterval">
            <summary>
            The interval of numeric fluents ID whose value are stored in this fluents container.
            </summary>
        </member>
        <member name="P:TLPlan.World.Implementations.ArrayFluentsContainer.ObjectFluentDefinitionInterval">
            <summary>
            The interval of object fluents ID whose value are stored in this fluents container.
            </summary>
        </member>
        <member name="T:TLPlan.World.Implementations.BitSetFactsContainer">
            <summary>
            A bitset facts container holds facts in a fixed bitset.
            Since each atomic formula application is assigned a unique formula ID, it is possible to
            store all possible facts in a bitset (indexed by their ID). This approach may be more
            memory-expensive than other methods but it allows for constant-time retrieval of
            predicates' value.
            </summary>
        </member>
        <member name="T:TLPlan.World.Implementations.FactsContainer">
            <summary>
            A facts container is responsible for holding and updating facts.
            </summary>
        </member>
        <member name="M:TLPlan.World.Implementations.FactsContainer.Copy">
            <summary>
            Copies this facts container.
            </summary>
            <returns>A copy of this facts container.</returns>
        </member>
        <member name="M:TLPlan.World.Implementations.FactsContainer.IsSet(System.Int32)">
            <summary>
            Checks whether the specified described atomic formula holds in this world.
            </summary>
            <param name="formulaID">A formula ID.</param>
            <returns>True, false, or unknown.</returns>
        </member>
        <member name="M:TLPlan.World.Implementations.FactsContainer.Set(System.Int32)">
            <summary>
            Sets the specified atomic formula to true.
            </summary>
            <param name="formulaID">A formula ID.</param>
        </member>
        <member name="M:TLPlan.World.Implementations.FactsContainer.Unset(System.Int32)">
            <summary>
            Sets the specified atomic formula to false.
            </summary>
            <param name="formulaID">A formula ID.</param>
        </member>
        <member name="M:TLPlan.World.Implementations.FactsContainer.Equals(System.Object)">
            <summary>
            Returns whether this facts container is equal to another object.
            </summary>
            <param name="obj">The other object to test for equality.</param>
            <returns>Whether this facts container is equal to the other object.</returns>
        </member>
        <member name="M:TLPlan.World.Implementations.FactsContainer.GetHashCode">
            <summary>
            Returns the hash code of this facts container.
            </summary>
            <returns>The hash code of this facts container.</returns>
        </member>
        <member name="M:TLPlan.World.Implementations.FactsContainer.CompareTo(TLPlan.World.Implementations.FactsContainer)">
            <summary>
            Compares this facts container with another facts container.
            </summary>
            <param name="other">The other facts container to compare this facts container to.</param>
            <returns>An integer representing the total order relation between the two facts containers.
            </returns>
        </member>
        <member name="F:TLPlan.World.Implementations.BitSetFactsContainer.m_facts">
            <summary>
            The bitset containing all facts.
            </summary>
        </member>
        <member name="F:TLPlan.World.Implementations.BitSetFactsContainer.m_hashCode">
            <summary>
            The hash code of this facts container.
            </summary>
        </member>
        <member name="F:TLPlan.World.Implementations.BitSetFactsContainer.m_offset">
            <summary>
            The offset (in a lookup table) corresponding to the predicate at bit 0 of this bitset.
            </summary>
        </member>
        <member name="M:TLPlan.World.Implementations.BitSetFactsContainer.#ctor(TLPlan.Utils.IntegerInterval)">
            <summary>
            Creates a new bitset facts container of the specified length.
            </summary>
            <param name="interval">The interval of predicates ID whose value are stored
            in this new bitset facts container.</param>
        </member>
        <member name="M:TLPlan.World.Implementations.BitSetFactsContainer.Copy">
            <summary>
            Copies this facts container.
            </summary>
            <returns>A copy of this facts container.</returns>
        </member>
        <member name="M:TLPlan.World.Implementations.BitSetFactsContainer.IsSet(System.Int32)">
            <summary>
            Checks whether the specified described atomic formula holds in this world.
            The value (a bit) is retrieved from the bitset.
            </summary>
            <param name="formulaID">A formula ID.</param>
            <returns>True, false, or unknown.</returns>
        </member>
        <member name="M:TLPlan.World.Implementations.BitSetFactsContainer.Set(System.Int32)">
            <summary>
            Sets the specified atomic formula to true.
            This function updates the appropriate bit.
            </summary>
            <param name="formulaID">A formula ID.</param>
        </member>
        <member name="M:TLPlan.World.Implementations.BitSetFactsContainer.Unset(System.Int32)">
            <summary>
            Sets the specified atomic formula to false.
            This function updates the appropriate bit.
            </summary>
            <param name="formulaID">A formula ID.</param>
        </member>
        <member name="M:TLPlan.World.Implementations.BitSetFactsContainer.Equals(System.Object)">
            <summary>
            Returns whether this facts container is equal to another object.
            Two bitset facts containers are equal if they hold the same facts.
            </summary>
            <param name="obj">The other object to test for equality.</param>
            <returns>Whether this facts container is equal to the other object.</returns>
        </member>
        <member name="M:TLPlan.World.Implementations.BitSetFactsContainer.GetHashCode">
            <summary>
            Returns the hash code of this facts container.
            </summary>
            <returns>The hash code of this facts container.</returns>
        </member>
        <member name="M:TLPlan.World.Implementations.BitSetFactsContainer.CompareTo(TLPlan.World.Implementations.FactsContainer)">
            <summary>
            Compares this facts container with another facts container.
            Comparison is done first on the hashcode, then on the internal bitsets. 
            </summary>
            <param name="other">The other facts container to compare this facts container to.</param>
            <returns>An integer representing the total order relation between the two facts containers.
            </returns>
        </member>
        <member name="P:TLPlan.World.Implementations.BitSetFactsContainer.DefinitionInterval">
            <summary>
            The interval of predicates ID whose value are stored in this bitset.
            </summary>
        </member>
        <member name="T:TLPlan.Validator.PlanValidator">
            <summary>
            Represents a wrapper for the PDDL3.0 plan validator. The validator is an external executable.
            </summary>
        </member>
        <member name="F:TLPlan.Validator.PlanValidator.m_options">
            <summary>
            The validator's options.
            </summary>
        </member>
        <member name="F:TLPlan.Validator.PlanValidator.m_stdOut">
            <summary>
            The output stream to which informative validation messages will be written. Defaults to Console.Out.
            </summary>
        </member>
        <member name="F:TLPlan.Validator.PlanValidator.m_errorOut">
            <summary>
            The output stream to which validation error messages will be written. Defaults to Console.Error.
            </summary>
        </member>
        <member name="M:TLPlan.Validator.PlanValidator.#ctor">
            <summary>
            Creates an instance of the validator with default values.
            </summary>
        </member>
        <member name="M:TLPlan.Validator.PlanValidator.#ctor(TLPlan.Validator.ValidatorOptions,System.IO.TextWriter,System.IO.TextWriter)">
            <summary>
            Creates an instance of the validator.
            </summary>
            <param name="options">The validator's options.</param>
            <param name="outStream">The stream to which informative validation messages will be written.</param>
            <param name="errorStream">The stream to which validation error messages will be written.</param>
        </member>
        <member name="M:TLPlan.Validator.PlanValidator.Validate(System.String,System.String,TLPlan.Plan)">
            <summary>
            Validates the plan found to a problem and a domain.
            Note: The plan has to be saved to a temporary file which can the be input the the validator.
            </summary>
            <param name="domain">The PDDL3.0-compliant domain used for validation.</param>
            <param name="problem">The PDDL3.0-compliant problem used for validation.</param>
            <param name="plan">The plan found for the given domain and problem.</param>
            <returns>Whether the plan is valid.</returns>
        </member>
        <member name="P:TLPlan.Validator.PlanValidator.Options">
            <summary>
            Returns the validator's options.
            </summary>
        </member>
        <member name="P:TLPlan.Validator.PlanValidator.Out">
            <summary>
            Returns the stream to which informative validation messages will be written.
            </summary>
        </member>
        <member name="P:TLPlan.Validator.PlanValidator.Error">
            <summary>
            Returns the stream to which validation error messages will be written.
            </summary>
        </member>
        <member name="T:TLPlan.Event">
            <summary>
            Represents an event to occur at a future time. This stores overall and end conditions and effects, as well
            as the action context of the operator which created it.
            </summary>
        </member>
        <member name="F:TLPlan.Event.m_overallCondition">
            <summary>
            The overall condition to satisfy.
            </summary>
        </member>
        <member name="F:TLPlan.Event.m_endCondition">
            <summary>
            The end condition to satisfy.
            </summary>
        </member>
        <member name="F:TLPlan.Event.m_overallEffect">
            <summary>
            The overall effect. As of now, this is only used for "over all" preferences and conditional effects.
            </summary>
        </member>
        <member name="F:TLPlan.Event.m_endEffect">
            <summary>
            The end effect.
            </summary>
        </member>
        <member name="F:TLPlan.Event.m_actionContext">
            <summary>
            The action context of this event. This is unique per operator and per use of the same operator.
            </summary>
        </member>
        <member name="F:TLPlan.Event.m_hashcode">
            <summary>
            The hashcode of the event.
            </summary>
        </member>
        <member name="M:TLPlan.Event.#ctor(PDDLParser.Exp.ILogicalExp,PDDLParser.Exp.ILogicalExp,PDDLParser.Exp.IEffect,PDDLParser.Exp.IEffect,PDDLParser.ActionContext)">
            <summary>
            Creates a new event.
            </summary>
            <param name="overallCondition">The overall condition. If null, it defaults to true.</param>
            <param name="endCondition">The end condition. If null, it defaults to true.</param>
            <param name="overallEffect">The overall effects. If null, it defaults to no effect.</param>
            <param name="endEffect">The end effect. If null, it defaults to no effect.</param>
            <param name="actionContext">The action context associated with the event. If null, a new action context is created.</param>
        </member>
        <member name="M:TLPlan.Event.Copy">
            <summary>
            Returns a copy of this event. Only the action context is actually copied; the conditions and effects
            do not need to be copied, as they are never modified.
            </summary>
            <returns>A copy of this event.</returns>
        </member>
        <member name="M:TLPlan.Event.CompareTo(TLPlan.Event)">
            <summary>
            Compares this event with another event.
            </summary>
            <param name="other">The other event to compare this event to.</param>
            <returns>An integer representing the total order relation between the two events.</returns>
        </member>
        <member name="M:TLPlan.Event.Equals(System.Object)">
            <summary>
            Returns true if this event is equal to a specified object.
            </summary>
            <param name="obj">Object to test for equality.</param>
            <returns>True if this event is equal to the specified objet.</returns>
        </member>
        <member name="M:TLPlan.Event.GetHashCode">
            <summary>
            Returns the hash code of this event.
            </summary>
            <returns>The hash code of this event.</returns>
        </member>
        <member name="M:TLPlan.Event.ToString">
            <summary>
            Returns a string representation of this event.
            </summary>
            <returns>A string representation of this event.</returns>
        </member>
        <member name="P:TLPlan.Event.OverallConditions">
            <summary>
            Gets the overall condition to satisfy.
            </summary>
        </member>
        <member name="P:TLPlan.Event.EndConditions">
            <summary>
            Gets the end condition to satisfy.
            </summary>
        </member>
        <member name="P:TLPlan.Event.OverallEffects">
            <summary>
            Gets the overall effect. As of now, this is only used for "over all" preferences and conditional effects.
            </summary>
        </member>
        <member name="P:TLPlan.Event.EndEffects">
            <summary>
            Gets the end effect.
            </summary>
        </member>
        <member name="P:TLPlan.Event.ActionContext">
            <summary>
            The action context of this event. This is unique per operator and per use of the same operator.
            </summary>
        </member>
        <member name="T:TLPlan.Algorithms.UnInformedGraphSearch">
            <summary>
            Unweighted graph search is the base class for search algorithms which do not use 
            domain information (i.e. a cost function) to operate.
            </summary>
        </member>
        <member name="F:TLPlan.Algorithms.UnInformedGraphSearch.m_linkedOpen">
            <summary>
            The open set contains nodes yet to be explored.
            </summary>
        </member>
        <member name="F:TLPlan.Algorithms.UnInformedGraphSearch.m_allNodes">
            <summary>
            This structure is used only if the CycleChecking option is on.
            It contains all nodes generated up to this point and allows for efficient detection
            of cycles.
            </summary>
        </member>
        <member name="M:TLPlan.Algorithms.UnInformedGraphSearch.#ctor(TLPlan.TLPlanOptions,TLPlan.Statistics,TLPlan.Utils.TraceWriter)">
            <summary>
            Creates a new unweighted search algorithm with the specified options.
            </summary>
            <param name="options">Search options.</param>
            <param name="statistics">Statistics object to use.</param>
            <param name="traceWriter">The stream to which traces are to be written.</param>
        </member>
        <member name="M:TLPlan.Algorithms.UnInformedGraphSearch.AddSuccessorToOpenSet(TLPlan.Node)">
            <summary>
            Adds the given successor to the open set.
            </summary>
            <param name="successor">The successors to add to open set.</param>
        </member>
        <member name="M:TLPlan.Algorithms.UnInformedGraphSearch.Initialize(TLPlan.Node)">
            <summary>
            Initializes the search with the initial node.
            </summary>
            <param name="initialNode">The initial node.</param>
        </member>
        <member name="M:TLPlan.Algorithms.UnInformedGraphSearch.GetNextNode">
            <summary>
            Returns the next node in open set.
            </summary>
            <returns>The next node in open set.</returns>
        </member>
        <member name="M:TLPlan.Algorithms.UnInformedGraphSearch.CloseNode(TLPlan.Node)">
            <summary>
            Closes the given node.
            </summary>
            <param name="node">The node to close.</param>
        </member>
        <member name="M:TLPlan.Algorithms.UnInformedGraphSearch.CausesCycle(TLPlan.Node)">
            <summary>
            This function returns whether the given node was already examined and thus
            represents a cycle in the search graph.
            </summary>
            <param name="node">The node to check for cycles.</param>
            <returns>Whether the given node has already been examined.</returns>
        </member>
        <member name="M:TLPlan.Algorithms.UnInformedGraphSearch.AddSuccessor(TLPlan.Node)">
            <summary>
            Signals a new node to be explored eventually.
            This function returns whether to continue adding successors, which is always true.
            </summary>
            <param name="successor">The new node to be explored.</param>
            <returns>Whether to continue adding successors, which is always true.</returns>
        </member>
        <member name="M:TLPlan.Algorithms.UnInformedGraphSearch.HasNextNode">
            <summary>
            Returns whether there is at least one node left in open set.
            </summary>
            <returns>Whether there is at least one node left in open set.</returns>
        </member>
        <member name="M:TLPlan.Algorithms.UnInformedGraphSearch.GetOpenCount">
            <summary>
            Returns the number of nodes in the open set, i.e. nodes which should 
            eventually be explored.
            This function is used for computing statistics.
            </summary>
            <returns>The number of nodes in the open set.</returns>
        </member>
        <member name="M:TLPlan.Algorithms.UnInformedGraphSearch.GetClosedCount">
            <summary>
            Returns the number of nodes in the closed set, i.e. nodes which have already
            been explored and whose successors have been generated.
            This function is used for computing statistics.
            </summary>
            <returns>The number of nodes in the closed set.</returns>
        </member>
        <member name="M:TLPlan.Algorithms.UnInformedGraphSearch.ResetAlgorithm">
            <summary>
            Resets the search.
            All data structures should be reinitialized.
            </summary>
        </member>
        <member name="T:TLPlan.Algorithms.DepthFirstSearchNoBacktracking">
            <summary>
            Depth-first search without backtracking behaves exactly like regular depth-first search 
            with backtracking option set to off. It explores a graph along one single branch as far as
            possible until either a goal is found or there is no successor.
            </summary>
        </member>
        <member name="F:TLPlan.Algorithms.DepthFirstSearchNoBacktracking.m_nextNode">
            <summary>
            The next node to explore.
            </summary>
        </member>
        <member name="F:TLPlan.Algorithms.DepthFirstSearchNoBacktracking.m_closed">
            <summary>
            This structure is used only if the CycleChecking option is on.
            The closed set contains nodes which have already been explored.
            </summary>
        </member>
        <member name="M:TLPlan.Algorithms.DepthFirstSearchNoBacktracking.#ctor(TLPlan.TLPlanOptions,TLPlan.Statistics,TLPlan.Utils.TraceWriter)">
            <summary>
            Creates a new depth-first search no-backtracking algorithm with the specified options.
            </summary>
            <param name="options">Search options.</param>
            <param name="statistics">Statistics object to use.</param>
            <param name="traceWriter">The stream to which traces are to be written.</param>
        </member>
        <member name="M:TLPlan.Algorithms.DepthFirstSearchNoBacktracking.Initialize(TLPlan.Node)">
            <summary>
            Initializes the search with the initial node.
            </summary>
            <param name="initialNode">The initial node.</param>
        </member>
        <member name="M:TLPlan.Algorithms.DepthFirstSearchNoBacktracking.GetNextNode">
            <summary>
            Returns the next node to explore.
            </summary>
            <returns>The next node to explore.</returns>
        </member>
        <member name="M:TLPlan.Algorithms.DepthFirstSearchNoBacktracking.CloseNode(TLPlan.Node)">
            <summary>
            Closes the given node.
            </summary>
            <param name="node">The node to close.</param>
        </member>
        <member name="M:TLPlan.Algorithms.DepthFirstSearchNoBacktracking.CausesCycle(TLPlan.Node)">
            <summary>
            This function returns whether the given node was already examined and thus
            represents a cycle in the search graph.
            </summary>
            <param name="node">The node to check for cycles.</param>
            <returns>Whether the given node has already been examined.</returns>
        </member>
        <member name="M:TLPlan.Algorithms.DepthFirstSearchNoBacktracking.AddSuccessor(TLPlan.Node)">
            <summary>
            Signals a new node to be explored eventually.
            This function returns whether to continue adding successors.
            </summary>
            <param name="successor">The new node to be explored.</param>
            <returns>Whether to continue adding successors, which is true only if
            no valid successor has been found yet.</returns>
        </member>
        <member name="M:TLPlan.Algorithms.DepthFirstSearchNoBacktracking.HasNextNode">
            <summary>
            Returns whether there is at least one node left to explore.
            </summary>
            <returns>Whether there is at least one node left to explore.</returns>
        </member>
        <member name="M:TLPlan.Algorithms.DepthFirstSearchNoBacktracking.GetOpenCount">
            <summary>
            Returns the number of nodes in the open set, i.e. nodes which should 
            eventually be explored.
            This function is used for computing statistics.
            Since backtracking is not used, there is always exactly zero or one node
            in open set.
            </summary>
            <returns>The number of nodes in the open set.</returns>
        </member>
        <member name="M:TLPlan.Algorithms.DepthFirstSearchNoBacktracking.GetClosedCount">
            <summary>
            Returns the number of nodes in the closed set, i.e. nodes which have already
            been explored and whose successors have been generated.
            This function is used for computing statistics.
            </summary>
            <returns>The number of nodes in the closed set.</returns>
        </member>
        <member name="M:TLPlan.Algorithms.DepthFirstSearchNoBacktracking.ResetAlgorithm">
            <summary>
            Resets the search.
            All data structures should be reinitialized.
            </summary>
        </member>
        <member name="T:TLPlan.Utils.MultiDictionary.AbstractMultiDictionary`2">
            <summary>
            Base class for multi-dictionary implementations.
            </summary>
            <typeparam name="Key">The key type.</typeparam>
            <typeparam name="Value">The value type.</typeparam>
        </member>
        <member name="T:TLPlan.Utils.IMultiDictionary`2">
            <summary>
            A multi-dictionary associates keys to lists of values.
            </summary>
            <typeparam name="Key">The key type.</typeparam>
            <typeparam name="Value">The value type.</typeparam>
        </member>
        <member name="M:TLPlan.Utils.IMultiDictionary`2.Add(`0,`1)">
            <summary>
            Adds a value with the specific key.
            </summary>
            <param name="key">The dictionary's key.</param>
            <param name="value">The value to add.</param>
            <returns>A pointer on the linked list's node which stores the value.</returns>
        </member>
        <member name="M:TLPlan.Utils.IMultiDictionary`2.Remove(System.Collections.Generic.LinkedListNode{`1})">
            <summary>
            Removes a node from a linked list in the dictionary.
            </summary>
            <param name="node">The node to remove.</param>
        </member>
        <member name="M:TLPlan.Utils.IMultiDictionary`2.IsEmpty">
            <summary>
            Returns whether the multi-dictionary is empty.
            </summary>
            <returns>Whether the multi-dictionary is empty.</returns>
        </member>
        <member name="P:TLPlan.Utils.IMultiDictionary`2.Count">
            <summary>
            Returns the number of elements stored in the multi-dictionary.
            </summary>
        </member>
        <member name="F:TLPlan.Utils.MultiDictionary.AbstractMultiDictionary`2.m_itemCount">
            <summary>
            The number of items in the multi-dictionary.
            </summary>
        </member>
        <member name="M:TLPlan.Utils.MultiDictionary.AbstractMultiDictionary`2.#ctor">
            <summary>
            Creates a new empty multi-dictionary.
            </summary>
        </member>
        <member name="M:TLPlan.Utils.MultiDictionary.AbstractMultiDictionary`2.GetEnumerator">
            <summary>
            Returns an enumerator over all key-value pairs in the multi-dictionary.
            </summary>
            <returns>An enumerator over all key-value pairs in the multi-dictionary</returns>
        </member>
        <member name="M:TLPlan.Utils.MultiDictionary.AbstractMultiDictionary`2.System#Collections#IEnumerable#GetEnumerator">
            <summary>
            Returns an enumerator over all key-value pairs in the multi-dictionary.
            </summary>
            <returns>An enumerator over all key-value pairs in the multi-dictionary</returns>
        </member>
        <member name="M:TLPlan.Utils.MultiDictionary.AbstractMultiDictionary`2.Add(`0,`1)">
            <summary>
            Adds a value with the specific key.
            </summary>
            <param name="key">The dictionary's key.</param>
            <param name="value">The value to add.</param>
            <returns>A pointer on the linked list's node which stores the value.</returns>
        </member>
        <member name="M:TLPlan.Utils.MultiDictionary.AbstractMultiDictionary`2.Remove(System.Collections.Generic.LinkedListNode{`1})">
            <summary>
            Removes a node from a linked list in the dictionary.
            </summary>
            <param name="node">The node to remove.</param>
        </member>
        <member name="M:TLPlan.Utils.MultiDictionary.AbstractMultiDictionary`2.IsEmpty">
            <summary>
            Returns whether the multi-dictionary is empty.
            </summary>
            <returns>Whether the multi-dictionary is empty.</returns>
        </member>
        <member name="P:TLPlan.Utils.MultiDictionary.AbstractMultiDictionary`2.Items">
            <summary>
            Returns the all the items (sorted by key) present in the multi-dictionary.
            </summary>
        </member>
        <member name="P:TLPlan.Utils.MultiDictionary.AbstractMultiDictionary`2.Count">
            <summary>
            Returns the number of elements stored in the multi-dictionary.
            </summary>
        </member>
        <member name="T:TLPlan.Utils.MultiDictionary.AbstractMultiDictionary`2.MultiDictionaryEnumerator">
            <summary>
            Enumerator over the key-value pairs of the multi-dictionary.
            </summary>
        </member>
        <member name="F:TLPlan.Utils.MultiDictionary.AbstractMultiDictionary`2.MultiDictionaryEnumerator.m_mainEnumerator">
            <summary>
            Enumerator over the lists of elements.
            </summary>
        </member>
        <member name="F:TLPlan.Utils.MultiDictionary.AbstractMultiDictionary`2.MultiDictionaryEnumerator.m_listEnumerator">
            <summary>
            Enumerator over the individual elements of a list.
            </summary>
        </member>
        <member name="M:TLPlan.Utils.MultiDictionary.AbstractMultiDictionary`2.MultiDictionaryEnumerator.#ctor(TLPlan.Utils.MultiDictionary.AbstractMultiDictionary{`0,`1})">
            <summary>
            Creates a new multi-dictionary enumerator.
            </summary>
            <param name="dict">The mult-dictionary to enumerate over.</param>
        </member>
        <member name="M:TLPlan.Utils.MultiDictionary.AbstractMultiDictionary`2.MultiDictionaryEnumerator.MoveNext">
            <summary>
            Advances the enumerator to the next element of the collection.
            </summary>
            <returns>True if the enumerator was successfully advanced to the next element;
            false if the enumerator has passed the end of the collection.</returns>
        </member>
        <member name="M:TLPlan.Utils.MultiDictionary.AbstractMultiDictionary`2.MultiDictionaryEnumerator.Reset">
            <summary>
            Sets the enumerator to its initial position, which is before the first element 
            in the collection.
            </summary>
        </member>
        <member name="M:TLPlan.Utils.MultiDictionary.AbstractMultiDictionary`2.MultiDictionaryEnumerator.Dispose">
            <summary>
            Disposes the enumerator.
            </summary>
        </member>
        <member name="P:TLPlan.Utils.MultiDictionary.AbstractMultiDictionary`2.MultiDictionaryEnumerator.Current">
            <summary>
            Gets the current pair pointed to by the enumerator.
            </summary>
        </member>
        <member name="P:TLPlan.Utils.MultiDictionary.AbstractMultiDictionary`2.MultiDictionaryEnumerator.System#Collections#IEnumerator#Current">
            <summary>
            Gets the current pair pointed to by the enumerator.
            </summary>
        </member>
        <member name="T:TLPlan.Algorithms.DepthFirstSearch">
            <summary>
            Depth-first search explores a graph as far as possible along each branch 
            before backtracking.
            Hence it uses open set as a LIFO list (successors are always explored first).
            </summary>
        </member>
        <member name="F:TLPlan.Algorithms.DepthFirstSearch.m_currentSuccessors">
            <summary>
            This list contains the successors of a node, in the order which they were generated.
            It is transferred to open set when the successors generation finishes.
            </summary>
        </member>
        <member name="M:TLPlan.Algorithms.DepthFirstSearch.#ctor(TLPlan.TLPlanOptions,TLPlan.Statistics,TLPlan.Utils.TraceWriter)">
            <summary>
            Creates a new depth-first search algorithm with the specified options.
            </summary>
            <param name="options">Search options.</param>
            <param name="statistics">Statistics object to use.</param>
            <param name="traceWriter">The stream to which traces are to be written.</param>
        </member>
        <member name="M:TLPlan.Algorithms.DepthFirstSearch.TransferSuccessorsToOpenSet">
            <summary>
            Transfer all successors to open set, if needed.
            </summary>
        </member>
        <member name="M:TLPlan.Algorithms.DepthFirstSearch.AddSuccessorToOpenSet(TLPlan.Node)">
            <summary>
            Adds the given successor to the open set.
            The successors are not added directly at the front of the open list since they are 
            generated according to their priority; we want the most promising nodes to be 
            explored first. 
            </summary>
            <param name="successor">The successors to add to open set.</param>
        </member>
        <member name="M:TLPlan.Algorithms.DepthFirstSearch.GetNextNode">
            <summary>
            Returns the next node in open set.
            </summary>
            <returns>The next node in open set.</returns>
        </member>
        <member name="M:TLPlan.Algorithms.DepthFirstSearch.HasNextNode">
            <summary>
            Returns whether there is at least one node left in open set.
            </summary>
            <returns>Whether there is at least one node left in open set.</returns>
        </member>
        <member name="M:TLPlan.Algorithms.DepthFirstSearch.GetOpenCount">
            <summary>
            Returns the number of nodes in the open set, i.e. nodes which should 
            eventually be explored.
            This function is used for computing statistics.
            </summary>
            <returns>The number of nodes in the open set.</returns>
        </member>
        <member name="M:TLPlan.Algorithms.DepthFirstSearch.ResetAlgorithm">
            <summary>
            Resets the search.
            All data structures should be reinitialized.
            </summary>
        </member>
        <member name="T:TLPlan.World.TransitiveInitialWorld">
            <summary>
            A transitive initial world is used to initialize both the initial world and the invariant
            world, and does so by forwarding all updates to the appropriate world (depending on whether
            the described formula to update is invariant).
            </summary>
        </member>
        <member name="F:TLPlan.World.TransitiveInitialWorld.m_initialWorld">
            <summary>
            The initial world to initialize.
            </summary>
        </member>
        <member name="F:TLPlan.World.TransitiveInitialWorld.m_invariants">
            <summary>
            The invariant world to initialize.
            </summary>
        </member>
        <member name="M:TLPlan.World.TransitiveInitialWorld.#ctor(PDDLParser.World.IDurativeClosedWorld,TLPlan.World.Implementations.InvariantWorld)">
            <summary>
            Creates a new transitive initial world that will forward all updates to the
            initial world or the invariant world.
            </summary>
            <param name="initialWorld">The initial world to initialize.</param>
            <param name="invariants">The invariant world to initialize.</param>
        </member>
        <member name="M:TLPlan.World.TransitiveInitialWorld.IsIdleGoalWorld">
            <summary>
            This function is not supported.
            </summary>
            <exception cref="T:System.NotSupportedException">This function is not supported.
            </exception>
        </member>
        <member name="M:TLPlan.World.TransitiveInitialWorld.IsSet(PDDLParser.Exp.Formula.AtomicFormulaApplication)">
            <summary>
            This function is not supported.
            </summary>
            <exception cref="T:System.NotSupportedException">This function is not supported.
            </exception>
        </member>
        <member name="M:TLPlan.World.TransitiveInitialWorld.PDDLParser#World#IReadOnlyOpenWorld#IsSet(PDDLParser.Exp.Formula.AtomicFormulaApplication)">
            <summary>
            This function is not supported.
            </summary>
            <exception cref="T:System.NotSupportedException">This function is not supported.
            </exception>
        </member>
        <member name="M:TLPlan.World.TransitiveInitialWorld.Set(PDDLParser.Exp.Formula.AtomicFormulaApplication)">
            <summary>
            Sets the specified atomic formula to true.
            </summary>
            <param name="formula">An atomic formula with constant arguments.</param>
        </member>
        <member name="M:TLPlan.World.TransitiveInitialWorld.GetEvaluation(PDDLParser.Exp.Formula.TLPlan.DefinedPredicateApplication,System.Boolean@)">
            <summary>
            This function is not supported.
            </summary>
            <exception cref="T:System.NotSupportedException">This function is not supported.
            </exception>
        </member>
        <member name="M:TLPlan.World.TransitiveInitialWorld.Unset(PDDLParser.Exp.Formula.AtomicFormulaApplication)">
            <summary>
            This function is not supported.
            </summary>
            <exception cref="T:System.NotSupportedException">This function is not supported.
            </exception>
        </member>
        <member name="M:TLPlan.World.TransitiveInitialWorld.GetNumericFluent(PDDLParser.Exp.Formula.NumericFluentApplication)">
            <summary>
            This function is not supported.
            </summary>
            <exception cref="T:System.NotSupportedException">This function is not supported.
            </exception>
        </member>
        <member name="M:TLPlan.World.TransitiveInitialWorld.PDDLParser#World#IReadOnlyOpenWorld#GetNumericFluent(PDDLParser.Exp.Formula.NumericFluentApplication)">
            <summary>
            This function is not supported.
            </summary>
            <exception cref="T:System.NotSupportedException">This function is not supported.
            </exception>
        </member>
        <member name="M:TLPlan.World.TransitiveInitialWorld.SetNumericFluent(PDDLParser.Exp.Formula.NumericFluentApplication,System.Double)">
            <summary>
            Sets the new value of the specified numeric fluent.
            </summary>
            <param name="function">A numeric fluent with constant arguments.</param>
            <param name="value">The new value of the numeric fluent.</param>
        </member>
        <member name="M:TLPlan.World.TransitiveInitialWorld.GetEvaluation(PDDLParser.Exp.Formula.TLPlan.DefinedNumericFunctionApplication,System.Boolean@)">
            <summary>
            This function is not supported.
            </summary>
            <exception cref="T:System.NotSupportedException">This function is not supported.
            </exception>
        </member>
        <member name="M:TLPlan.World.TransitiveInitialWorld.GetObjectFluent(PDDLParser.Exp.Formula.ObjectFluentApplication)">
            <summary>
            This function is not supported.
            </summary>
            <exception cref="T:System.NotSupportedException">This function is not supported.
            </exception>
        </member>
        <member name="M:TLPlan.World.TransitiveInitialWorld.PDDLParser#World#IReadOnlyOpenWorld#GetObjectFluent(PDDLParser.Exp.Formula.ObjectFluentApplication)">
            <summary>
            This function is not supported.
            </summary>
            <exception cref="T:System.NotSupportedException">This function is not supported.
            </exception>
        </member>
        <member name="M:TLPlan.World.TransitiveInitialWorld.SetObjectFluent(PDDLParser.Exp.Formula.ObjectFluentApplication,PDDLParser.Exp.Term.Constant)">
            <summary>
            Sets the new value of the specified object fluent.
            </summary>
            <param name="function">A object fluent with constant arguments.</param>
            <param name="value">The constant representing the new value of the object fluent.
            </param>
        </member>
        <member name="M:TLPlan.World.TransitiveInitialWorld.UndefineObjectFluent(PDDLParser.Exp.Formula.ObjectFluentApplication)">
            <summary>
            This function is not supported.
            </summary>
            <exception cref="T:System.NotSupportedException">This function is not supported.
            </exception>
        </member>
        <member name="M:TLPlan.World.TransitiveInitialWorld.GetEvaluation(PDDLParser.Exp.Formula.TLPlan.DefinedObjectFunctionApplication,System.Boolean@)">
            <summary>
            This function is not supported.
            </summary>
            <exception cref="T:System.NotSupportedException">This function is not supported.
            </exception>
        </member>
        <member name="M:TLPlan.World.TransitiveInitialWorld.GetTotalTime">
            <summary>
            This function is not supported.
            </summary>
            <exception cref="T:System.NotSupportedException">This function is not supported.
            </exception>
        </member>
        <member name="M:TLPlan.World.TransitiveInitialWorld.AddEndEffect(System.Double,PDDLParser.Exp.IEffect)">
            <summary>
            Add an effect which will take place after a fixed duration.
            </summary>
            <param name="timeOffset">The relative time offset at which the effect takes place.</param>
            <param name="effect">The delayed effect.</param>
        </member>
        <member name="T:TLPlan.Utils.IntegerInterval">
            <summary>
            An interval is defined as a starting value and length.
            </summary>
        </member>
        <member name="F:TLPlan.Utils.IntegerInterval.m_start">
            <summary>
            The first value.
            </summary>
        </member>
        <member name="F:TLPlan.Utils.IntegerInterval.m_length">
            <summary>
            The length of the interval.
            </summary>
        </member>
        <member name="M:TLPlan.Utils.IntegerInterval.#ctor(System.Int32,System.Int32)">
            <summary>
            Creates a new interval with the specified first value and length.
            </summary>
            <param name="start">The first value.</param>
            <param name="length">The length of the interval.</param>
        </member>
        <member name="M:TLPlan.Utils.IntegerInterval.Contains(System.Int32)">
            <summary>
            Returns whether the specified value is contained in the interval.
            </summary>
            <param name="value">A value.</param>
            <returns>Whether the specified value is contained in the interval.</returns>
        </member>
        <member name="P:TLPlan.Utils.IntegerInterval.Start">
            <summary>
            The first value.
            </summary>
        </member>
        <member name="P:TLPlan.Utils.IntegerInterval.Length">
            <summary>
            The length of the interval.
            </summary>
        </member>
        <member name="T:TLPlan.World.TLPlanDurativeClosedWorld">
            <summary>
            Updatable durative closed world implementation for TLPlan.
            Updates concerning facts and fluents are forwarded to the inner world responsible for
            storing their values.
            </summary>
        </member>
        <member name="T:TLPlan.World.TLPlanReadOnlyDurativeClosedWorld">
            <summary>
            Read-only durative closed world implementation for TLPlan.
            These are the worlds which constitute the nodes of a planning search graph.
            A world holds:
            - a timestamp
            - invariants information
            - facts and fluents values
            - a queue of future events
            - the trajectory constraints ("hard" constraints)
            - the trajectory constraint preferences ("soft" constraints)
            </summary>
        </member>
        <member name="F:TLPlan.World.TLPlanReadOnlyDurativeClosedWorld.SmallTimeOffset">
            <summary>
            A small time offset used not to have concurrent actions.
            </summary>
        </member>
        <member name="F:TLPlan.World.TLPlanReadOnlyDurativeClosedWorld.s_worldCount">
            <summary>
            The number of worlds created up to now.
            </summary>
        </member>
        <member name="F:TLPlan.World.TLPlanReadOnlyDurativeClosedWorld.m_timeStamp">
            <summary>
            The world's timestamp.
            </summary>
        </member>
        <member name="F:TLPlan.World.TLPlanReadOnlyDurativeClosedWorld.m_invariants">
            <summary>
            Invariant world encapsulating invariant information.
            </summary>
        </member>
        <member name="F:TLPlan.World.TLPlanReadOnlyDurativeClosedWorld.m_openWorld">
            <summary>
            Open world responsible for holding facts and fluents values.
            Different implementations are possible.
            </summary>
        </member>
        <member name="F:TLPlan.World.TLPlanReadOnlyDurativeClosedWorld.m_eventQueue">
            <summary>
            Future events, sorted by their timestamps.
            </summary>
        </member>
        <member name="F:TLPlan.World.TLPlanReadOnlyDurativeClosedWorld.m_currentConstraints">
            <summary>
            Trajectory constraints which must not evaluate to false in current world.
            Note: 
            - If option PRUNE_ALL_SUCCESSORS is on, the current constraints are not kept
              in worlds and m_currentConstraints is thus always null.
            - Else (when option PRUNE_ALL_SUCCESSORS is off), the current constraints are always
              kept in worlds since they are not progressed immediately. The next constraints
              may be defined as well.
            </summary>
        </member>
        <member name="F:TLPlan.World.TLPlanReadOnlyDurativeClosedWorld.m_nextConstraints">
            <summary>
            Trajectory constraints which must not evaluate to false in successors world.
            - When option PRUNE_ALL_SUCCESSORS is on, the next constraints are always kept
              in worlds since the current constraints are progressed immediately.
            - Else when option PRUNE_ALL_SUCCESSORS is off, the next constraints may be null,
              i.e. in the case where a new node is generated and the current constraints haven't
              been progressed yet.
            </summary>
        </member>
        <member name="F:TLPlan.World.TLPlanReadOnlyDurativeClosedWorld.m_constraintPreferences">
            <summary>
            The list of all the constraint preferences.
            </summary>
        </member>
        <member name="F:TLPlan.World.TLPlanReadOnlyDurativeClosedWorld.m_nextAbsoluteConstraintTimestamp">
            <summary>
            The next absolute constraint timestamp at which something interesting happens.
            This can be considered as a special event.
            </summary>
        </member>
        <member name="F:TLPlan.World.TLPlanReadOnlyDurativeClosedWorld.m_isIdleGoal">
            <summary>
            Whether this world has been idled, which happens when the world satisfies the goal 
            expression and its metric evaluation has been updated to reflect violated goal
            constraints.
            </summary>
        </member>
        <member name="F:TLPlan.World.TLPlanReadOnlyDurativeClosedWorld.m_evaluationCache">
            <summary>
            The evaluation cache.
            </summary>
        </member>
        <member name="F:TLPlan.World.TLPlanReadOnlyDurativeClosedWorld.m_options">
            <summary>
            TLPlan options.
            </summary>
        </member>
        <member name="F:TLPlan.World.TLPlanReadOnlyDurativeClosedWorld.m_worldNumber">
            <summary>
            This world's number.
            </summary>
        </member>
        <member name="M:TLPlan.World.TLPlanReadOnlyDurativeClosedWorld.#cctor">
            <summary>
            Initializes the world count.
            </summary>
        </member>
        <member name="M:TLPlan.World.TLPlanReadOnlyDurativeClosedWorld.#ctor(System.Double,TLPlan.World.ExtendedOpenWorld,TLPlan.World.Implementations.InvariantWorld,PDDLParser.Exp.IConstraintExp,TLPlan.TLPlanOptions)">
            <summary>
            Creates a new read-only closed durative world with the specified timestamp and inner world.
            </summary>
            <param name="timeStamp">The world timestamp.</param>
            <param name="openWorld">The inner world responsible for storing facts and fluents values.</param>
            <param name="invariants">The invariant world storing invariant facts and fluents values.</param>
            <param name="currentConstraints">The trajectory constraints which the new world must respect.</param>
            <param name="options">The TLPlan options.</param>
        </member>
        <member name="M:TLPlan.World.TLPlanReadOnlyDurativeClosedWorld.IsIdleGoalWorld">
            <summary>
            Returns whether the world is an idle goal world (i.e. it satisfies a problem's goal).
            </summary>
            <returns>True if the world is an idle goal world, false otherwise.</returns>
        </member>
        <member name="M:TLPlan.World.TLPlanReadOnlyDurativeClosedWorld.IsSet(PDDLParser.Exp.Formula.AtomicFormulaApplication)">
            <summary>
            Checks whether the specified described atomic formula holds in this world.
            </summary>
            <param name="formula">A described (and ground) atomic formula.</param>
            <returns>True or false.</returns>
        </member>
        <member name="M:TLPlan.World.TLPlanReadOnlyDurativeClosedWorld.PDDLParser#World#IReadOnlyOpenWorld#IsSet(PDDLParser.Exp.Formula.AtomicFormulaApplication)">
            <summary>
            Checks whether the specified described atomic formula holds in this world.
            </summary>
            <param name="formula">A described (and ground) atomic formula.</param>
            <returns>True, false, or unknown.</returns>
        </member>
        <member name="M:TLPlan.World.TLPlanReadOnlyDurativeClosedWorld.GetEvaluation(PDDLParser.Exp.Formula.TLPlan.DefinedPredicateApplication,System.Boolean@)">
            <summary>
            Returns an evaluation record which indicates whether the given defined predicate has
            already been evaluated with the provided arguments, as well as the cached evaluation 
            value.
            </summary>
            <param name="pred">The defined predicate application.</param>
            <param name="existing">This flag is set to true if the defined predicate is already in the
            process of (or has finished) being evaluated.</param>
            <returns>An evaluation record corresponding to the specified defined predicate and 
            arguments.</returns>
        </member>
        <member name="M:TLPlan.World.TLPlanReadOnlyDurativeClosedWorld.PDDLParser#World#IReadOnlyOpenWorld#GetEvaluation(PDDLParser.Exp.Formula.TLPlan.DefinedPredicateApplication,System.Boolean@)">
            <summary>
            Returns an evaluation record which indicates whether the given defined predicate has
            already been evaluated with the provided arguments, as well as the cached evaluation 
            value.
            </summary>
            <param name="pred">The defined predicate application.</param>
            <param name="existing">This flag is set to true if the defined predicate is already in the
            process of (or has finished) being evaluated.</param>
            <returns>An evaluation record corresponding to the specified defined predicate and 
            arguments.</returns>
        </member>
        <member name="M:TLPlan.World.TLPlanReadOnlyDurativeClosedWorld.GetNumericFluent(PDDLParser.Exp.Formula.NumericFluentApplication)">
            <summary>
            Returns the value of the specified numeric fluent in this world.
            </summary>
            <param name="fluent">A described (and ground) numeric fluent.</param>
            <returns>Undefined, or the value of the numeric fluent.</returns>
        </member>
        <member name="M:TLPlan.World.TLPlanReadOnlyDurativeClosedWorld.PDDLParser#World#IReadOnlyOpenWorld#GetNumericFluent(PDDLParser.Exp.Formula.NumericFluentApplication)">
            <summary>
            Returns the value of the specified numeric fluent in this world.
            </summary>
            <param name="fluent">A described (and ground) numeric fluent.</param>
            <returns>Unknown, undefined, or the value of the numeric fluent.</returns>
        </member>
        <member name="M:TLPlan.World.TLPlanReadOnlyDurativeClosedWorld.GetEvaluation(PDDLParser.Exp.Formula.TLPlan.DefinedNumericFunctionApplication,System.Boolean@)">
            <summary>
            Returns an evaluation record which indicates whether the given defined numeric function has
            already been evaluated with the provided arguments, as well as the cached evaluation 
            value.
            </summary>
            <param name="pred">The defined numeric function application.</param>
            <param name="existing">This flag is set to true if the defined numeric function is already
            in the process of (or has finished) being evaluated.</param>
            <returns>An evaluation record corresponding to the specified defined numeric function and 
            arguments.</returns>
        </member>
        <member name="M:TLPlan.World.TLPlanReadOnlyDurativeClosedWorld.PDDLParser#World#IReadOnlyOpenWorld#GetEvaluation(PDDLParser.Exp.Formula.TLPlan.DefinedNumericFunctionApplication,System.Boolean@)">
            <summary>
            Returns an evaluation record which indicates whether the given defined numeric function has
            already been evaluated with the provided arguments, as well as the cached evaluation 
            value.
            </summary>
            <param name="pred">The defined numeric function application.</param>
            <param name="existing">This flag is set to true if the defined numeric function is already
            in the process of (or has finished) being evaluated.</param>
            <returns>An evaluation record corresponding to the specified defined numeric function and 
            arguments.</returns>
        </member>
        <member name="M:TLPlan.World.TLPlanReadOnlyDurativeClosedWorld.GetObjectFluent(PDDLParser.Exp.Formula.ObjectFluentApplication)">
            <summary>
            Returns the value of the specified object fluent in this world.
            </summary>
            <param name="fluent">A described (and ground) object fluent.</param>
            <returns>Undefined, or a constant representing the value of
            the object fluent.</returns>
        </member>
        <member name="M:TLPlan.World.TLPlanReadOnlyDurativeClosedWorld.PDDLParser#World#IReadOnlyOpenWorld#GetObjectFluent(PDDLParser.Exp.Formula.ObjectFluentApplication)">
            <summary>
            Returns the value of the specified object fluent in this world.
            </summary>
            <param name="fluent">A described (and ground) object fluent.</param>
            <returns>Unknown, undefined, or a constant representing the value of the 
            object fluent.</returns>
        </member>
        <member name="M:TLPlan.World.TLPlanReadOnlyDurativeClosedWorld.GetEvaluation(PDDLParser.Exp.Formula.TLPlan.DefinedObjectFunctionApplication,System.Boolean@)">
            <summary>
            Returns an evaluation record which indicates whether the given defined object function has
            already been evaluated with the provided arguments, as well as the cached evaluation 
            value.
            </summary>
            <param name="pred">The defined object function application.</param>
            <param name="existing">This flag is set to true if the defined object function is already
            in the process of (or has finished) being evaluated.</param>
            <returns>An evaluation record corresponding to the specified defined object function and 
            arguments.</returns>
        </member>
        <member name="M:TLPlan.World.TLPlanReadOnlyDurativeClosedWorld.PDDLParser#World#IReadOnlyOpenWorld#GetEvaluation(PDDLParser.Exp.Formula.TLPlan.DefinedObjectFunctionApplication,System.Boolean@)">
            <summary>
            Returns an evaluation record which indicates whether the given defined object function has
            already been evaluated with the provided arguments, as well as the cached evaluation 
            value.
            </summary>
            <param name="pred">The defined object function application.</param>
            <param name="existing">This flag is set to true if the defined object function is already
            in the process of (or has finished) being evaluated.</param>
            <returns>An evaluation record corresponding to the specified defined object function and 
            arguments.</returns>
        </member>
        <member name="M:TLPlan.World.TLPlanReadOnlyDurativeClosedWorld.GetTotalTime">
            <summary>
            Returns the total time it took to reach the current world.
            </summary>
            <returns>The total time of the plan up to this point.</returns>
        </member>
        <member name="M:TLPlan.World.TLPlanReadOnlyDurativeClosedWorld.Satisfies(PDDLParser.Exp.ILogicalExp)">
            <summary>
            Returns whether this world satisfies the specified condition.
            </summary>
            <param name="condition">The condition to test.</param>
            <returns>Whether this world satisfies the specified condition</returns>
        </member>
        <member name="M:TLPlan.World.TLPlanReadOnlyDurativeClosedWorld.ProgressCurrentConstraints">
            <summary>
            Progresses the world current constraints.
            This function returns false if the current constraints are not satisfied.
            </summary>
            <returns>True if the constraints have been successfully progressed, false
            if they evaluate to false.</returns>
        </member>
        <member name="M:TLPlan.World.TLPlanReadOnlyDurativeClosedWorld.IsConsistent">
            <summary>
            Determines whether the world is consistent by evaluating the overall conditions of 
            each of its queued events.
            </summary>
            <returns>Whether the world is consistent.</returns>
        </member>
        <member name="M:TLPlan.World.TLPlanReadOnlyDurativeClosedWorld.AreAllEventsProcessed">
            <summary>
            Returns whether the world has no more events to process.
            </summary>
            <returns>True if there are no more events to process and no timestamp to look forward to.</returns>
        </member>
        <member name="M:TLPlan.World.TLPlanReadOnlyDurativeClosedWorld.GetNextTimestamp">
            <summary>
            Retrieves the next absolute timestamp, be it the next one in the event queue, or the one returned by the
            last progressions.
            </summary>
            <returns>The next absolute timestamp.</returns>
        </member>
        <member name="M:TLPlan.World.TLPlanReadOnlyDurativeClosedWorld.GetNextDurativeConditions">
            <summary>
            Returns the next durative conditions which the wait-for-next-event operator must verify.
            These conditions consist of the next end conditions contained in the list (the first values
            in the list always imply the end of an action) and the remaining overall conditions, which
            must also be satisfied.
            </summary>
            <returns>The next end and overall conditions to be assessed</returns>
        </member>
        <member name="M:TLPlan.World.TLPlanReadOnlyDurativeClosedWorld.Copy">
            <summary>
            Copies this read-only durative world, returning an updatable durative world.
            </summary>
            <returns>An updatable copy of this closed durative world.</returns>
        </member>
        <member name="M:TLPlan.World.TLPlanReadOnlyDurativeClosedWorld.InternalCopy">
            <summary>
            Copies the internal structures of this world.
            </summary>
            <returns>A copy of this world.</returns>
        </member>
        <member name="M:TLPlan.World.TLPlanReadOnlyDurativeClosedWorld.GetEventQueueHashCode">
            <summary>
            Calculates the hash code of the event queue.
            </summary>
            <returns>The hash code of the event queue.</returns>
        </member>
        <member name="M:TLPlan.World.TLPlanReadOnlyDurativeClosedWorld.EventQueueEquals(TLPlan.World.TLPlanReadOnlyDurativeClosedWorld)">
            <summary>
            Determines whether this world's event queue is equal to another world's event queue.
            </summary>
            <param name="other">The other world.</param>
            <returns>Whether this world's event queue is equal the other world's event queue.</returns>
        </member>
        <member name="M:TLPlan.World.TLPlanReadOnlyDurativeClosedWorld.EventQueueCompareTo(TLPlan.World.TLPlanReadOnlyDurativeClosedWorld)">
            <summary>
            Compares this world's event queue with another world's event queue.
            </summary>
            <param name="other">The other world.</param>
            <returns>An integer representing the total order relation between the two worlds'
            event queue.</returns>
        </member>
        <member name="M:TLPlan.World.TLPlanReadOnlyDurativeClosedWorld.ExtractNextTime(PDDLParser.Exp.Struct.TimeValue)">
            <summary>
            Extracts the next time at which an interesting event will happen, according to a time bound.
            </summary>
            <remarks>
            The next interesting time will differ whether the bound is lower or upper, and whether the interval
            is closed or not. The "interesting" time of a lower, open bound (just like an upper, closed bound)
            is slightly after the given time, since no change happens on the boundary itself.
            </remarks>
            <param name="value">The time value from which the next time will be extracted.</param>
            <returns>The next "interesting" time.</returns>
        </member>
        <member name="M:TLPlan.World.TLPlanReadOnlyDurativeClosedWorld.Equals(System.Object)">
            <summary>
            Returns whether this world is equal to another object.
            </summary>
            <param name="obj">The other object to test for equality.</param>
            <returns>Whether this world is equal to the other object.</returns>
        </member>
        <member name="M:TLPlan.World.TLPlanReadOnlyDurativeClosedWorld.GetHashCode">
            <summary>
            Returns the hash code of this world.
            </summary>
            <returns>The hash code of this world.</returns>
        </member>
        <member name="M:TLPlan.World.TLPlanReadOnlyDurativeClosedWorld.ToString">
            <summary>
            Returns a string representation of this world.
            </summary>
            <returns>A string representation of this world.</returns>
        </member>
        <member name="M:TLPlan.World.TLPlanReadOnlyDurativeClosedWorld.CompareTo(TLPlan.World.TLPlanReadOnlyDurativeClosedWorld)">
            <summary>
            Compares this world with another world.
            </summary>
            <param name="other">The other world to compare this world to.</param>
            <returns>An integer representing the total order relation between the two worlds.
            </returns>
        </member>
        <member name="P:TLPlan.World.TLPlanReadOnlyDurativeClosedWorld.IsEventQueueEmpty">
            <summary>
            Whether the event queue is empty.
            </summary>
        </member>
        <member name="P:TLPlan.World.TLPlanReadOnlyDurativeClosedWorld.EventQueue">
            <summary>
            Gets the event queue.
            </summary>
        </member>
        <member name="P:TLPlan.World.TLPlanReadOnlyDurativeClosedWorld.TimeStamp">
            <summary>
            Gets the world timestamp.
            </summary>
        </member>
        <member name="P:TLPlan.World.TLPlanReadOnlyDurativeClosedWorld.Invariants">
            <summary>
            Gets the invariant world associated with this world.
            Note that all worlds belonging to the same graph are associated
            with the same invariant world.
            </summary>
        </member>
        <member name="P:TLPlan.World.TLPlanReadOnlyDurativeClosedWorld.CurrentConstraints">
            <summary>
            Gets the current constraints of this world.
            The current constraints are constraints that must not evaluate to false in
            this world.
            </summary>
        </member>
        <member name="P:TLPlan.World.TLPlanReadOnlyDurativeClosedWorld.NextConstraints">
            <summary>
            Gets the constraints applicable in the future worlds.
            The next constraints are constraints that must not evalute to false in
            successor worlds.
            </summary>
        </member>
        <member name="P:TLPlan.World.TLPlanReadOnlyDurativeClosedWorld.ConstraintPreferences">
            <summary>
            Gets the list of constraint preferences.
            </summary>
        </member>
        <member name="P:TLPlan.World.TLPlanReadOnlyDurativeClosedWorld.NextAbsoluteConstraintTimestamp">
            <summary>
            Gets the next absolute constraint timestamp at which something interesting happens.
            </summary>
        </member>
        <member name="P:TLPlan.World.TLPlanReadOnlyDurativeClosedWorld.Cache">
            <summary>
            Gets the evaluation cache, instantiating it if necessary.
            </summary>
        </member>
        <member name="P:TLPlan.World.TLPlanReadOnlyDurativeClosedWorld.WorldNumber">
            <summary>
            Gets this world's number.
            </summary>
        </member>
        <member name="M:TLPlan.World.TLPlanDurativeClosedWorld.#ctor(System.Double,TLPlan.World.ExtendedOpenWorld,TLPlan.World.Implementations.InvariantWorld,PDDLParser.Exp.IConstraintExp,TLPlan.TLPlanOptions)">
            <summary>
            Creates a new closed durative world with the specified timestamp and inner world.
            </summary>
            <param name="timeStamp">The world timestamp.</param>
            <param name="openWorld">The inner world responsible for storing facts and fluents values.</param>
            <param name="invariantWorld">The invariant world storing invariant facts and fluents values.</param>
            <param name="currentConstraints">The trajectory constraints which the new world must respect.</param>
            <param name="options">The TLPlan options.</param>
        </member>
        <member name="M:TLPlan.World.TLPlanDurativeClosedWorld.Set(PDDLParser.Exp.Formula.AtomicFormulaApplication)">
            <summary>
            Sets the specified atomic formula to true.
            </summary>
            <param name="formula">An atomic formula with constant arguments.</param>
        </member>
        <member name="M:TLPlan.World.TLPlanDurativeClosedWorld.Unset(PDDLParser.Exp.Formula.AtomicFormulaApplication)">
            <summary>
            Sets the specified atomic formula to false.
            </summary>
            <param name="formula">A atomic formula with constant arguments.</param>
        </member>
        <member name="M:TLPlan.World.TLPlanDurativeClosedWorld.SetNumericFluent(PDDLParser.Exp.Formula.NumericFluentApplication,System.Double)">
            <summary>
            Sets the new value of the specified numeric fluent.
            </summary>
            <param name="fluent">A numeric fluent with constant arguments.</param>
            <param name="value">The new value of the numeric fluent.</param>
        </member>
        <member name="M:TLPlan.World.TLPlanDurativeClosedWorld.SetObjectFluent(PDDLParser.Exp.Formula.ObjectFluentApplication,PDDLParser.Exp.Term.Constant)">
            <summary>
            Sets the new value of the specified object fluent.
            </summary>
            <param name="fluent">A object fluent with constant arguments.</param>
            <param name="value">The constant representing the new value of the object fluent.
            </param>
        </member>
        <member name="M:TLPlan.World.TLPlanDurativeClosedWorld.UndefineObjectFluent(PDDLParser.Exp.Formula.ObjectFluentApplication)">
            <summary>
            Sets the specified object fluent to undefined.
            </summary>
            <param name="fluent">A object fluent with constant arguments.</param>
        </member>
        <member name="M:TLPlan.World.TLPlanDurativeClosedWorld.AddEndEffect(System.Double,PDDLParser.Exp.IEffect)">
            <summary>
            Add an effect which will take place after a fixed duration.
            </summary>
            <param name="timeOffset">The relative time offset at which the effect takes place.</param>
            <param name="effect">The delayed effect.</param>
        </member>
        <member name="M:TLPlan.World.TLPlanDurativeClosedWorld.InvalidateEvaluationCache">
            <summary>
            Invalidates the evaluation cache.
            This is called every time the world is modified.
            </summary>
        </member>
        <member name="M:TLPlan.World.TLPlanDurativeClosedWorld.Modify(PDDLParser.World.IReadOnlyClosedWorld,PDDLParser.Exp.IEffect)">
            <summary>
            Modifies this world by applying the specified effect.
            </summary>
            <param name="evaluationWorld">The evaluation world used to evaluate conditional effects.
            </param>
            <param name="effect">The effect that modifies the world.</param>
        </member>
        <member name="M:TLPlan.World.TLPlanDurativeClosedWorld.Modify(PDDLParser.World.IReadOnlyClosedWorld,PDDLParser.Exp.IEffect,PDDLParser.ActionContext)">
            <summary>
            Modifies this world by applying the specified effect.
            </summary>
            <param name="evaluationWorld">The evaluation world used to evaluate conditional effects.
            </param>
            <param name="effect">The effect that modifies the world.</param>
            <param name="context">The action context.</param>
        </member>
        <member name="M:TLPlan.World.TLPlanDurativeClosedWorld.ApplyOverallEffects(PDDLParser.World.IReadOnlyClosedWorld)">
            <summary>
            Applies the overall effects of each event is the event queue.
            </summary>
            <param name="evaluationWorld">The evaluation world used to evaluate conditional effects.
            </param>
        </member>
        <member name="M:TLPlan.World.TLPlanDurativeClosedWorld.ApplyNextEndEffects(PDDLParser.World.IReadOnlyClosedWorld)">
            <summary>
            Apply the next operators' end effect, update the world's timestamp and remove the
            applied effects from the list.
            </summary>
            <param name="evaluationWorld">The evaluation world used to evaluate conditional effects.
            </param>
        </member>
        <member name="M:TLPlan.World.TLPlanDurativeClosedWorld.ProgressPreferences(System.Collections.Generic.IEnumerable{PDDLParser.Exp.IConstraintPrefExp})">
            <summary>
            Progresses the preference constraints retrieved from the previous world.
            </summary>
            <param name="prefs">The preference constraints to progress.</param>
        </member>
        <member name="M:TLPlan.World.TLPlanDurativeClosedWorld.AddEvent(System.Double,TLPlan.Event)">
            <summary>
            Adds an event to the event queue.
            </summary>
            <param name="timeOffset">The time offset of the event.</param>
            <param name="ev">The event to add.</param>
        </member>
        <member name="M:TLPlan.World.TLPlanDurativeClosedWorld.Copy">
            <summary>
            Copies this durative world.
            </summary>
            <returns>A copy of this closed durative world.</returns>
        </member>
        <member name="M:TLPlan.World.TLPlanDurativeClosedWorld.CompareTo(TLPlan.World.TLPlanDurativeClosedWorld)">
            <summary>
            Compares this world with another world.
            </summary>
            <param name="other">The other world to compare this world to.</param>
            <returns>An integer representing the total order relation between the two worlds.
            </returns>
        </member>
        <member name="P:TLPlan.World.TLPlanDurativeClosedWorld.IsIdleGoal">
            <summary>
            Returns whether the world is an idle goal world (whether it satisfies a goal and
            has been idled).
            </summary>
            <returns>True if the world is an idle goal world, false otherwise.</returns>
        </member>
        <member name="P:TLPlan.World.TLPlanDurativeClosedWorld.TimeStamp">
            <summary>
            The world's timestamp.
            </summary>
        </member>
        <member name="P:TLPlan.World.TLPlanDurativeClosedWorld.CurrentConstraints">
            <summary>
            Trajectory constraints which must not evaluate to false in current world.
            </summary>
        </member>
        <member name="P:TLPlan.World.TLPlanDurativeClosedWorld.NextConstraints">
            <summary>
            Trajectory constraints which must not evaluate to false in successors world.
            </summary>
        </member>
        <member name="P:TLPlan.World.TLPlanDurativeClosedWorld.NextAbsoluteConstraintTimestamp">
            <summary>
            Gets the next absolute constraint timestamp at which something interesting happens.
            </summary>
        </member>
        <member name="T:TLPlan.World.Implementations.QualifiedWorld">
            <summary>
            A qualified world is a custom world which stores facts and fluents using
            qualified hashsets.
            </summary>
        </member>
        <member name="T:TLPlan.World.ExtendedOpenWorld">
            <summary>
            An extended open world is an open world which can be copied and compared to
            other extended worlds.
            </summary>
        </member>
        <member name="F:TLPlan.World.ExtendedOpenWorld.m_options">
            <summary>
            The TLPlan options.
            </summary>
        </member>
        <member name="M:TLPlan.World.ExtendedOpenWorld.#ctor(TLPlan.TLPlanOptions)">
            <summary>
            Creates a new extended open world with the given set of options.
            </summary>
            <param name="options">A set of options.</param>
        </member>
        <member name="M:TLPlan.World.ExtendedOpenWorld.Copy">
            <summary>
            Copies this extended world.
            </summary>
            <returns>A copy of this extended world.</returns>
        </member>
        <member name="M:TLPlan.World.ExtendedOpenWorld.IsSet(PDDLParser.Exp.Formula.AtomicFormulaApplication)">
            <summary>
            Checks whether the specified described atomic formula holds in this world.
            </summary>
            <param name="formula">A described (and ground) atomic formula.</param>
            <returns>True, false, or unknown.</returns>
        </member>
        <member name="M:TLPlan.World.ExtendedOpenWorld.InternalGetNumericFluent(PDDLParser.Exp.Formula.NumericFluentApplication)">
            <summary>
            Returns the value of the specified numeric fluent in this world.
            </summary>
            <param name="fluent">A described (and ground) numeric fluent.</param>
            <returns>Unknown, undefined, or the value of the numeric fluent.</returns>
        </member>
        <member name="M:TLPlan.World.ExtendedOpenWorld.GetNumericFluent(PDDLParser.Exp.Formula.NumericFluentApplication)">
            <summary>
            Returns the value of the specified numeric fluent in this world.
            This function throws if the fluent is undefined and undefined fluents are not allowed.
            </summary>
            <param name="fluent">A described (and ground) numeric fluent.</param>
            <returns>Unknown, undefined, or the value of the numeric fluent.</returns>
        </member>
        <member name="M:TLPlan.World.ExtendedOpenWorld.InternalGetObjectFluent(PDDLParser.Exp.Formula.ObjectFluentApplication)">
            <summary>
            Returns the value of the specified object fluent in this world.
            </summary>
            <param name="fluent">A described (and ground) object fluent.</param>
            <returns>Unknown, undefined, or a constant representing the value of the 
            object fluent.</returns>
        </member>
        <member name="M:TLPlan.World.ExtendedOpenWorld.GetObjectFluent(PDDLParser.Exp.Formula.ObjectFluentApplication)">
            <summary>
            Returns the value of the specified object fluent in this world.
                /// This function throws if the fluent is undefined and undefined fluents are not allowed.
            </summary>
            <param name="fluent">A described (and ground) object fluent.</param>
            <returns>Unknown, undefined, or a constant representing the value of the 
            object fluent.</returns>
        </member>
        <member name="M:TLPlan.World.ExtendedOpenWorld.GetEvaluation(PDDLParser.Exp.Formula.TLPlan.DefinedPredicateApplication,System.Boolean@)">
            <summary>
            Returns an evaluation record which indicates whether the given defined predicate has
            already been evaluated with the provided arguments, as well as the cached evaluation 
            value.
            </summary>
            <param name="pred">The defined predicate application.</param>
            <param name="existing">This flag is set to true if the defined predicate is already in the
            process of (or has finished) being evaluated.</param>
            <returns>An evaluation record corresponding to the specified defined predicate and 
            arguments.</returns>
        </member>
        <member name="M:TLPlan.World.ExtendedOpenWorld.GetEvaluation(PDDLParser.Exp.Formula.TLPlan.DefinedNumericFunctionApplication,System.Boolean@)">
            <summary>
            Returns an evaluation record which indicates whether the given defined numeric function has
            already been evaluated with the provided arguments, as well as the cached evaluation 
            value.
            </summary>
            <param name="function">The defined numeric function application.</param>
            <param name="existing">This flag is set to true if the defined numeric function is already
            in the process of (or has finished) being evaluated.</param>
            <returns>An evaluation record corresponding to the specified defined numeric function and 
            arguments.</returns>
        </member>
        <member name="M:TLPlan.World.ExtendedOpenWorld.GetEvaluation(PDDLParser.Exp.Formula.TLPlan.DefinedObjectFunctionApplication,System.Boolean@)">
            <summary>
            Returns an evaluation record which indicates whether the given defined object function has
            already been evaluated with the provided arguments, as well as the cached evaluation 
            value.
            </summary>
            <param name="function">The defined object function application.</param>
            <param name="existing">This flag is set to true if the defined object function is already
            in the process of (or has finished) being evaluated.</param>
            <returns>An evaluation record corresponding to the specified defined object function and 
            arguments.</returns>
        </member>
        <member name="M:TLPlan.World.ExtendedOpenWorld.Set(PDDLParser.Exp.Formula.AtomicFormulaApplication)">
            <summary>
            Sets the specified atomic formula to true.
            </summary>
            <param name="formula">An atomic formula with constant arguments.</param>
        </member>
        <member name="M:TLPlan.World.ExtendedOpenWorld.Unset(PDDLParser.Exp.Formula.AtomicFormulaApplication)">
            <summary>
            Sets the specified atomic formula to false.
            </summary>
            <param name="formula">A atomic formula with constant arguments.</param>
        </member>
        <member name="M:TLPlan.World.ExtendedOpenWorld.SetNumericFluent(PDDLParser.Exp.Formula.NumericFluentApplication,System.Double)">
            <summary>
            Sets the new value of the specified numeric fluent.
            </summary>
            <param name="fluent">A numeric fluent with constant arguments.</param>
            <param name="value">The new value of the numeric fluent.</param>
        </member>
        <member name="M:TLPlan.World.ExtendedOpenWorld.SetObjectFluent(PDDLParser.Exp.Formula.ObjectFluentApplication,PDDLParser.Exp.Term.Constant)">
            <summary>
            Sets the new value of the specified object fluent.
            </summary>
            <param name="fluent">A object fluent with constant arguments.</param>
            <param name="value">The constant representing the new value of the object fluent.
            </param>
        </member>
        <member name="M:TLPlan.World.ExtendedOpenWorld.UndefineObjectFluent(PDDLParser.Exp.Formula.ObjectFluentApplication)">
            <summary>
            Sets the specified object fluent to undefined.
            </summary>
            <param name="fluent">A object fluent with constant arguments.</param>
        </member>
        <member name="M:TLPlan.World.ExtendedOpenWorld.Equals(System.Object)">
            <summary>
            Returns whether this world is equal to another object.
            </summary>
            <param name="obj">The other object to test for equality.</param>
            <returns>Whether this world is equal to the other object.</returns>
        </member>
        <member name="M:TLPlan.World.ExtendedOpenWorld.GetHashCode">
            <summary>
            Returns the hash code of this world.
            </summary>
            <returns>The hash code of this world.</returns>
        </member>
        <member name="M:TLPlan.World.ExtendedOpenWorld.CompareTo(TLPlan.World.ExtendedOpenWorld)">
            <summary>
            Compares this world with another world.
            </summary>
            <param name="other">The other world to compare this world to.</param>
            <returns>An integer representing the total order relation between the two worlds.
            </returns>
        </member>
        <member name="F:TLPlan.World.Implementations.QualifiedWorld.m_factsContainer">
            <summary>
            The facts container holds all facts.
            </summary>
        </member>
        <member name="F:TLPlan.World.Implementations.QualifiedWorld.m_fluentsContainer">
            <summary>
            The fluents container holds all numeric and object fluents.
            </summary>
        </member>
        <member name="M:TLPlan.World.Implementations.QualifiedWorld.#ctor(TLPlan.TLPlanOptions)">
            <summary>
            Creates a new qualified world using the specified set of options.
            </summary>
            <param name="options">A set of TLPlan options.</param>
        </member>
        <member name="M:TLPlan.World.Implementations.QualifiedWorld.Copy">
            <summary>
            Copies this qualified world.
            </summary>
            <returns>A copy of this qualified world.</returns>
        </member>
        <member name="M:TLPlan.World.Implementations.QualifiedWorld.IsSet(PDDLParser.Exp.Formula.AtomicFormulaApplication)">
            <summary>
            Checks whether the specified described atomic formula holds in this world.
            </summary>
            <param name="formula">A described (and ground) atomic formula.</param>
            <returns>True, false, or unknown.</returns>
        </member>
        <member name="M:TLPlan.World.Implementations.QualifiedWorld.InternalGetNumericFluent(PDDLParser.Exp.Formula.NumericFluentApplication)">
            <summary>
            Returns the value of the specified numeric fluent in this world.
            </summary>
            <param name="fluent">A described (and ground) numeric fluent.</param>
            <returns>Unknown, undefined, or the value of the numeric fluent.</returns>
        </member>
        <member name="M:TLPlan.World.Implementations.QualifiedWorld.InternalGetObjectFluent(PDDLParser.Exp.Formula.ObjectFluentApplication)">
            <summary>
            Returns the value of the specified object fluent in this world.
            </summary>
            <param name="fluent">A described (and ground) object fluent.</param>
            <returns>Unknown, undefined, or a constant representing the value of the 
            object fluent.</returns>
        </member>
        <member name="M:TLPlan.World.Implementations.QualifiedWorld.Set(PDDLParser.Exp.Formula.AtomicFormulaApplication)">
            <summary>
            Sets the specified atomic formula to true.
            </summary>
            <param name="formula">An atomic formula with constant arguments.</param>
        </member>
        <member name="M:TLPlan.World.Implementations.QualifiedWorld.Unset(PDDLParser.Exp.Formula.AtomicFormulaApplication)">
            <summary>
            Sets the specified atomic formula to false.
            </summary>
            <param name="formula">A atomic formula with constant arguments.</param>
        </member>
        <member name="M:TLPlan.World.Implementations.QualifiedWorld.SetNumericFluent(PDDLParser.Exp.Formula.NumericFluentApplication,System.Double)">
            <summary>
            Sets the new value of the specified numeric fluent.
            </summary>
            <param name="fluent">A numeric fluent with constant arguments.</param>
            <param name="value">The new value of the numeric fluent.</param>
        </member>
        <member name="M:TLPlan.World.Implementations.QualifiedWorld.SetObjectFluent(PDDLParser.Exp.Formula.ObjectFluentApplication,PDDLParser.Exp.Term.Constant)">
            <summary>
            Sets the new value of the specified object fluent.
            </summary>
            <param name="fluent">A object fluent with constant arguments.</param>
            <param name="value">The constant representing the new value of the object fluent.
            </param>
        </member>
        <member name="M:TLPlan.World.Implementations.QualifiedWorld.UndefineObjectFluent(PDDLParser.Exp.Formula.ObjectFluentApplication)">
            <summary>
            Sets the specified object fluent to undefined.
            </summary>
            <param name="fluent">A object fluent with constant arguments.</param>
        </member>
        <member name="M:TLPlan.World.Implementations.QualifiedWorld.Equals(System.Object)">
            <summary>
            Returns whether this world is equal to another object.
            </summary>
            <param name="obj">The other object to test for equality.</param>
            <returns>Whether this world is equal to the other object.</returns>
        </member>
        <member name="M:TLPlan.World.Implementations.QualifiedWorld.GetHashCode">
            <summary>
            Returns the hash code of this world.
            </summary>
            <returns>The hash code of this world.</returns>
        </member>
        <member name="M:TLPlan.World.Implementations.QualifiedWorld.ToString">
            <summary>
            Returns a string representation of this qualified world.
            </summary>
            <returns>A string representation of this qualified world.</returns>
        </member>
        <member name="M:TLPlan.World.Implementations.QualifiedWorld.CompareTo(TLPlan.World.ExtendedOpenWorld)">
            <summary>
            Compares this world with another world.
            </summary>
            <param name="world">The other world to compare this world to.</param>
            <returns>An integer representing the total order relation between the two worlds.
            </returns>
        </member>
        <member name="T:TLPlan.World.Implementations.QualifiedWorld.QualifiedHashSetFactsContainer">
            <summary>
            A qualified hashset facts container holds qualified facts in a hashset.
            This implementation is fast for retrieving predicates' value, but comparison
            between two qualified hashset facts container is slow because their respective
            elements must be sorted beforehand.
            Moreover it is a little slower than a regular hashset facts container,
            but has the (debugging) advantage of offering a decent string representation
            of the facts.
            </summary>
        </member>
        <member name="F:TLPlan.World.Implementations.QualifiedWorld.QualifiedHashSetFactsContainer.m_facts">
            <summary>
            The hashset of facts.
            </summary>
        </member>
        <member name="F:TLPlan.World.Implementations.QualifiedWorld.QualifiedHashSetFactsContainer.m_sortedFacts">
            <summary>
            The cached list of sorted facts, necessary only for comparisons 
            with other containers.
            </summary>
        </member>
        <member name="F:TLPlan.World.Implementations.QualifiedWorld.QualifiedHashSetFactsContainer.m_hashCode">
            <summary>
            The hash code of this facts container.
            </summary>
        </member>
        <member name="M:TLPlan.World.Implementations.QualifiedWorld.QualifiedHashSetFactsContainer.#ctor">
            <summary>
            Creates a new empty qualified hashset facts container.
            </summary>
        </member>
        <member name="M:TLPlan.World.Implementations.QualifiedWorld.QualifiedHashSetFactsContainer.Copy">
            <summary>
            Copies this facts container.
            </summary>
            <returns>A copy of this facts container.</returns>
        </member>
        <member name="M:TLPlan.World.Implementations.QualifiedWorld.QualifiedHashSetFactsContainer.IsSet(PDDLParser.Exp.Formula.AtomicFormulaApplication)">
            <summary>
            Checks whether the specified described atomic formula holds in this world.
            </summary>
            <param name="formula">A described (and ground) atomic formula.</param>
            <returns>True, or unknown.</returns>
        </member>
        <member name="M:TLPlan.World.Implementations.QualifiedWorld.QualifiedHashSetFactsContainer.Set(PDDLParser.Exp.Formula.AtomicFormulaApplication)">
            <summary>
            Sets the specified atomic formula to true.
            </summary>
            <param name="formula">An atomic formula with constant arguments.</param>
        </member>
        <member name="M:TLPlan.World.Implementations.QualifiedWorld.QualifiedHashSetFactsContainer.Unset(PDDLParser.Exp.Formula.AtomicFormulaApplication)">
            <summary>
            Sets the specified atomic formula to false.
            </summary>
            <param name="formula">An atomic formula with constant arguments.</param>
        </member>
        <member name="M:TLPlan.World.Implementations.QualifiedWorld.QualifiedHashSetFactsContainer.Equals(System.Object)">
            <summary>
            Returns whether this facts container is equal to another object.
            Two qualified hashset facts container are equal if they both store the same facts.
            </summary>
            <param name="obj">The other object to test for equality.</param>
            <returns>Whether this facts container is equal to the other object.</returns>
        </member>
        <member name="M:TLPlan.World.Implementations.QualifiedWorld.QualifiedHashSetFactsContainer.GetHashCode">
            <summary>
            Returns the hash code of this facts container.
            </summary>
            <returns>The hash code of this facts container.</returns>
        </member>
        <member name="M:TLPlan.World.Implementations.QualifiedWorld.QualifiedHashSetFactsContainer.ToString">
            <summary>
            Returns a string representation of this facts container.
            </summary>
            <returns>A string representation of this facts container.</returns>
        </member>
        <member name="M:TLPlan.World.Implementations.QualifiedWorld.QualifiedHashSetFactsContainer.CompareTo(TLPlan.World.Implementations.QualifiedWorld.QualifiedHashSetFactsContainer)">
            <summary>
            Compares this facts container with another facts container.
            Comparison is done first on the hash code, then on the number of facts, 
            and finally facts are sorted and compared individually.
            </summary>
            <param name="other">The other facts container to compare this facts container to.</param>
            <returns>An integer representing the total order relation between the two facts containers.
            </returns>
        </member>
        <member name="P:TLPlan.World.Implementations.QualifiedWorld.QualifiedHashSetFactsContainer.SortedFacts">
            <summary>
            The list of sorted facts, necessary only for comparisons with other containers.
            </summary>
        </member>
        <member name="T:TLPlan.World.Implementations.QualifiedWorld.QualifiedHashSetFluentsContainer">
            <summary>
            A qualified hashset fluents container holds fluents in a hashset.
            This implementation is fast for retrieving fluents' value, but comparison
            between two qualified hashset fluents container is slow because their respective
            elements must be sorted beforehand.
            Moreover it is a little slower than a regular hashset facts container,
            but has the (debugging) advantage of offering a decent string representation
            of the fluents.
            </summary>
        </member>
        <member name="F:TLPlan.World.Implementations.QualifiedWorld.QualifiedHashSetFluentsContainer.m_numericFluents">
            <summary>
            The dictionary of numeric fluents.
            </summary>
        </member>
        <member name="F:TLPlan.World.Implementations.QualifiedWorld.QualifiedHashSetFluentsContainer.m_sortedNumericFluents">
            <summary>
            The cached list of sorted numeric fluents/values, necessary only for 
            comparisons with other containers.
            </summary>
        </member>
        <member name="F:TLPlan.World.Implementations.QualifiedWorld.QualifiedHashSetFluentsContainer.m_objectFluents">
            <summary>
            The dictionary of object fluents.
            </summary>
        </member>
        <member name="F:TLPlan.World.Implementations.QualifiedWorld.QualifiedHashSetFluentsContainer.m_sortedObjectFluents">
            <summary>
            The cached list of sorted object fluents IDs/values, necessary only for
            comparisons with other containers.
            </summary>
        </member>
        <member name="F:TLPlan.World.Implementations.QualifiedWorld.QualifiedHashSetFluentsContainer.m_hashCode">
            <summary>
            The hash code of this fluents container.
            </summary>
        </member>
        <member name="M:TLPlan.World.Implementations.QualifiedWorld.QualifiedHashSetFluentsContainer.#ctor">
            <summary>
            Creates a new empty qualified hashset fluents container.
            </summary>
        </member>
        <member name="M:TLPlan.World.Implementations.QualifiedWorld.QualifiedHashSetFluentsContainer.Copy">
            <summary>
            Copies this fluent container.
            </summary>
            <returns>A copy of this fluent container.</returns>
        </member>
        <member name="M:TLPlan.World.Implementations.QualifiedWorld.QualifiedHashSetFluentsContainer.GetNumericFluent(PDDLParser.Exp.Formula.NumericFluentApplication)">
            <summary>
            Returns the value of the specified numeric fluent in this world.
            </summary>
            <param name="fluent">A described (and ground) numeric fluent.</param>
            <returns>Unknown, undefined, or the value of the numeric fluent.</returns>
        </member>
        <member name="M:TLPlan.World.Implementations.QualifiedWorld.QualifiedHashSetFluentsContainer.GetObjectFluent(PDDLParser.Exp.Formula.ObjectFluentApplication)">
            <summary>
            Returns the value of the specified object fluent in this world.
            </summary>
            <param name="fluent">A described (and ground) object fluent.</param>
            <returns>Unknown, undefined, or a constant representing the value of the 
            object fluent.</returns>
        </member>
        <member name="M:TLPlan.World.Implementations.QualifiedWorld.QualifiedHashSetFluentsContainer.SetNumericFluent(PDDLParser.Exp.Formula.NumericFluentApplication,System.Double)">
            <summary>
            Sets the new value of the specified numeric fluent.
            </summary>
            <param name="fluent">A numeric fluent with constant arguments.</param>
            <param name="value">The new value of the numeric fluent.</param>
        </member>
        <member name="M:TLPlan.World.Implementations.QualifiedWorld.QualifiedHashSetFluentsContainer.SetObjectFluent(PDDLParser.Exp.Formula.ObjectFluentApplication,PDDLParser.Exp.Term.Constant)">
            <summary>
            Sets the new value of the specified object fluent.
            </summary>
            <param name="fluent">A object fluent with constant arguments.</param>
            <param name="value">The constant representing the new value of the object fluent.
            </param>
        </member>
        <member name="M:TLPlan.World.Implementations.QualifiedWorld.QualifiedHashSetFluentsContainer.UndefineObjectFluent(PDDLParser.Exp.Formula.ObjectFluentApplication)">
            <summary>
            Sets the specified object fluent to undefined.
            </summary>
            <param name="fluent">A object fluent with constant arguments.</param>
        </member>
        <member name="M:TLPlan.World.Implementations.QualifiedWorld.QualifiedHashSetFluentsContainer.Equals(System.Object)">
            <summary>
            Returns whether this fluents container is equal to another fluents container.
            Two hashset fluent containers are equal if all their respective fluents have the
            same value pairwise.
            </summary>
            <param name="obj">The other object to test for equality.</param>
            <returns>Whether this fluents container is equal to the other object.</returns>
        </member>
        <member name="M:TLPlan.World.Implementations.QualifiedWorld.QualifiedHashSetFluentsContainer.GetHashCode">
            <summary>
            Returns the hash code of this fluents container.
            </summary>
            <returns>The hash code of this fluents container.</returns>
        </member>
        <member name="M:TLPlan.World.Implementations.QualifiedWorld.QualifiedHashSetFluentsContainer.ToString">
            <summary>
            Returns a string representation of this fluents container.
            </summary>
            <returns>A string representation of this fluents container.</returns>
        </member>
        <member name="M:TLPlan.World.Implementations.QualifiedWorld.QualifiedHashSetFluentsContainer.CompareTo(TLPlan.World.Implementations.QualifiedWorld.QualifiedHashSetFluentsContainer)">
            <summary>
            Compares this fluents container with another fluents container.
            Comparison is done first on the hash code, then on the number of defined fluents, and
            finally fluents are sorted and compared individually.
            </summary>
            <param name="other">The other fluents container to compare this fluents container to.</param>
            <returns>An integer representing the total order relation between the two fluents containers.
            </returns>
        </member>
        <member name="P:TLPlan.World.Implementations.QualifiedWorld.QualifiedHashSetFluentsContainer.SortedNumericFluents">
            <summary>
            The list of sorted numeric fluents/values, necessary only for 
            comparisons with other containers.
            </summary>
        </member>
        <member name="P:TLPlan.World.Implementations.QualifiedWorld.QualifiedHashSetFluentsContainer.SortedObjectFluents">
            <summary>
            The list of sorted object fluents/values, necessary only for
            comparisons with other containers.
            </summary>
        </member>
        <member name="T:TLPlan.Utils.SortedLinkedList`2">
            <summary>
            Represents a linked list sorted on its keys.
            </summary>
            <typeparam name="K">The type of the key. This must implement IComparable.</typeparam>
            <typeparam name="V">The type of the value. This must implement IComparable.</typeparam>
        </member>
        <member name="F:TLPlan.Utils.SortedLinkedList`2.m_sortedList">
            <summary>
            The linked list which is sorted on keys.
            </summary>
        </member>
        <member name="M:TLPlan.Utils.SortedLinkedList`2.#ctor">
            <summary>
            Creates an empty instance of the sorted linked list.
            </summary>
        </member>
        <member name="M:TLPlan.Utils.SortedLinkedList`2.#ctor(System.Collections.Generic.IEnumerable{System.Collections.Generic.KeyValuePair{`0,`1}})">
            <summary>
            Creates an instance of sorted linked list containing the given keys and values.
            </summary>
            <param name="ienum">The contents of the linked list.</param>
        </member>
        <member name="M:TLPlan.Utils.SortedLinkedList`2.InsertSorted(`0,`1)">
            <summary>
            Inserts an element in the linked list so that it remains sorted.
            </summary>
            <param name="key">The key at which to insert the value.</param>
            <param name="value">The value to insert.</param>
        </member>
        <member name="M:TLPlan.Utils.SortedLinkedList`2.GetFirstValues">
            <summary>
            Returns the first values in the sorted linked list. The first values are all the values
            at the beginning of the linked list that have the same key.
            </summary>
            <returns>The first values of the linked list.</returns>
        </member>
        <member name="M:TLPlan.Utils.SortedLinkedList`2.RemoveFirstValues">
            <summary>
            Removes and returns the first values in the sorted linked list. The first values are 
            all the values at the beginning of the linked list that have the same key.
            </summary>
            <returns>The first values of the linked list.</returns>
        </member>
        <member name="M:TLPlan.Utils.SortedLinkedList`2.GetFirstNodes">
            <summary>
            Returns the first nodes in the sorted linked list. The first nodes are 
            all the nodes at the beginning of the linked list that have the same key.
            </summary>
            <returns>The first nodes in the sorted linked list.</returns>
        </member>
        <member name="M:TLPlan.Utils.SortedLinkedList`2.GetHashCode">
            <summary>
            Returns the hash code of this sorted linked list.
            </summary>
            <returns>The hash code of this sorted linked list.</returns>
        </member>
        <member name="M:TLPlan.Utils.SortedLinkedList`2.Equals(System.Object)">
            <summary>
            Returns true if this sorted linked list is equal to a specified object.
            Two sorted linked list are equal if they contain the same key/value pairs.
            </summary>
            <param name="obj">Object to test for equality.</param>
            <returns>True if this sorted linked list is equal to the specified objet.</returns>
        </member>
        <member name="M:TLPlan.Utils.SortedLinkedList`2.CompareTo(TLPlan.Utils.SortedLinkedList{`0,`1})">
            <summary>
            Compares this sorted linked list with another sorted linked list.
            </summary>
            <param name="other">The other sorted linked list to compare this sorted linked list to.</param>
            <returns>An integer representing the total order relation between the two sorted linked list.</returns>
        </member>
        <member name="M:TLPlan.Utils.SortedLinkedList`2.GetEnumerator">
            <summary>
            Returns an enumerator over the key/value pairs stored this sorted linked list.
            </summary>
            <returns>An enumerator over the key/value pairs stored this sorted linked list.</returns>
        </member>
        <member name="M:TLPlan.Utils.SortedLinkedList`2.System#Collections#IEnumerable#GetEnumerator">
            <summary>
            Returns an enumerator over the key/value pairs stored this sorted linked list.
            </summary>
            <returns>An enumerator over the key/value pairs stored this sorted linked list.</returns>
        </member>
        <member name="P:TLPlan.Utils.SortedLinkedList`2.Count">
            <summary>
            Returns the number of elements in the linked list.
            </summary>
        </member>
        <member name="P:TLPlan.Utils.SortedLinkedList`2.Values">
            <summary>
            Returns an enumerable over the values of the linked list, sorted by keys.
            </summary>
        </member>
        <member name="P:TLPlan.Utils.SortedLinkedList`2.First">
            <summary>
            Returns the first element of the sorted linked list.
            </summary>
        </member>
        <member name="T:TLPlan.Planner">
            <summary>
            TLPlan planner class.
            </summary>
        </member>
        <member name="F:TLPlan.Planner.m_currentProblem">
            <summary>
            The current PDDL problem.
            </summary>
        </member>
        <member name="F:TLPlan.Planner.m_options">
            <summary>
            The current TLPlan options.
            </summary>
        </member>
        <member name="F:TLPlan.Planner.m_statistics">
            <summary>
            The current statistics.
            </summary>
        </member>
        <member name="F:TLPlan.Planner.m_errorStream">
            <summary>
            The error stream connected to the UI.
            </summary>
        </member>
        <member name="F:TLPlan.Planner.m_traceWriter">
            <summary>
            The stream to which traces are to be written.
            </summary>
        </member>
        <member name="F:TLPlan.Planner.m_graphSearch">
            <summary>
            The internal graph search implementation.
            </summary>
        </member>
        <member name="M:TLPlan.Planner.#ctor">
            <summary>
            Creates a new TLPlan planner with the default options.
            </summary>
        </member>
        <member name="M:TLPlan.Planner.#ctor(TLPlan.TLPlanOptions)">
            <summary>
            Creates a new TLPlan planner with the specified options.
            </summary>
            <param name="options">The TLPlan options.</param>
        </member>
        <member name="M:TLPlan.Planner.#ctor(TLPlan.TLPlanOptions,TLPlan.Statistics)">
            <summary>
            Creates a new TLPlan planner with the specified options and statistics.
            </summary>
            <param name="options">The TLPlan options.</param>
            <param name="statistics">The statistics computed up to this point 
            (mostly concerning parsing).</param>
        </member>
        <member name="M:TLPlan.Planner.#ctor(TLPlan.TLPlanOptions,TLPlan.Statistics,System.IO.TextWriter,System.IO.TextWriter)">
            <summary>
            Creates a new TLPlan planner with the specified options, statistics, and
            error stream.
            </summary>
            <param name="options">The TLPlan options.</param>
            <param name="statistics">The statistics computed up to this point 
            (mostly concerning parsing)</param>
            <param name="errorStream">The error stream connected to the UI.</param>
            <param name="traceStream">The stream to which traces are to be written.</param>
        </member>
        <member name="M:TLPlan.Planner.GetGraphSearchImplementation(TLPlan.TLPlanOptions.GraphSearchStrategy)">
            <summary>
            Returns the appropriate graph search implementation given the GraphSearchStrategy.
            </summary>
            <param name="strategy">The GraphSearchStrategy to use.</param>
            <returns>The appropriate graph search implementation.</returns>
        </member>
        <member name="M:TLPlan.Planner.Pause">
            <summary>
            Pauses the search.
            </summary>
            <returns>True if search was not already paused.</returns>
        </member>
        <member name="M:TLPlan.Planner.Unpause">
            <summary>
            Resumes the search.
            </summary>
            <returns>True if the search was paused.</returns>
        </member>
        <member name="M:TLPlan.Planner.Stop">
            <summary>
            Stops the search.
            </summary>
        </member>
        <member name="M:TLPlan.Planner.Reset">
            <summary>
            Resets the planning.
            </summary>
        </member>
        <member name="M:TLPlan.Planner.SetPDDLProblem(PDDLParser.Parser.PDDLObject)">
            <summary>
            Sets the PDDL problem that must be solved by the planner.
            </summary>
            <param name="problem">The problem to solve.</param>
        </member>
        <member name="M:TLPlan.Planner.Solve(PDDLParser.Parser.PDDLObject)">
            <summary>
            Attempts to solve the given PDDL problem.
            </summary>
            <param name="problem">The problem to solve.</param>
            <returns>A plan that solves the problem, or null if no plan was found.</returns>
        </member>
        <member name="M:TLPlan.Planner.Solve">
            <summary>
            Attempts to solve the current PDDL problem.
            </summary>
            <returns>A plan that solves the problem, or null if no plan was found.</returns>
        </member>
        <member name="M:TLPlan.Planner.PreprocessProblem(PDDLParser.Parser.PDDLObject)">
            <summary>
            Preprocesses the given PDDL problem.
            The preprocess phase consists of setting offsets for all formulas, and specifying
            whether some described formulas are considered invariant.
            </summary>
            <param name="pb">The PDDL problem to process.</param>
        </member>
        <member name="M:TLPlan.Planner.SetFormulasOffset``1(System.Collections.Generic.IEnumerable{``0})">
            <summary>
            Sets the offset of the specified formulas.
            </summary>
            <typeparam name="T">The type of the formulas.</typeparam>
            <param name="formulas">The formulas to preprocess.</param>
        </member>
        <member name="M:TLPlan.Planner.SetFormulasOffset``2(System.Collections.Generic.IEnumerable{``0},System.Comparison{``1})">
            <summary>
            Sets the offset of the specified formulas.
            The formulas are sorted according to the comparison function specified.
            </summary>
            <typeparam name="T">The type of the formulas.</typeparam>
            <typeparam name="U">The type of the comparison function operands.</typeparam>
            <param name="formulas">The formulas to preprocess.</param>
            <param name="comparisonFunction">The comparison function used to sort the formulas.</param>
        </member>
        <member name="M:TLPlan.Planner.Solve(TLPlan.World.TLPlanDurativeClosedWorld,System.Collections.Generic.List{TLPlan.IOperator},PDDLParser.Exp.ILogicalExp,PDDLParser.Exp.Metric.MetricExp)">
            <summary>
            Attempts to solve a given problem.
            </summary>
            <param name="initialWorld">The initial world.</param>
            <param name="operators">The list of operators to use.</param>
            <param name="goal">The goal formulation.</param>
            <param name="metric">The metric evaluation function.</param>
            <returns>A plan that solves the problem, or null if no plan was found.</returns>
        </member>
        <member name="M:TLPlan.Planner.GetInitialWorld">
            <summary>
            Returns the initial world of the current PDDL problem.
            </summary>
            <returns>The initial world of the current PDDL problem.</returns>
        </member>
        <member name="M:TLPlan.Planner.PreprocessFormula(PDDLParser.Exp.ILogicalExp,TLPlan.World.Implementations.InvariantWorld)">
            <summary>
            Preprocesses a given logical expression.
            If invariants should be used to preprocess logical formulas (as specified in options),
            then the given logical expression is simplified.
            Else the expression is returned as is.
            </summary>
            <param name="exp">The logical expression to simplify.</param>
            <param name="invariants">Invariants information.</param>
            <returns>True, false, undefined, or the simplified expression.</returns>
        </member>
        <member name="M:TLPlan.Planner.InstantiateOperators(System.Collections.Generic.IEnumerable{PDDLParser.Action.IActionDef},TLPlan.World.Implementations.InvariantWorld,System.Boolean)">
            <summary>
            Returns a list of all instantiated operators, given a list of actions.
            </summary>
            <param name="actions">All possible actions.</param>
            <param name="invariants">Invariant information.</param>
            <param name="containsDurativeActions">Whether there are durative actions in the list.</param>
            <returns>A list of instantiated operators.</returns>
        </member>
        <member name="M:TLPlan.Planner.InstantiateOperators(System.Collections.Generic.List{TLPlan.IOperator},PDDLParser.Action.IActionDef,PDDLParser.Exp.Formula.AtomicFormula,System.Int32,PDDLParser.Exp.LocalBindings,TLPlan.World.Implementations.InvariantWorld,System.Boolean)">
            <summary>
            Instantiate all possible operators by enumerating over all variables substitutions.
            </summary>
            <param name="ops">The list of operators to fetch.</param>
            <param name="action">The current action.</param>
            <param name="actionName">The name of the current action (represented as an atomic formula).
            </param>
            <param name="currentParam">The current parameter index.</param>
            <param name="bindings">The current set of bindings.</param>
            <param name="invariants">Invariants information.</param>
            <param name="containsDurativeActions">Whether the list of actions contains durative
            actions.</param>
        </member>
        <member name="M:TLPlan.Planner.AddNewOp(System.Collections.Generic.List{TLPlan.IOperator},PDDLParser.Action.IActionDef,PDDLParser.Exp.Formula.AtomicFormula,PDDLParser.Exp.LocalBindings,TLPlan.World.Implementations.InvariantWorld,System.Boolean)">
            <summary>
            Adds a new operator created from a specific action.
            </summary>
            <param name="ops">The list of operators to fetch.</param>
            <param name="action">The current action.</param>
            <param name="actionName">The name of the current action (represented as an atomic formula).
            </param>
            <param name="bindings">The current set of bindings.</param>
            <param name="invariants">Invariants information.</param>
            <param name="containsDurativeActions">Whether the list of actions contains durative
            actions.</param>
            <returns>Whether the new operator was added.</returns>
        </member>
        <member name="M:TLPlan.Planner.CreateOp(PDDLParser.Action.Action,System.String,PDDLParser.Exp.LocalBindings,TLPlan.World.Implementations.InvariantWorld,System.Boolean)">
            <summary>
            Creates a new operator given an action and a set of bindings.
            </summary>
            <param name="action">The action to create an operator from.</param>
            <param name="name">The name of the operator to create.</param>
            <param name="bindings">The set of action's variables bindings.</param>
            <param name="invariants">Invariants information.</param>
            <param name="containsDurativeActions">Whether the list of actions contains 
            durative actions.</param>
            <returns>The new operator, or null if it was not created.</returns>
        </member>
        <member name="M:TLPlan.Planner.CreateDurativeOp(PDDLParser.Action.DurativeAction,System.String,PDDLParser.Exp.LocalBindings,TLPlan.World.Implementations.InvariantWorld)">
            <summary>
            Creates a new operator given an action and a set of bindings.
            </summary>
            <param name="action">The action to create an operator from.</param>
            <param name="name">The name of the operator to create.</param>
            <param name="bindings">The set of action's variables bindings.</param>
            <param name="invariants">Invariants information.</param>
            <returns>The new operator, or null if it was not created.</returns>
        </member>
        <member name="E:TLPlan.Planner.Started">
            <summary>
            The Started event is fired when the search starts.
            It is forwarded to the graph search implementation.
            </summary>
        </member>
        <member name="E:TLPlan.Planner.Paused">
            <summary>
            The Paused event is fired when the search is paused.
            It is forwarded to the graph search implementation.
            </summary>
        </member>
        <member name="E:TLPlan.Planner.Unpaused">
            <summary>
            The Unpaused event is fired when the search is resumed.
            It is forwarded to the graph search implementation.
            </summary>
        </member>
        <member name="E:TLPlan.Planner.Stopped">
            <summary>
            The Stopped event is fired when the search is stopped.
            It is forwarded to the graph search implementation.
            </summary>
        </member>
        <member name="E:TLPlan.Planner.PlanningFinished">
            <summary>
            The PlanningFinished event is fired when the planning is finished.
            It is forwarded to the graph search implementation.
            </summary>
        </member>
        <member name="P:TLPlan.Planner.CurrentNode">
            <summary>
            The current node which is being explored by the graph search algorithm.
            </summary>
        </member>
        <member name="P:TLPlan.Planner.IsPaused">
            <summary>
            Whether the search is currently paused.
            </summary>
        </member>
        <member name="P:TLPlan.Planner.PauseOnGoalWorld">
            <summary>
            Whether the search should be paused when the goal world is found.
            </summary>
        </member>
        <member name="P:TLPlan.Planner.FailureReason">
            <summary>
            The reason why the planning failed.
            </summary>
        </member>
        <member name="P:TLPlan.Planner.ErrorStream">
            <summary>
            The error stream connected to the UI.
            </summary>
        </member>
        <member name="P:TLPlan.Planner.Options">
            <summary>
            The current TLPlan options.
            </summary>
        </member>
        <member name="P:TLPlan.Planner.Statistics">
            <summary>
            The current statistics.
            </summary>
        </member>
        <member name="T:TLPlan.Planner.PlanningFinishedEventArgs">
            <summary>
            Arguments of the PlanningFinished event.
            </summary>
        </member>
        <member name="M:TLPlan.Planner.PlanningFinishedEventArgs.#ctor(TLPlan.Plan)">
            <summary>
            Creates a new instance of PlanningFinishedEventArgs with the specified plan.
            </summary>
            <param name="plan">The plan found.</param>
        </member>
        <member name="M:TLPlan.Planner.PlanningFinishedEventArgs.#ctor">
            <summary>
            Creates a new instance of PlanningFinishedEventArgs without any plan.
            </summary>
        </member>
        <member name="P:TLPlan.Planner.PlanningFinishedEventArgs.Plan">
            <summary>
            The event indicates the plan found.
            It is null if the problem has not been solved.
            </summary>
        </member>
        <member name="P:TLPlan.Planner.PlanningFinishedEventArgs.ProblemSolved">
            <summary>
            The event indicates whether the problem was solved.
            </summary>
        </member>
        <member name="T:TLPlan.Utils.Set.AbstractSet`1">
            <summary>
            Base class for set implementation.
            </summary>
            <typeparam name="Value">The type of the elements.</typeparam>
        </member>
        <member name="T:TLPlan.Utils.Set.ISet`1">
            <summary>
            A set stores elements without duplicates.
            Contrary to a regular set, it allows one to retrieve the item present in the set
            from an equal item (using TryGetValue).
            </summary>
            <typeparam name="Value">The type of the elements.</typeparam>
        </member>
        <member name="M:TLPlan.Utils.Set.ISet`1.Add(`0)">
            <summary>
            Adds a new item in the set.
            </summary>
            <param name="item">The item to add to the set.</param>
            <remarks>This call should simply overwrite the existing item if an equal item exists.
            No exception should be thrown.</remarks>
        </member>
        <member name="M:TLPlan.Utils.Set.ISet`1.Remove(`0)">
            <summary>
            Removes an item from the set.
            </summary>
            <param name="item">The item to remove from the set.</param>
            <returns>Whether the item was present in the set.</returns>
        </member>
        <member name="M:TLPlan.Utils.Set.ISet`1.Contains(`0)">
            <summary>
            Determines whether the set contains the specified item.
            </summary>
            <param name="item">The object to locate in the set.</param>
            <returns>Whether the set contains the specified item.</returns>
        </member>
        <member name="M:TLPlan.Utils.Set.ISet`1.TryGetValue(`0,`0@)">
            <summary>
            Attempts to retrieve an item present in the set from an equivalent item.
            This function returns true if an existing item was found in the set.
            </summary>
            <param name="item">The item used as key.</param>
            <param name="oldItem">The item present in the set.</param>
            <returns>True if an existing item was found in the set.</returns>
        </member>
        <member name="P:TLPlan.Utils.Set.ISet`1.Count">
            <summary>
            Returns the number of elements in the set.
            </summary>
        </member>
        <member name="M:TLPlan.Utils.Set.AbstractSet`1.#ctor">
            <summary>
            Creates a new empty set
            </summary>
        </member>
        <member name="M:TLPlan.Utils.Set.AbstractSet`1.Add(`0)">
            <summary>
            Adds a new item in the set.
            </summary>
            <param name="item">The item to add to the set.</param>
        </member>
        <member name="M:TLPlan.Utils.Set.AbstractSet`1.Remove(`0)">
            <summary>
            Removes an item from the set.
            </summary>
            <param name="item">The item to remove from the set.</param>
            <returns>Whether the item was present in the set.</returns>
        </member>
        <member name="M:TLPlan.Utils.Set.AbstractSet`1.Contains(`0)">
            <summary>
            Determines whether the set contains the specified item.
            </summary>
            <param name="item">The object to locate in the set.</param>
            <returns>Whether the set contains the specified item.</returns>
        </member>
        <member name="M:TLPlan.Utils.Set.AbstractSet`1.TryGetValue(`0,`0@)">
            <summary>
            Attempts to retrieve an item present in the set from an equivalent item.
            This function returns true if an existing item was found in the set.
            </summary>
            <param name="item">The item used as key.</param>
            <param name="oldItem">The item present in the set.</param>
            <returns>True if an existing item was found in the set.</returns>
        </member>
        <member name="M:TLPlan.Utils.Set.AbstractSet`1.GetEnumerator">
            <summary>
            Returns an enumerator over all the elements contained in the set.
            </summary>
            <returns>An enumerator over all the elements contained in the set.</returns>
        </member>
        <member name="M:TLPlan.Utils.Set.AbstractSet`1.System#Collections#IEnumerable#GetEnumerator">
            <summary>
            Returns an enumerator over all the elements contained in the set.
            </summary>
            <returns>An enumerator over all the elements contained in the set.</returns>
        </member>
        <member name="P:TLPlan.Utils.Set.AbstractSet`1.Items">
            <summary>
            The internal set is implemented as a dictionary of values mapping to themselves.
            </summary>
        </member>
        <member name="P:TLPlan.Utils.Set.AbstractSet`1.Count">
            <summary>
            Returns the number of elements in the set.
            </summary>
        </member>
        <member name="T:TLPlan.Utils.MultiDictionary.MultiDictionary`2">
            <summary>
            Multi-dictionary implemented as a dictionary (hashtable).
            </summary>
            <typeparam name="Key">The key type.</typeparam>
            <typeparam name="Value">The value type.</typeparam>
        </member>
        <member name="F:TLPlan.Utils.MultiDictionary.MultiDictionary`2.m_items">
            <summary>
            Items are retrieved using the hashtable.
            </summary>
        </member>
        <member name="M:TLPlan.Utils.MultiDictionary.MultiDictionary`2.#ctor">
            <summary>
            Creates a new empty multi dictionary.
            </summary>
        </member>
        <member name="P:TLPlan.Utils.MultiDictionary.MultiDictionary`2.Items">
            <summary>
            Returns the all the items (sorted by key) present in the multi-dictionary.
            </summary>
        </member>
        <member name="T:TLPlan.Algorithms.BestFirstSearch">
            <summary>
            Best-first search explores the most promising worlds first, i.e. the nodes with the
            lowest f-cost.
            </summary>
        </member>
        <member name="F:TLPlan.Algorithms.BestFirstSearch.m_openSorted">
            <summary>
            The open set contains nodes yet to be explored.
            This structure is sorted by nodes' f-cost to allow efficient retrieval of the
            next node.
            </summary>
        </member>
        <member name="F:TLPlan.Algorithms.BestFirstSearch.m_open">
            <summary>
            This structure is used only if the CycleChecking option is on.
            It maps nodes to their location in <see cref="F:TLPlan.Algorithms.BestFirstSearch.m_openSorted"/>, hence
            allowing efficient detection of cycles.
            </summary>
        </member>
        <member name="F:TLPlan.Algorithms.BestFirstSearch.m_closed">
            <summary>
            This structure is used only if the CycleChecking option is on.
            The close set contains nodes which have already been explored.
            </summary>
        </member>
        <member name="F:TLPlan.Algorithms.BestFirstSearch.m_worseOpenNodeContainer">
            <summary>
            When not null, this container holds the last node found in open which is
            equal to the current node but has a worse g-cost.
            </summary>
        </member>
        <member name="F:TLPlan.Algorithms.BestFirstSearch.m_worseClosedNode">
            <summary>
            When not null, this container holds the last node found in closed which is
            equal to the current node but has a worse g-cost.
            </summary>
        </member>
        <member name="M:TLPlan.Algorithms.BestFirstSearch.#ctor(TLPlan.TLPlanOptions,TLPlan.Statistics,TLPlan.Utils.TraceWriter)">
            <summary>
            Creates a new best-first search algorithm with the specified options.
            </summary>
            <param name="options">Search options.</param>
            <param name="statistics">Statistics object to use.</param>
            <param name="traceWriter">The stream to which traces are to be written.</param>
        </member>
        <member name="M:TLPlan.Algorithms.BestFirstSearch.Initialize(TLPlan.Node)">
            <summary>
            Initializes the search with the initial node.
            </summary>
            <param name="initialNode">The initial node.</param>
        </member>
        <member name="M:TLPlan.Algorithms.BestFirstSearch.GetNextNode">
            <summary>
            Returns the next node to explore.
            Best-first search returns the open node with the lowest f-cost.
            </summary>
            <returns>The next node to explore.</returns>
        </member>
        <member name="M:TLPlan.Algorithms.BestFirstSearch.IsGoal(TLPlan.Node)">
            <summary>
            Returns whether the given node is a goal node.
            When a goal node satisfying the goal formulation is first discovered, its metric 
            evaluation is updated (if necessary) to reflect the violated goal preferences
            and the node is sent back to open set.
            The first explored idle goal node represents the best solution (assuming the
            metric function is monotone).
            </summary>
            <param name="node">The node to test.</param>
            <returns>Whether the given node is a goal node.</returns>
        </member>
        <member name="M:TLPlan.Algorithms.BestFirstSearch.CloseNode(TLPlan.Node)">
            <summary>
            Closes the given node.
            </summary>
            <param name="node">The node to close.</param>
        </member>
        <member name="M:TLPlan.Algorithms.BestFirstSearch.CausesCycle(TLPlan.Node)">
            <summary>
            This function returns whether the given node was already examined and thus
            represents a cycle in the search graph.
            </summary>
            <param name="node">The node to check for cycles.</param>
            <returns>Whether the given node has already been examined.</returns>
        </member>
        <member name="M:TLPlan.Algorithms.BestFirstSearch.AddSuccessor(TLPlan.Node)">
            <summary>
            Signals a new node to be explored eventually.
            If CycleChecking is off, the node is always added to open set.
            Else the node is added if:
            - no better (g-cost-wise) identical nodes were found in open set; and
            - no better (g-cost-wise) identical nodes were found in closed set.
            </summary>
            <param name="successor">The new node to be explored.</param>
            <returns>Whether to continue adding successors, which is always true.</returns>
        </member>
        <member name="M:TLPlan.Algorithms.BestFirstSearch.HasNextNode">
            <summary>
            Returns whether there is at least one node left in open set.
            </summary>
            <returns>Whether there is at least one node left in open set.</returns>
        </member>
        <member name="M:TLPlan.Algorithms.BestFirstSearch.GetOpenCount">
            <summary>
            Returns the number of nodes in the open set, i.e. nodes which should 
            eventually be explored.
            This function is used for computing statistics.
            </summary>
            <returns>The number of nodes in the open set.</returns>
        </member>
        <member name="M:TLPlan.Algorithms.BestFirstSearch.GetClosedCount">
            <summary>
            Returns the number of nodes in the closed set, i.e. nodes which have already
            been explored and whose successors have been generated.
            This function is used for computing statistics.
            </summary>
            <returns>The number of nodes in the closed set.</returns>
        </member>
        <member name="M:TLPlan.Algorithms.BestFirstSearch.ResetAlgorithm">
            <summary>
            Resets the search.
            All data structures should be reinitialized.
            </summary>
        </member>
        <member name="T:TLPlan.World.Implementations.TreeSetFactsContainer">
            <summary>
            A treeset facts container stores facts in a treeset.
            This implementation is O(log n) for retrieving predicates' value, but allows for
            a much faster comparison between two facts container, since treesets keep facts
            sorted.
            Note that as is, a treeset facts container cannot determine whether a predicate ID not
            contained in the treeset is actually "false" or "unknown", and hence always returns 
            unknown.
            </summary>
        </member>
        <member name="F:TLPlan.World.Implementations.TreeSetFactsContainer.m_facts">
            <summary>
            The treeset of facts IDs.
            </summary>
        </member>
        <member name="F:TLPlan.World.Implementations.TreeSetFactsContainer.m_hashCode">
            <summary>
            The hash code of this facts container.
            </summary>
        </member>
        <member name="M:TLPlan.World.Implementations.TreeSetFactsContainer.#ctor(TLPlan.Utils.IntegerInterval)">
            <summary>
            Creates a new empty treeset facts container.
            </summary>
            <param name="interval">The interval of predicates ID whose value are stored
            in this new hashset facts container.</param>
        </member>
        <member name="M:TLPlan.World.Implementations.TreeSetFactsContainer.Copy">
            <summary>
            Copies this facts container.
            </summary>
            <returns>A copy of this facts container.</returns>
        </member>
        <member name="M:TLPlan.World.Implementations.TreeSetFactsContainer.IsSet(System.Int32)">
            <summary>
            Checks whether the specified described atomic formula holds in this world.
            </summary>
            <param name="formulaID">A formula ID.</param>
            <returns>True, false, or unknown.</returns>
        </member>
        <member name="M:TLPlan.World.Implementations.TreeSetFactsContainer.Set(System.Int32)">
            <summary>
            Sets the specified atomic formula to true.
            </summary>
            <param name="formulaID">A formula ID.</param>
        </member>
        <member name="M:TLPlan.World.Implementations.TreeSetFactsContainer.Unset(System.Int32)">
            <summary>
            Sets the specified atomic formula to false.
            </summary>
            <param name="formulaID">A formula ID.</param>
        </member>
        <member name="M:TLPlan.World.Implementations.TreeSetFactsContainer.Equals(System.Object)">
            <summary>
            Returns whether this facts container is equal to another object.
            Two tree sets facts container are equal if they both store the same facts.
            </summary>
            <param name="obj">The other object to test for equality.</param>
            <returns>Whether this facts container is equal to the other object.</returns>
        </member>
        <member name="M:TLPlan.World.Implementations.TreeSetFactsContainer.GetHashCode">
            <summary>
            Returns the hash code of this facts container.
            </summary>
            <returns>The hash code of this facts container.</returns>
        </member>
        <member name="M:TLPlan.World.Implementations.TreeSetFactsContainer.CompareTo(TLPlan.World.Implementations.FactsContainer)">
            <summary>
            Compares this facts container with another facts container.
            Comparison is done first on the hash code, then on the number of facts, 
            and finally on the individual facts.
            </summary>
            <param name="other">The other facts container to compare this facts container to.</param>
            <returns>An integer representing the total order relation between the two facts containers.
            </returns>
        </member>
        <member name="T:TLPlan.Node">
            <summary>
            A node encapsulates a world by adding planning information.
            </summary>
        </member>
        <member name="F:TLPlan.Node.m_world">
            <summary>
            The world inside this node.
            </summary>
        </member>
        <member name="F:TLPlan.Node.m_operator">
            <summary>
            The operator which generated this world.
            </summary>
        </member>
        <member name="F:TLPlan.Node.m_predecessor">
            <summary>
            The predecessor of this node, used to memorize the trajectory.
            </summary>
        </member>
        <member name="F:TLPlan.Node.m_depth">
            <summary>
            The depth of the node in the search graph.
            </summary>
        </member>
        <member name="F:TLPlan.Node.m_gCost">
            <summary>
            The g-cost is the cumulative cost from the starting point.
            It is evaluated with the problem's metric.
            </summary>
        </member>
        <member name="F:TLPlan.Node.m_hCost">
            <summary>
            The h-cost is an estimation of the cost-to-go to the final world.
            </summary>
        </member>
        <member name="F:TLPlan.Node.m_isGoal">
            <summary>
            Whether this node is a goal node.
            Note that this variable does not imply m_world.IsIdleGoalNode()!
            </summary>
        </member>
        <member name="F:TLPlan.Node.m_worldHashCode">
            <summary>
            The cached hash code of this world.
            </summary>
        </member>
        <member name="M:TLPlan.Node.#ctor(TLPlan.World.TLPlanDurativeClosedWorld,TLPlan.Node,TLPlan.IOperator)">
            <summary>
            Creates a new node with the specified node, predecessor, and operator.
            </summary>
            <param name="world">The world to store in this node.</param>
            <param name="predecessor">The predecessor of this node.</param>
            <param name="op">The operator which generated this world.</param>
        </member>
        <member name="M:TLPlan.Node.Equals(System.Object)">
            <summary>
            Returns whether this node is equal to another object.
            </summary>
            <param name="obj">The other object to test for equality.</param>
            <returns>Whether this node is equal to the other object.</returns>
        </member>
        <member name="M:TLPlan.Node.GetHashCode">
            <summary>
            Returns the hash code of this node.
            </summary>
            <returns>The hash code of this node.</returns>
        </member>
        <member name="M:TLPlan.Node.ToString">
            <summary>
            Returns the string representation of this node.
            </summary>
            <returns>The string representation of this node.</returns>
        </member>
        <member name="M:TLPlan.Node.CompareTo(TLPlan.Node)">
            <summary>
            Compares this node with another node.
            </summary>
            <param name="other">The other node to compare this node to.</param>
            <returns>An integer representing the total order relation between the two nodes.
            </returns>
        </member>
        <member name="P:TLPlan.Node.World">
            <summary>
            The world inside this node.
            </summary>
        </member>
        <member name="P:TLPlan.Node.Operator">
            <summary>
            The operator which generated this world.
            </summary>
        </member>
        <member name="P:TLPlan.Node.Predecessor">
            <summary>
            The predecessor of this node, used to keep track of the trajectory.
            </summary>
        </member>
        <member name="P:TLPlan.Node.Depth">
            <summary>
            The depth of this node in the search graph.
            </summary>
        </member>
        <member name="P:TLPlan.Node.FCost">
            <summary>
            The f-cost is the sum of the g-cost and the h-cost.
            </summary>
        </member>
        <member name="P:TLPlan.Node.GCost">
            <summary>
            The g-cost is the cumulative cost from the starting point.
            It is evaluated with the problem's metric.
            </summary>
        </member>
        <member name="P:TLPlan.Node.HCost">
            <summary>
            The h-cost is an estimation of the cost-to-go to the final world.
            </summary>
        </member>
        <member name="P:TLPlan.Node.IsGoal">
            <summary>
            Whether this node is a goal node.
            Note that this does NOT imply its inner goal world has been idled.
            </summary>
        </member>
        <member name="T:TLPlan.World.Implementations.CustomWorld">
            <summary>
            A custom world is an updatable world with a custom facts container and a custom
            fluents container.
            As is, a custom world cannot evaluate formulas on its own: indeed, some facts container
            implementation like hashset return unknown when a certain predicate ID is not contained
            in their internal set of IDs, causing both actual unknown predicates and false predicates
            to be evaluated to unknown.
            </summary>
        </member>
        <member name="F:TLPlan.World.Implementations.CustomWorld.m_factsContainer">
            <summary>
            The facts container holds all facts.
            </summary>
        </member>
        <member name="F:TLPlan.World.Implementations.CustomWorld.m_fluentsContainer">
            <summary>
            The fluents container holds all numeric and object fluents.
            </summary>
        </member>
        <member name="M:TLPlan.World.Implementations.CustomWorld.#ctor(TLPlan.World.Implementations.FactsContainer,TLPlan.World.Implementations.FluentsContainer,TLPlan.TLPlanOptions)">
            <summary>
            Creates a new custom world with the specified facts and fluents containers.
            </summary>
            <param name="factsContainer">The facts container.</param>
            <param name="fluentsContainer">The fluents container.</param>
            <param name="options">The TLPlan options.</param>
        </member>
        <member name="M:TLPlan.World.Implementations.CustomWorld.Copy">
            <summary>
            Copies this custom world.
            </summary>
            <returns>A copy of this custom world.</returns>
        </member>
        <member name="M:TLPlan.World.Implementations.CustomWorld.IsSet(PDDLParser.Exp.Formula.AtomicFormulaApplication)">
            <summary>
            Checks whether the specified described atomic formula holds in this world.
            </summary>
            <param name="formula">A described (and ground) atomic formula.</param>
            <returns>True, false, or unknown.</returns>
        </member>
        <member name="M:TLPlan.World.Implementations.CustomWorld.InternalGetNumericFluent(PDDLParser.Exp.Formula.NumericFluentApplication)">
            <summary>
            Returns the value of the specified numeric fluent in this world.
            </summary>
            <param name="fluent">A described (and ground) numeric fluent.</param>
            <returns>Unknown, undefined, or the value of the numeric fluent.</returns>
        </member>
        <member name="M:TLPlan.World.Implementations.CustomWorld.InternalGetObjectFluent(PDDLParser.Exp.Formula.ObjectFluentApplication)">
            <summary>
            Returns the value of the specified object fluent in this world.
            </summary>
            <param name="fluent">A described (and ground) object fluent.</param>
            <returns>Unknown, undefined, or a constant representing the value of the 
            object fluent.</returns>
        </member>
        <member name="M:TLPlan.World.Implementations.CustomWorld.Set(PDDLParser.Exp.Formula.AtomicFormulaApplication)">
            <summary>
            Sets the specified atomic formula to true.
            </summary>
            <param name="formula">An atomic formula with constant arguments.</param>
        </member>
        <member name="M:TLPlan.World.Implementations.CustomWorld.Unset(PDDLParser.Exp.Formula.AtomicFormulaApplication)">
            <summary>
            Sets the specified atomic formula to false.
            </summary>
            <param name="formula">A atomic formula with constant arguments.</param>
        </member>
        <member name="M:TLPlan.World.Implementations.CustomWorld.SetNumericFluent(PDDLParser.Exp.Formula.NumericFluentApplication,System.Double)">
            <summary>
            Sets the new value of the specified numeric fluent.
            </summary>
            <param name="fluent">A numeric fluent with constant arguments.</param>
            <param name="value">The new value of the numeric fluent.</param>
        </member>
        <member name="M:TLPlan.World.Implementations.CustomWorld.SetObjectFluent(PDDLParser.Exp.Formula.ObjectFluentApplication,PDDLParser.Exp.Term.Constant)">
            <summary>
            Sets the new value of the specified object fluent.
            </summary>
            <param name="fluent">A object fluent with constant arguments.</param>
            <param name="value">The constant representing the new value of the object fluent.
            </param>
        </member>
        <member name="M:TLPlan.World.Implementations.CustomWorld.UndefineObjectFluent(PDDLParser.Exp.Formula.ObjectFluentApplication)">
            <summary>
            Sets the specified object fluent to undefined.
            </summary>
            <param name="fluent">A object fluent with constant arguments.</param>
        </member>
        <member name="M:TLPlan.World.Implementations.CustomWorld.Equals(System.Object)">
            <summary>
            Returns whether this world is equal to another object.
            </summary>
            <param name="obj">The other object to test for equality.</param>
            <returns>Whether this world is equal to the other object.</returns>
        </member>
        <member name="M:TLPlan.World.Implementations.CustomWorld.GetHashCode">
            <summary>
            Returns the hash code of this world.
            </summary>
            <returns>The hash code of this world.</returns>
        </member>
        <member name="M:TLPlan.World.Implementations.CustomWorld.CompareTo(TLPlan.World.ExtendedOpenWorld)">
            <summary>
            Compares this custom world with another extended world.
            </summary>
            <param name="other">The other extended world to compare this custom world to.</param>
            <returns>An integer representation the total order relation between the two worlds.
            </returns>
        </member>
        <member name="T:TLPlan.Algorithms.BreadthFirstSearch">
            <summary>
            Breadth-first search explores neighboring nodes incrementally, i.e. all 1-neighbors, 
            then all 2-neighbors, ... and so on until the goal is reached.
            Hence it uses open set as a FIFO list (successors are always explored last).
            </summary>
        </member>
        <member name="M:TLPlan.Algorithms.BreadthFirstSearch.#ctor(TLPlan.TLPlanOptions,TLPlan.Statistics,TLPlan.Utils.TraceWriter)">
            <summary>
            Creates a new breadth-first search algorithm with the specified options.
            </summary>
            <param name="options">Search options.</param>
            <param name="statistics">Statistics object to use.</param>
            <param name="traceWriter">The stream to which traces are to be written.</param>
        </member>
        <member name="M:TLPlan.Algorithms.BreadthFirstSearch.AddSuccessorToOpenSet(TLPlan.Node)">
            <summary>
            Adds the given successor to the open set.
            </summary>
            <param name="successor">The successor to add to open set.</param>
        </member>
        <member name="T:TLPlan.World.Implementations.PartialCycleCheckWorld">
            <summary>
            A partial-cycle-check world does not take into account the described formulas with
            the attribute "DetectCycles" set to false when comparing itself with another world.
            To achieve this, it stores cycle-check attributes and no-cycle-check attributes in two
            different worlds and simplify forward query/updates to the appropriate world.
            </summary>
        </member>
        <member name="F:TLPlan.World.Implementations.PartialCycleCheckWorld.m_cycleCheckWorld">
            <summary>
            The world responsible for storing the cycle-check formulas.
            </summary>
        </member>
        <member name="F:TLPlan.World.Implementations.PartialCycleCheckWorld.m_noCycleCheckWorld">
            <summary>
            The world responsible for storing the no-cycle-check formulas.
            </summary>
        </member>
        <member name="M:TLPlan.World.Implementations.PartialCycleCheckWorld.#ctor(TLPlan.World.ExtendedOpenWorld,TLPlan.World.ExtendedOpenWorld,TLPlan.TLPlanOptions)">
            <summary>
            Creates a new partial-cycle-check worlds with the specified cycle-check world and
            no-cycle-check world.
            </summary>
            <param name="cycleCheckWorld">The cycle-check world.</param>
            <param name="noCycleCheckWorld">The no-cycle-check world.</param>
            <param name="options">A set of TLPlan options.</param>
        </member>
        <member name="M:TLPlan.World.Implementations.PartialCycleCheckWorld.Copy">
            <summary>
            Copies this partial-cycle-check world.
            </summary>
            <returns>A copy of this partial-cycle-check  world.</returns>
        </member>
        <member name="M:TLPlan.World.Implementations.PartialCycleCheckWorld.IsSet(PDDLParser.Exp.Formula.AtomicFormulaApplication)">
            <summary>
            Checks whether the specified described atomic formula holds in this world.
            </summary>
            <param name="formula">A described (and ground) atomic formula.</param>
            <returns>True, false, or unknown.</returns>
        </member>
        <member name="M:TLPlan.World.Implementations.PartialCycleCheckWorld.InternalGetNumericFluent(PDDLParser.Exp.Formula.NumericFluentApplication)">
            <summary>
            Returns the value of the specified numeric fluent in this world.
            </summary>
            <param name="fluent">A described (and ground) numeric fluent.</param>
            <returns>Unknown, undefined, or the value of the numeric fluent.</returns>
        </member>
        <member name="M:TLPlan.World.Implementations.PartialCycleCheckWorld.InternalGetObjectFluent(PDDLParser.Exp.Formula.ObjectFluentApplication)">
            <summary>
            Returns the value of the specified object fluent in this world.
            </summary>
            <param name="fluent">A described (and ground) object fluent.</param>
            <returns>Unknown, undefined, or a constant representing the value of the 
            object fluent.</returns>
        </member>
        <member name="M:TLPlan.World.Implementations.PartialCycleCheckWorld.Set(PDDLParser.Exp.Formula.AtomicFormulaApplication)">
            <summary>
            Sets the specified atomic formula to true.
            </summary>
            <param name="formula">An atomic formula with constant arguments.</param>
        </member>
        <member name="M:TLPlan.World.Implementations.PartialCycleCheckWorld.Unset(PDDLParser.Exp.Formula.AtomicFormulaApplication)">
            <summary>
            Sets the specified atomic formula to false.
            </summary>
            <param name="formula">A atomic formula with constant arguments.</param>
        </member>
        <member name="M:TLPlan.World.Implementations.PartialCycleCheckWorld.SetNumericFluent(PDDLParser.Exp.Formula.NumericFluentApplication,System.Double)">
            <summary>
            Sets the new value of the specified numeric fluent.
            </summary>
            <param name="fluent">A numeric fluent with constant arguments.</param>
            <param name="value">The new value of the numeric fluent.</param>
        </member>
        <member name="M:TLPlan.World.Implementations.PartialCycleCheckWorld.SetObjectFluent(PDDLParser.Exp.Formula.ObjectFluentApplication,PDDLParser.Exp.Term.Constant)">
            <summary>
            Sets the new value of the specified object fluent.
            </summary>
            <param name="fluent">A object fluent with constant arguments.</param>
            <param name="value">The constant representing the new value of the object fluent.
            </param>
        </member>
        <member name="M:TLPlan.World.Implementations.PartialCycleCheckWorld.UndefineObjectFluent(PDDLParser.Exp.Formula.ObjectFluentApplication)">
            <summary>
            Sets the specified object fluent to undefined.
            </summary>
            <param name="fluent">A object fluent with constant arguments.</param>
        </member>
        <member name="M:TLPlan.World.Implementations.PartialCycleCheckWorld.Equals(System.Object)">
            <summary>
            Returns whether this world is equal to another object.
            </summary>
            <param name="obj">The other object to test for equality.</param>
            <returns>Whether this world is equal to the other object.</returns>
        </member>
        <member name="M:TLPlan.World.Implementations.PartialCycleCheckWorld.GetHashCode">
            <summary>
            Returns the hash code of this world.
            </summary>
            <returns>The hash code of this world.</returns>
        </member>
        <member name="M:TLPlan.World.Implementations.PartialCycleCheckWorld.CompareTo(TLPlan.World.ExtendedOpenWorld)">
            <summary>
            Compares this world with another world.
            </summary>
            <param name="other">The other world to compare this world to.</param>
            <returns>An integer representing the total order relation between the two worlds.
            </returns>
        </member>
        <member name="T:TLPlan.Utils.Set.SortedSet`1">
            <summary>
            Sorted set implemented a sorted dictionary (red-black tree?)
            </summary>
            <typeparam name="Value">The type of the elements.</typeparam>
        </member>
        <member name="F:TLPlan.Utils.Set.SortedSet`1.m_items">
            <summary>
            Internal set implemented as a sorted dictionary.
            </summary>
        </member>
        <member name="M:TLPlan.Utils.Set.SortedSet`1.#ctor">
            <summary>
            Creates a new sorted empty set.
            </summary>
        </member>
        <member name="M:TLPlan.Utils.Set.SortedSet`1.#ctor(TLPlan.Utils.Set.SortedSet{`0})">
            <summary>
            Creates a new sorted set from an existing set.
            </summary>
            <param name="other">The other set to retrieve the elements from.</param>
        </member>
        <member name="P:TLPlan.Utils.Set.SortedSet`1.Items">
            <summary>
            The internal set is implemented as a dictionary of values mapping to themselves.
            </summary>
        </member>
        <member name="T:TLPlan.World.Implementations.HashMapFluentsContainer">
            <summary>
            A hashmap fluents container holds fluents IDs in a hashtable (dictionary).
            This implementation is fast for retrieving fluents' value, but comparison
            between two hashset fluents container is slow because their respective
            elements must be sorted beforehand.
            Note that as is, a hashset fluents container cannot determine whether a fluent ID not
            contained in the hashset is actually "undefined" or "unknown", and hence always returns 
            unknown.
            </summary>
        </member>
        <member name="F:TLPlan.World.Implementations.HashMapFluentsContainer.m_numericFluents">
            <summary>
            The dictionary of numeric fluents IDs.
            </summary>
        </member>
        <member name="F:TLPlan.World.Implementations.HashMapFluentsContainer.m_sortedNumericFluents">
            <summary>
            The cached list of sorted numeric fluents IDs/values, necessary only for 
            comparisons with other containers.
            </summary>
        </member>
        <member name="F:TLPlan.World.Implementations.HashMapFluentsContainer.m_objectFluents">
            <summary>
            The dictionary of object fluents IDs.
            </summary>
        </member>
        <member name="F:TLPlan.World.Implementations.HashMapFluentsContainer.m_sortedObjectFluents">
            <summary>
            The cached list of sorted object fluents IDs/values, necessary only for
            comparisons with other containers.
            </summary>
        </member>
        <member name="F:TLPlan.World.Implementations.HashMapFluentsContainer.m_hashCode">
            <summary>
            The hash code of this fluents container.
            </summary>
        </member>
        <member name="M:TLPlan.World.Implementations.HashMapFluentsContainer.#ctor(TLPlan.Utils.IntegerInterval,TLPlan.Utils.IntegerInterval)">
            <summary>
            Creates a new empty hashset fluents container.
            </summary>
            <param name="numericInterval">The interval of numeric fluents ID whose value are stored 
            in this new fluents container.</param>
            <param name="objectInterval">The interval of object fluents ID whose value are stored 
            in this new fluents container.</param>
        </member>
        <member name="M:TLPlan.World.Implementations.HashMapFluentsContainer.Copy">
            <summary>
            Copies this fluent container.
            </summary>
            <returns>A copy of this fluent container.</returns>
        </member>
        <member name="M:TLPlan.World.Implementations.HashMapFluentsContainer.GetNumericFluent(System.Int32)">
            <summary>
            Returns the value of the specified numeric fluent in this world.
            </summary>
            <param name="fluentID">A numeric fluent ID.</param>
            <returns>Unknown, undefined, or the value of the numeric fluent.</returns>
        </member>
        <member name="M:TLPlan.World.Implementations.HashMapFluentsContainer.GetObjectFluent(System.Int32)">
            <summary>
            Returns the value of the specified object fluent in this world.
            </summary>
            <param name="fluentID">An object fluent ID.</param>
            <returns>Unknown, undefined, or a constant representing the value of the 
            object fluent.</returns>
        </member>
        <member name="M:TLPlan.World.Implementations.HashMapFluentsContainer.SetNumericFluent(System.Int32,System.Double)">
            <summary>
            Sets the new value of the specified numeric fluent.
            </summary>
            <param name="fluentID">A numeric fluent ID.</param>
            <param name="value">The new value of the numeric fluent.</param>
        </member>
        <member name="M:TLPlan.World.Implementations.HashMapFluentsContainer.SetObjectFluent(System.Int32,PDDLParser.Exp.Term.Constant)">
            <summary>
            Sets the new value of the specified object fluent.
            </summary>
            <param name="fluentID">An object fluent ID.</param>
            <param name="value">The constant representing the new value of the object fluent.
            </param>
        </member>
        <member name="M:TLPlan.World.Implementations.HashMapFluentsContainer.UndefineObjectFluent(System.Int32)">
            <summary>
            Sets the specified object fluent to undefined.
            </summary>
            <param name="fluentID">An object fluent ID.</param>
        </member>
        <member name="M:TLPlan.World.Implementations.HashMapFluentsContainer.Equals(System.Object)">
            <summary>
            Returns whether this fluents container is equal to another fluents container.
            Two hashset fluent containers are equal if all their respective fluents have the
            same value pairwise.
            </summary>
            <param name="obj">The other object to test for equality.</param>
            <returns>Whether this fluents container is equal to the other object.</returns>
        </member>
        <member name="M:TLPlan.World.Implementations.HashMapFluentsContainer.GetHashCode">
            <summary>
            Returns the hash code of this fluents container.
            </summary>
            <returns>The hash code of this fluents container.</returns>
        </member>
        <member name="M:TLPlan.World.Implementations.HashMapFluentsContainer.CompareTo(TLPlan.World.Implementations.FluentsContainer)">
            <summary>
            Compares this fluents container with another fluents container.
            Comparison is done first on the hash code, then on the number of defined fluents, and
            finally fluents are sorted and compared individually.
            </summary>
            <param name="other">The other fluents container to compare this fluents container to.</param>
            <returns>An integer representing the total order relation between the two fluents containers.
            </returns>
        </member>
        <member name="P:TLPlan.World.Implementations.HashMapFluentsContainer.SortedNumericFluents">
            <summary>
            The list of sorted numeric fluents IDs/values, necessary only for 
            comparisons with other containers.
            </summary>
        </member>
        <member name="P:TLPlan.World.Implementations.HashMapFluentsContainer.SortedObjectFluents">
            <summary>
            The list of sorted object fluents IDs/values, necessary only for
            comparisons with other containers.
            </summary>
        </member>
        <member name="T:TLPlan.World.Implementations.HashSetFactsContainer">
            <summary>
            A hashset facts container holds facts IDs in a hashset.
            This implementation is fast for retrieving predicates' value, but comparison
            between two hashset facts container is slow because their respective
            elements must be sorted beforehand.
            Note that as is, a hashset facts container cannot determine whether a predicate ID not
            contained in the hashset is actually "false" or "unknown", and hence always returns 
            unknown.
            </summary>
        </member>
        <member name="F:TLPlan.World.Implementations.HashSetFactsContainer.m_facts">
            <summary>
            The hashset of facts IDs.
            </summary>
        </member>
        <member name="F:TLPlan.World.Implementations.HashSetFactsContainer.m_sortedFacts">
            <summary>
            The cached list of sorted facts IDs, necessary only for comparisons 
            with other containers.
            </summary>
        </member>
        <member name="F:TLPlan.World.Implementations.HashSetFactsContainer.m_hashCode">
            <summary>
            The hash code of this facts container.
            </summary>
        </member>
        <member name="M:TLPlan.World.Implementations.HashSetFactsContainer.#ctor(TLPlan.Utils.IntegerInterval)">
            <summary>
            Creates a new empty hashset facts container.
            </summary>
            <param name="interval">The interval of predicates ID whose value are stored
            in this new hashset facts container.</param>
        </member>
        <member name="M:TLPlan.World.Implementations.HashSetFactsContainer.Copy">
            <summary>
            Copies this facts container.
            </summary>
            <returns>A copy of this facts container.</returns>
        </member>
        <member name="M:TLPlan.World.Implementations.HashSetFactsContainer.IsSet(System.Int32)">
            <summary>
            Checks whether the specified described atomic formula holds in this world.
            </summary>
            <param name="formulaID">A formula ID.</param>
            <returns>True, or unknown.</returns>
        </member>
        <member name="M:TLPlan.World.Implementations.HashSetFactsContainer.Set(System.Int32)">
            <summary>
            Sets the specified atomic formula to true.
            </summary>
            <param name="formulaID">A formula ID.</param>
        </member>
        <member name="M:TLPlan.World.Implementations.HashSetFactsContainer.Unset(System.Int32)">
            <summary>
            Sets the specified atomic formula to false.
            </summary>
            <param name="formulaID">A formula ID.</param>
        </member>
        <member name="M:TLPlan.World.Implementations.HashSetFactsContainer.Equals(System.Object)">
            <summary>
            Returns whether this facts container is equal to another object.
            Two hashset facts container are equal if they both store the same facts.
            </summary>
            <param name="obj">The other object to test for equality.</param>
            <returns>Whether this facts container is equal to the other object.</returns>
        </member>
        <member name="M:TLPlan.World.Implementations.HashSetFactsContainer.GetHashCode">
            <summary>
            Returns the hash code of this facts container.
            </summary>
            <returns>The hash code of this facts container.</returns>
        </member>
        <member name="M:TLPlan.World.Implementations.HashSetFactsContainer.CompareTo(TLPlan.World.Implementations.FactsContainer)">
            <summary>
            Compares this facts container with another facts container.
            Comparison is done first on the hash code, then on the number of facts, 
            and finally facts are sorted and compared individually.
            </summary>
            <param name="other">The other facts container to compare this facts container to.</param>
            <returns>An integer representing the total order relation between the two facts containers.
            </returns>
        </member>
        <member name="P:TLPlan.World.Implementations.HashSetFactsContainer.SortedFacts">
            <summary>
            The list of sorted facts IDs, necessary only for comparisons with other containers.
            </summary>
        </member>
        <member name="T:TLPlan.Utils.Container`1">
            <summary>
            A container stores an object.
            This class (which looks useless at first sight) actually provides an additional 
            level of indirection when passing objects around.
            </summary>
            <typeparam name="T">The type of the object to store.</typeparam>
        </member>
        <member name="M:TLPlan.Utils.Container`1.#ctor(`0)">
            <summary>
            Creates a new container for the specified object.
            </summary>
            <param name="value">The type of the object to store.</param>
        </member>
        <member name="M:TLPlan.Utils.Container`1.Equals(System.Object)">
            <summary>
            Verifies whether this container is equal to another object.
            </summary>
            <param name="obj">The other object to test for equality.</param>
            <returns>Whether the two container are equal.</returns>
        </member>
        <member name="M:TLPlan.Utils.Container`1.GetHashCode">
            <summary>
            Returns the hash code of this container.
            </summary>
            <returns>The hash code of this container.</returns>
        </member>
        <member name="M:TLPlan.Utils.Container`1.ToString">
            <summary>
            Returns a string representation of this container.
            </summary>
            <returns>A string representation of this container.</returns>
        </member>
        <member name="P:TLPlan.Utils.Container`1.Value">
            <summary>
            The stored object.
            </summary>
        </member>
        <member name="T:TLPlan.World.WorldUtils">
            <summary>
            Represents a set of utility functions for worlds.
            </summary>
        </member>
        <member name="M:TLPlan.World.WorldUtils.PrintWorld(PDDLParser.Parser.PDDLObject,TLPlan.Node,TLPlan.World.WorldUtils.PrintWorldPart)">
            <summary>
            Prints the given parts of the specified world on the <see cref="P:System.Console.Out"/> console output.
            </summary>
            <param name="problem">The PDDL problem.</param>
            <param name="node">The node containing the world to print.</param>
            <param name="printParts">The parts of the world to print.</param>
        </member>
        <member name="M:TLPlan.World.WorldUtils.PrintWorld(PDDLParser.Parser.PDDLObject,TLPlan.Node,TLPlan.World.WorldUtils.PrintWorldPart,System.Boolean,System.Boolean)">
            <summary>
            Prints the given parts of the specified world on the specified output stream, using different options.
            </summary>
            <param name="problem">The PDDL problem.</param>
            <param name="node">The node containing the world to print.</param>
            <param name="printParts">The parts of the world to print.</param>
            <param name="printAllPredicates">Whether to print all predicates, or only true facts and defined fluents.</param>
            <param name="alignLines">Whether to align the prints facts and fluents on new lines.</param>
        </member>
        <member name="M:TLPlan.World.WorldUtils.PrintWorld(PDDLParser.Parser.PDDLObject,TLPlan.Node,TLPlan.World.WorldUtils.PrintWorldPart,System.Boolean,System.Boolean,System.IO.TextWriter,System.IO.TextWriter)">
            <summary>
            Prints the given parts of the specified world on the specified output stream, using different options.
            </summary>
            <param name="problem">The PDDL problem.</param>
            <param name="node">The node containing the world to print.</param>
            <param name="printParts">The parts of the world to print.</param>
            <param name="printAllPredicates">Whether to print all predicates, or only true facts and defined fluents.</param>
            <param name="alignLines">Whether to align the prints facts and fluents on new lines.</param>
            <param name="titleWriter">The title text writer.</param>
            <param name="infoWriter">The main text writer.</param>
        </member>
        <member name="M:TLPlan.World.WorldUtils.AlignLines(System.Collections.Generic.IEnumerable{System.String},System.Int32)">
            <summary>
            Pads the given strings with spaces so that they align nicely when printed. The first string is not padded.
            </summary>
            <param name="strings">The strings to pad with spaces.</param>
            <param name="startOffset">The number of spaces to add at the beginning of the strings.</param>
            <returns>An enumeration containing the padded strings.</returns>
        </member>
        <member name="M:TLPlan.World.WorldUtils.PrintFormulas``3(System.Collections.Generic.List{``0},TLPlan.World.TLPlanReadOnlyDurativeClosedWorld,System.String,TLPlan.World.WorldUtils.ResultGetter{``2,``1},System.Predicate{``2},System.String,System.Boolean,System.IO.TextWriter,System.IO.TextWriter)">
            <summary>
            Prints the given formulas, along with their values, to the specified output streams.
            </summary>
            <typeparam name="FormulaType">The specific subtype of <see cref="T:PDDLParser.Exp.Formula.DescribedFormula"/> that is used.</typeparam>
            <typeparam name="ApplicationType">The specfied subtype of <see cref="T:PDDLParser.Exp.Formula.FormulaApplication"/> that is used.</typeparam>
            <typeparam name="ResultType">The type of the values returned by the getter.</typeparam>
            <param name="formulas">The list of formulas that need to be printed.</param>
            <param name="world">The world to query for the formulas' values.</param>
            <param name="category">The string mentioning the type of formulas being printed.</param>
            <param name="getter">The function used to retrieve the formulas' values in the world.</param>
            <param name="hider">The predicate used to determine whether to print the formula or not. If the call to the hider returns true, the formula is not printed.</param>
            <param name="printFormat">The format string used for printing.</param>
            <param name="alignLines">Whether to align the output so that it prints nicely on multiple lines.</param>
            <param name="categoryWriter">The writer used to write the <paramref name="category"/> string.</param>
            <param name="infoWriter">The writer used to print the formulas and their values.</param>
        </member>
        <member name="T:TLPlan.World.WorldUtils.PrintWorldPart">
            <summary>
            A flag enumeration indicating which parts of the world should be printed.
            </summary>
        </member>
        <member name="F:TLPlan.World.WorldUtils.PrintWorldPart.None">
            <summary>
            No part of the world will be printed.
            </summary>
        </member>
        <member name="F:TLPlan.World.WorldUtils.PrintWorldPart.LastOperator">
            <summary>
            The last operator leading to the world will be printed.
            </summary>
        </member>
        <member name="F:TLPlan.World.WorldUtils.PrintWorldPart.ElapsedTime">
            <summary>
            The elapsed time up to the world will be printed.
            </summary>
        </member>
        <member name="F:TLPlan.World.WorldUtils.PrintWorldPart.RemainingEvents">
            <summary>
            The remaining events in the world will be printed.
            </summary>
        </member>
        <member name="F:TLPlan.World.WorldUtils.PrintWorldPart.Facts">
            <summary>
            The variant facts of the world will be printed.
            </summary>
        </member>
        <member name="F:TLPlan.World.WorldUtils.PrintWorldPart.InvariantFacts">
            <summary>
            The invariant facts of the world will be printed.
            </summary>
        </member>
        <member name="F:TLPlan.World.WorldUtils.PrintWorldPart.NumericFluents">
            <summary>
            The variant numeric fluents of the world will be printed.
            </summary>
        </member>
        <member name="F:TLPlan.World.WorldUtils.PrintWorldPart.InvariantNumericFluents">
            <summary>
            The invariant numeric fluents of the world will be printed.
            </summary>
        </member>
        <member name="F:TLPlan.World.WorldUtils.PrintWorldPart.ObjectFluents">
            <summary>
            The variant object fluents of the world will be printed.
            </summary>
        </member>
        <member name="F:TLPlan.World.WorldUtils.PrintWorldPart.InvariantObjectFluents">
            <summary>
            The invariant object fluents of the world will be printed.
            </summary>
        </member>
        <member name="F:TLPlan.World.WorldUtils.PrintWorldPart.CurrentConstraints">
            <summary>
            The current constraints of the world will be printed.
            </summary>
        </member>
        <member name="F:TLPlan.World.WorldUtils.PrintWorldPart.NextConstraints">
            <summary>
            The next constraints of the world will be printed.
            </summary>
        </member>
        <member name="F:TLPlan.World.WorldUtils.PrintWorldPart.ConstraintPreferences">
            <summary>
            The constraint preferences of the world will be printed.
            </summary>
        </member>
        <member name="F:TLPlan.World.WorldUtils.PrintWorldPart.AllFacts">
            <summary>
            All facts of the world will be printed.
            </summary>
        </member>
        <member name="F:TLPlan.World.WorldUtils.PrintWorldPart.AllNumericFluents">
            <summary>
            All numeric fluents of the world will be printed.
            </summary>
        </member>
        <member name="F:TLPlan.World.WorldUtils.PrintWorldPart.AllObjectFluents">
            <summary>
            All object fluents of the world will be printed.
            </summary>
        </member>
        <member name="F:TLPlan.World.WorldUtils.PrintWorldPart.AllFluents">
            <summary>
            All fluents of the world will be printed.
            </summary>
        </member>
        <member name="F:TLPlan.World.WorldUtils.PrintWorldPart.AllFactsAndFluents">
            <summary>
            All facts and fluents of the world will be printed.
            </summary>
        </member>
        <member name="F:TLPlan.World.WorldUtils.PrintWorldPart.All">
            <summary>
            Every information about the world will be printed.
            </summary>
        </member>
        <member name="T:TLPlan.World.WorldUtils.ResultGetter`2">
            <summary>
            A delegate to retrieve the value of a given <see cref="T:PDDLParser.Exp.Formula.FormulaApplication"/>.
            </summary>
            <typeparam name="ResultType">The type of the value.</typeparam>
            <typeparam name="ApplicationType">The specific type of <see cref="T:PDDLParser.Exp.Formula.FormulaApplication"/>.</typeparam>
            <param name="world">The world is in which the values are retrieved.</param>
            <param name="appl">The formula application whose value is to be known.</param>
            <returns>The value of the <see cref="T:PDDLParser.Exp.Formula.FormulaApplication"/> in the given world.</returns>
        </member>
        <member name="T:TLPlan.World.IInvariantWorld">
            <summary>
            An invariant world is a read-only open world containing information about invariants
            facts and fluents. It knows nothing except the value of these invariant formulas, which
            can be represented as intervals (of formulas ID).
            Hence when an invariant world is queried for the value of an invariant formula
            (one whose ID belongs to the interval), it cannot return unknown.
            </summary>
        </member>
        <member name="P:TLPlan.World.IInvariantWorld.InvariantPredicateInterval">
            <summary>
            The interval of invariant predicates IDs whose value are known.
            </summary>
        </member>
        <member name="P:TLPlan.World.IInvariantWorld.InvariantNumericFluentInterval">
            <summary>
            The interval of invariant numeric fluent IDs whose value are known.
            </summary>
        </member>
        <member name="P:TLPlan.World.IInvariantWorld.InvariantObjectFluentInterval">
            <summary>
            The interval of invariant object fluent IDs whose value are known.
            </summary>
        </member>
        <member name="T:TLPlan.Utils.Set.Set`1">
            <summary>
            Set implemented as a dictionary (hash-table).
            </summary>
            <typeparam name="Value">The type of the elements.</typeparam>
        </member>
        <member name="F:TLPlan.Utils.Set.Set`1.m_items">
            <summary>
            Internal set implemented as a dictionary (hash-table).
            </summary>
        </member>
        <member name="M:TLPlan.Utils.Set.Set`1.#ctor">
            <summary>
            Creates a new empty set.
            </summary>
        </member>
        <member name="M:TLPlan.Utils.Set.Set`1.#ctor(TLPlan.Utils.Set.Set{`0})">
            <summary>
            Creates a new set from an existing set.
            </summary>
            <param name="other">The other set to retrieve the elements from.</param>
        </member>
        <member name="P:TLPlan.Utils.Set.Set`1.Items">
            <summary>
            The internal set is implemented as a dictionary of values mapping to themselves.
            </summary>
        </member>
        <member name="T:TLPlan.World.Implementations.InvariantWorld">
            <summary>
            An invariant world is read-only world that holds facts and fluents values.
            As specified in <see cref="T:TLPlan.World.IInvariantWorld"/>, an invariant world cannot return unknown
            when queried for the value of an invariant formula.
            It holds its facts and fluents in a fixed-size structure (respectively bitset and array) 
            to allow constant-time retrieval. Although it is true that these structures are more expensive
            memory-wise than other possible implementations (hashset, treeset...), this isn't an issue
            since the invariant world is initialized only once.
            </summary>
        </member>
        <member name="F:TLPlan.World.Implementations.InvariantWorld.m_factsContainer">
            <summary>
            The facts container holds all facts.
            </summary>
        </member>
        <member name="F:TLPlan.World.Implementations.InvariantWorld.m_fluentsContainer">
            <summary>
            The fluents container holds all numeric and object fluents.
            </summary>
        </member>
        <member name="F:TLPlan.World.Implementations.InvariantWorld.m_options">
            <summary>
            The TLPlan options.
            </summary>
        </member>
        <member name="F:TLPlan.World.Implementations.InvariantWorld.m_cache">
            <summary>
            The evaluation cache.
            </summary>
        </member>
        <member name="F:TLPlan.World.Implementations.InvariantWorld.m_skipDefinedFormulas">
            <summary>
            Whether to skip evaluation of certain defined formulas.
            </summary>
        </member>
        <member name="M:TLPlan.World.Implementations.InvariantWorld.#ctor(TLPlan.World.Implementations.BitSetFactsContainer,TLPlan.World.Implementations.ArrayFluentsContainer,TLPlan.TLPlanOptions)">
            <summary>
            Creates a new custom world with the specified facts and fluents containers.
            </summary>
            <param name="factsContainer">The facts container.</param>
            <param name="fluentsContainer">The fluents container.</param>
            <param name="options">The TLPlan options.</param>
        </member>
        <member name="M:TLPlan.World.Implementations.InvariantWorld.SkipDefinedFormula(PDDLParser.Exp.Formula.DefinedFormula)">
            <summary>
            Returns whether to skip evaluation of the given defined formula.
            </summary>
            <param name="formula">A defined formula.</param>
            <returns>Whether to skip evaluation of the given defined formula</returns>
        </member>
        <member name="M:TLPlan.World.Implementations.InvariantWorld.IsSet(PDDLParser.Exp.Formula.AtomicFormulaApplication)">
            <summary>
            Checks whether the specified described atomic formula holds in this world.
            </summary>
            <param name="formula">A described (and ground) atomic formula.</param>
            <returns>True, false, or unknown.</returns>
        </member>
        <member name="M:TLPlan.World.Implementations.InvariantWorld.GetNumericFluent(PDDLParser.Exp.Formula.NumericFluentApplication)">
            <summary>
            Returns the value of the specified numeric fluent in this world.
            </summary>
            <param name="fluent">A described (and ground) numeric fluent.</param>
            <returns>Unknown, undefined, or the value of the numeric fluent.</returns>
        </member>
        <member name="M:TLPlan.World.Implementations.InvariantWorld.GetObjectFluent(PDDLParser.Exp.Formula.ObjectFluentApplication)">
            <summary>
            Returns the value of the specified object fluent in this world.
            </summary>
            <param name="fluent">A described (and ground) object fluent.</param>
            <returns>Unknown, undefined, or a constant representing the value of the 
            object fluent.</returns>
        </member>
        <member name="M:TLPlan.World.Implementations.InvariantWorld.GetEvaluation(PDDLParser.Exp.Formula.TLPlan.DefinedPredicateApplication,System.Boolean@)">
            <summary>
            Returns an evaluation record which indicates whether the given defined predicate has
            already been evaluated with the provided arguments, as well as the cached evaluation 
            value.
            </summary>
            <param name="pred">The defined predicate application.</param>
            <param name="existing">This flag is set to true if the defined predicate is already in the
            process of (or has finished) being evaluated.</param>
            <returns>An evaluation record corresponding to the specified defined predicate and 
            arguments.</returns>
        </member>
        <member name="M:TLPlan.World.Implementations.InvariantWorld.GetEvaluation(PDDLParser.Exp.Formula.TLPlan.DefinedNumericFunctionApplication,System.Boolean@)">
            <summary>
            Returns an evaluation record which indicates whether the given defined numeric function has
            already been evaluated with the provided arguments, as well as the cached evaluation 
            value.
            </summary>
            <param name="function">The defined numeric function application.</param>
            <param name="existing">This flag is set to true if the defined numeric function is already
            in the process of (or has finished) being evaluated.</param>
            <returns>An evaluation record corresponding to the specified defined numeric function and 
            arguments.</returns>
        </member>
        <member name="M:TLPlan.World.Implementations.InvariantWorld.GetEvaluation(PDDLParser.Exp.Formula.TLPlan.DefinedObjectFunctionApplication,System.Boolean@)">
            <summary>
            Returns an evaluation record which indicates whether the given defined object function has
            already been evaluated with the provided arguments, as well as the cached evaluation 
            value.
            </summary>
            <param name="function">The defined object function application.</param>
            <param name="existing">This flag is set to true if the defined object function is already
            in the process of (or has finished) being evaluated.</param>
            <returns>An evaluation record corresponding to the specified defined object function and 
            arguments.</returns>
        </member>
        <member name="M:TLPlan.World.Implementations.InvariantWorld.SetInitialPredicate(PDDLParser.Exp.Formula.AtomicFormulaApplication)">
            <summary>
            Sets the specified atomic formula to true.
            </summary>
            <param name="formula">An atomic formula with constant arguments.</param>
        </member>
        <member name="M:TLPlan.World.Implementations.InvariantWorld.SetInitialNumericFluent(PDDLParser.Exp.Formula.NumericFluentApplication,System.Double)">
            <summary>
            Sets the new value of the specified numeric fluent.
            </summary>
            <param name="fluent">A numeric fluent with constant arguments.</param>
            <param name="value">The new value of the numeric fluent.</param>
        </member>
        <member name="M:TLPlan.World.Implementations.InvariantWorld.SetInitialObjectFluent(PDDLParser.Exp.Formula.ObjectFluentApplication,PDDLParser.Exp.Term.Constant)">
            <summary>
            Sets the new value of the specified object fluent.
            </summary>
            <param name="fluent">A object fluent with constant arguments.</param>
            <param name="value">The constant representing the new value of the object fluent.
            </param>
        </member>
        <member name="P:TLPlan.World.Implementations.InvariantWorld.InvariantPredicateInterval">
            <summary>
            The interval of predicates ID whose value are stored in this invariant world.
            </summary>
        </member>
        <member name="P:TLPlan.World.Implementations.InvariantWorld.InvariantNumericFluentInterval">
            <summary>
            The interval of numeric fluents ID whose value are stored in this invariant world.
            </summary>
        </member>
        <member name="P:TLPlan.World.Implementations.InvariantWorld.InvariantObjectFluentInterval">
            <summary>
            The interval of object fluents ID whose value are stored in this invariant world.
            </summary>
        </member>
        <member name="T:TLPlan.WaitForNextEventOperator">
            <summary>
            Represents the special wait-for-next-event operator, which is used to find the next evaluable
            event (which contains overall and end conditions and effects of prior operator applications) 
            and to apply it to the current world.
            </summary>
        </member>
        <member name="M:TLPlan.WaitForNextEventOperator.#ctor(System.Boolean)">
            <summary>
            Creates a new wait-for-next-event operator.
            </summary>
            <param name="isElided">Whether the operator should be elided from plans. Take note that if
            the operator is not elided, plan validation is not possible.</param>
        </member>
        <member name="M:TLPlan.WaitForNextEventOperator.IsApplicable(TLPlan.World.TLPlanReadOnlyDurativeClosedWorld)">
            <summary>
            Returns whether this operator is applicable to the given world, i.e. whether there are any events left to
            process and whether the remaning overall and end conditions are met.
            </summary>
            <param name="world">The world in which the verification occurs.</param>
            <returns>True if the operator's preconditions are met in the given world.</returns>
        </member>
        <member name="M:TLPlan.WaitForNextEventOperator.GetDuration(TLPlan.World.TLPlanReadOnlyDurativeClosedWorld)">
            <summary>
            Returns the duration of this operator as evaluated in the given world.
            The wait-for-next-event has no duration; it therefore throws an exception.
            </summary>
            <param name="world">The world in which the duration must be calculated (unused).</param>
            <exception cref="T:System.NotSupportedException">
            The operator has no duration. Call <see cref="P:TLPlan.WaitForNextEventOperator.HasDuration"/> to verify if the operator has a duration.
            </exception>
            <returns>The duration of this operator as evaluated in the given world.</returns>
        </member>
        <member name="M:TLPlan.WaitForNextEventOperator.ApplyInternal(TLPlan.World.TLPlanReadOnlyDurativeClosedWorld)">
            <summary>
            Applies the effects of this operator on a copy of the given world. This essentially retrieves the
            next events, applies the effects to the world and updates its timestamp.
            </summary>
            <param name="world">The world on which effects must be applied.</param>
            <returns>A copy of the given world on which the effects of this operator have been applied.</returns>
        </member>
        <member name="P:TLPlan.WaitForNextEventOperator.HasDuration">
            <summary>
            Verify whether this operator has a duration. The wait-for-next-event has no duration.
            </summary>
        </member>
        <member name="T:TLPlan.Utils.TraceWriter">
            <summary>
            Represents a class which can write traces to a given <see cref="T:System.IO.TextWriter"/> and print worlds to it.
            </summary>
        </member>
        <member name="F:TLPlan.Utils.TraceWriter.m_fullProblem">
            <summary>
            The current PDDL problem being solved.
            </summary>
        </member>
        <member name="F:TLPlan.Utils.TraceWriter.m_textWriter">
            <summary>
            The stream to which traces are to be written.
            </summary>
        </member>
        <member name="M:TLPlan.Utils.TraceWriter.#ctor(System.IO.TextWriter)">
            <summary>
            Creates a new trace writer with the given trace stream.
            </summary>
            <param name="writer">The stream to which traces are to be written.</param>
        </member>
        <member name="M:TLPlan.Utils.TraceWriter.WriteLine(System.String)">
            <summary>
            Logs a string to the trace stream.
            </summary>
            <param name="str">The string to be logged.</param>
        </member>
        <member name="M:TLPlan.Utils.TraceWriter.WriteLine(System.String,System.Object[])">
            <summary>
            Logs a formatted string to the trace stream.
            </summary>
            <param name="format">The formatted string.</param>
            <param name="args">The parameters of the formatted string.</param>
        </member>
        <member name="M:TLPlan.Utils.TraceWriter.PrintWorld(TLPlan.Node,TLPlan.World.WorldUtils.PrintWorldPart)">
            <summary>
            Prints a world to the trace stream.
            </summary>
            <param name="node">The node containing the world to print.</param>
            <param name="worldParts">The parts of the world to print.</param>
        </member>
        <member name="P:TLPlan.Utils.TraceWriter.FullProblem">
            <summary>
            Gets or sets the current PDDL problem being solved.
            </summary>
        </member>
        <member name="T:TLPlan.Utils.MultiDictionary.SortedMultiDictionary`2">
            <summary>
            Sorted multi-dictionary implemented as a sorted dictionary.
            </summary>
            <typeparam name="Key">The key type.</typeparam>
            <typeparam name="Value">The value type.</typeparam>
        </member>
        <member name="F:TLPlan.Utils.MultiDictionary.SortedMultiDictionary`2.m_items">
            <summary>
            Items are retrieved using the sorted dictionary.
            </summary>
        </member>
        <member name="M:TLPlan.Utils.MultiDictionary.SortedMultiDictionary`2.#ctor">
            <summary>
            Creates a new empty sorted multi-dictionary.
            </summary>
        </member>
        <member name="M:TLPlan.Utils.MultiDictionary.SortedMultiDictionary`2.RemoveFirst">
            <summary>
            Removes the first item present in the dictionary.
            </summary>
            <returns>The first item which was present in the dictionary.</returns>
        </member>
        <member name="P:TLPlan.Utils.MultiDictionary.SortedMultiDictionary`2.Items">
            <summary>
            Returns the all the items (sorted by key) present in the multi-dictionary.
            </summary>
        </member>
        <member name="T:TLPlan.Utils.General">
            <summary>
            Represents a set of general utility methods to be used in TLPlan.
            </summary>
        </member>
        <member name="M:TLPlan.Utils.General.ComparePair``2(System.Collections.Generic.KeyValuePair{``0,``1},System.Collections.Generic.KeyValuePair{``0,``1})">
            <summary>
            Compares two key/value pairs.
            Comparison is done on the key first, then on the value in case of equality.
            </summary>
            <typeparam name="Key">The key type.</typeparam>
            <typeparam name="Value">The value type.</typeparam>
            <param name="x">The first key/value pair.</param>
            <param name="y">The second key/value pair.</param>
            <returns>An integer representing the total order relation between the two pairs.</returns>
        </member>
        <member name="M:TLPlan.Utils.General.Hash(System.Int32)">
            <summary>
            Returns the hash code of an integer value.
            </summary>
            <param name="value">The value to hash.</param>
            <returns>The hash code of the integer value.</returns>
        </member>
        <member name="T:TLPlan.Algorithms.DepthBestFirstSearch">
            <summary>
            Depth-best-first search is a depth-first heuristic search.
            The successors of each node are explored in a best-first manner, but the graph itself
            is explored depth-first.
            </summary>
        </member>
        <member name="F:TLPlan.Algorithms.DepthBestFirstSearch.m_linkedOpen">
            <summary>
            The open set contains nodes yet to be explored.
            </summary>
        </member>
        <member name="F:TLPlan.Algorithms.DepthBestFirstSearch.m_open">
            <summary>
            This structure is used only if the CycleChecking option is on.
            It maps nodes to their location in <see cref="F:TLPlan.Algorithms.DepthBestFirstSearch.m_linkedOpen"/>, hence
            allowing efficient detection of cycles.
            </summary>
        </member>
        <member name="F:TLPlan.Algorithms.DepthBestFirstSearch.m_closed">
            <summary>
            This structure is used only if the CycleChecking option is on.
            The close set contains nodes which have already been explored.
            </summary>
        </member>
        <member name="F:TLPlan.Algorithms.DepthBestFirstSearch.m_worseOpenNodeContainer">
            <summary>
            When not null, this container holds the last node found in open which is
            equal to the current node but has a worse g-cost.
            </summary>
        </member>
        <member name="F:TLPlan.Algorithms.DepthBestFirstSearch.m_worseClosedNode">
            <summary>
            When not null, this container holds the last node found in closed which is
            equal to the current node but has a worse g-cost.
            </summary>
        </member>
        <member name="M:TLPlan.Algorithms.DepthBestFirstSearch.#ctor(TLPlan.TLPlanOptions,TLPlan.Statistics,TLPlan.Utils.TraceWriter)">
            <summary>
            Creates a new depth-best-first search algorithm with the specified options.
            </summary>
            <param name="options">Search options.</param>
            <param name="statistics">Statistics object to use.</param>
            <param name="traceWriter">The stream to which traces are to be written.</param>
        </member>
        <member name="M:TLPlan.Algorithms.DepthBestFirstSearch.Initialize(TLPlan.Node)">
            <summary>
            Initializes the search with the initial node.
            </summary>
            <param name="initialNode">The initial node.</param>
        </member>
        <member name="M:TLPlan.Algorithms.DepthBestFirstSearch.GetNextNode">
            <summary>
            Returns the next node in open set.
            </summary>
            <returns>The next node in open set.</returns>
        </member>
        <member name="M:TLPlan.Algorithms.DepthBestFirstSearch.CloseNode(TLPlan.Node)">
            <summary>
            Closes the given node.
            </summary>
            <param name="node">The node to close.</param>
        </member>
        <member name="M:TLPlan.Algorithms.DepthBestFirstSearch.CausesCycle(TLPlan.Node)">
            <summary>
            This function returns whether the given node was already examined and thus
            represents a cycle in the search graph.
            </summary>
            <param name="node">The node to check for cycles.</param>
            <returns>Whether the given node has already been examined.</returns>
        </member>
        <member name="M:TLPlan.Algorithms.DepthBestFirstSearch.AddSuccessor(TLPlan.Node)">
            <summary>
            Signals a new node to be explored eventually.
            This function returns whether to continue adding successors.
            </summary>
            <param name="successor">The new node to be explored.</param>
            <returns>Whether to continue adding successors, which is always true.</returns>
        </member>
        <member name="M:TLPlan.Algorithms.DepthBestFirstSearch.HasNextNode">
            <summary>
            Returns whether there is at least one node left in open set.
            </summary>
            <returns>Whether there is at least one node left in open set.</returns>
        </member>
        <member name="M:TLPlan.Algorithms.DepthBestFirstSearch.GetOpenCount">
            <summary>
            Returns the number of nodes in the open set, i.e. nodes which should 
            eventually be explored.
            This function is used for computing statistics.
            </summary>
            <returns>The number of nodes in the open set.</returns>
        </member>
        <member name="M:TLPlan.Algorithms.DepthBestFirstSearch.GetClosedCount">
            <summary>
            Returns the number of nodes in the closed set, i.e. nodes which have already
            been explored and whose successors have been generated.
            This function is used for computing statistics.
            </summary>
            <returns>The number of nodes in the closed set.</returns>
        </member>
        <member name="M:TLPlan.Algorithms.DepthBestFirstSearch.ResetAlgorithm">
            <summary>
            Resets the search.
            All data structures should be reinitialized.
            </summary>
        </member>
        <member name="M:TLPlan.Algorithms.DepthBestFirstSearch.GetSuccessors(System.Collections.Generic.IEnumerable{TLPlan.IOperator},TLPlan.Node)">
            <summary>
            Returns the valid successors of a given node.
            Instead of deferring the evaluation, all successors are immediately generated are
            sorted by their costs (descending).
            </summary>
            <param name="operators">The operators to use.</param>
            <param name="node">The current node.</param>
            <returns>The successors of the given node.</returns>
        </member>
        <member name="T:TLPlan.World.Implementations.TreeMapFluentsContainer">
            <summary>
            A treemap fluents container stores fluents in a treemap (sorted dictionary).
            This implementation is O(log n) for retrieving fluents' value, but allows for
            a much faster comparison between two fluents container, since treesets keep fluents
            sorted.
            Note that as is, a treeset fluents container cannot determine whether a fluent ID not
            contained in the treeset is actually "undefined" or "unknown", and hence always returns 
            unknown.
            </summary>
        </member>
        <member name="F:TLPlan.World.Implementations.TreeMapFluentsContainer.m_numericFluents">
            <summary>
            The treeset of numeric fluents IDs.
            </summary>
        </member>
        <member name="F:TLPlan.World.Implementations.TreeMapFluentsContainer.m_objectFluents">
            <summary>
            The treeset of object fluents IDs.
            </summary>
        </member>
        <member name="F:TLPlan.World.Implementations.TreeMapFluentsContainer.m_hashCode">
            <summary>
            The hash code of this fluents container.
            </summary>
        </member>
        <member name="M:TLPlan.World.Implementations.TreeMapFluentsContainer.#ctor(TLPlan.Utils.IntegerInterval,TLPlan.Utils.IntegerInterval)">
            <summary>
            Creates a new empty treeset fluents container.
            </summary>
            <param name="numericInterval">The interval of numeric fluents ID whose value are stored 
            in this new fluents container.</param>
            <param name="objectInterval">The interval of object fluents ID whose value are stored 
            in this new fluents container.</param>
        </member>
        <member name="M:TLPlan.World.Implementations.TreeMapFluentsContainer.Copy">
            <summary>
            Copies this fluent container.
            </summary>
            <returns>A copy of this fluent container.</returns>
        </member>
        <member name="M:TLPlan.World.Implementations.TreeMapFluentsContainer.GetNumericFluent(System.Int32)">
            <summary>
            Returns the value of the specified numeric fluent in this world.
            </summary>
            <param name="fluentID">A numeric fluent ID.</param>
            <returns>Unknown, undefined, or the value of the numeric fluent.</returns>
        </member>
        <member name="M:TLPlan.World.Implementations.TreeMapFluentsContainer.GetObjectFluent(System.Int32)">
            <summary>
            Returns the value of the specified object fluent in this world.
            </summary>
            <param name="fluentID">An object fluent ID.</param>
            <returns>Unknown, undefined, or a constant representing the value of the 
            object fluent.</returns>
        </member>
        <member name="M:TLPlan.World.Implementations.TreeMapFluentsContainer.SetNumericFluent(System.Int32,System.Double)">
            <summary>
            Sets the new value of the specified numeric fluent.
            </summary>
            <param name="fluentID">A numeric fluent ID.</param>
            <param name="value">The new value of the numeric fluent.</param>
        </member>
        <member name="M:TLPlan.World.Implementations.TreeMapFluentsContainer.SetObjectFluent(System.Int32,PDDLParser.Exp.Term.Constant)">
            <summary>
            Sets the new value of the specified object fluent.
            </summary>
            <param name="fluentID">An object fluent ID.</param>
            <param name="value">The constant representing the new value of the object fluent.
            </param>
        </member>
        <member name="M:TLPlan.World.Implementations.TreeMapFluentsContainer.UndefineObjectFluent(System.Int32)">
            <summary>
            Sets the specified object fluent to undefined.
            </summary>
            <param name="fluentID">An object fluent ID.</param>
        </member>
        <member name="M:TLPlan.World.Implementations.TreeMapFluentsContainer.Equals(System.Object)">
            <summary>
            Returns whether this fluents container is equal to another fluents container.
            Two hashset fluent containers are equal if all their respective fluents have the
            same value pairwise.
            </summary>
            <param name="obj">The other object to test for equality.</param>
            <returns>Whether this fluents container is equal to the other object.</returns>
        </member>
        <member name="M:TLPlan.World.Implementations.TreeMapFluentsContainer.GetHashCode">
            <summary>
            Returns the hash code of this fluents container.
            </summary>
            <returns>The hash code of this fluents container.</returns>
        </member>
        <member name="M:TLPlan.World.Implementations.TreeMapFluentsContainer.CompareTo(TLPlan.World.Implementations.FluentsContainer)">
            <summary>
            Compares this fluents container with another fluents container.
            Comparison is done first on the hash code, then on the number of defined fluents, and
            finally on the individual fluents themselves.
            </summary>
            <param name="other">The other fluents container to compare this fluents container to.</param>
            <returns>An integer representing the total order relation between the two fluents containers.
            </returns>
        </member>
        <member name="T:TLPlan.Plan">
            <summary>
            Represents a plan, i.e. certain number of operators with a partial order relationship.
            </summary>
        </member>
        <member name="F:TLPlan.Plan.m_operators">
            <summary>
            List of all operators in the plan.
            </summary>
        </member>
        <member name="F:TLPlan.Plan.m_order">
            <summary>
            Sorted set of pairs of operators (representing the predecessor-successor relationship)
            </summary>
        </member>
        <member name="F:TLPlan.Plan.m_cost">
            <summary>
            The cost of the plan.
            </summary>
        </member>
        <member name="M:TLPlan.Plan.ReconstructPlan(TLPlan.Node)">
            <summary>
            Reconstructs a plan from its last node (the one containing the goal world for a full plan).
            </summary>
            <param name="node">The last node of the plan (the one containing the goal world for a full plan).</param>
            <returns>A plan that leads to the given last node.</returns>
        </member>
        <member name="M:TLPlan.Plan.ScanPlan(TLPlan.Node)">
            <summary>
            Recursively scans the input node until the first one is reached, then adds
            the operators and their order to reconstruct the plan.
            </summary>
            <param name="node">The node to scan.</param>
            <returns>A plan operator representing the scanned node.</returns>
        </member>
        <member name="M:TLPlan.Plan.AddOperator(TLPlan.Node)">
            <summary>
            Adds an plan operator to the plan an returns it.
            </summary>
            <param name="node">The node used to create the plan operator.</param>
            <returns>The created plan operator, based on the given node.</returns>
        </member>
        <member name="M:TLPlan.Plan.AddOrder(TLPlan.Plan.PlanOperator,TLPlan.Plan.PlanOperator)">
            <summary>
            Adds an order relation between the two plan operators.
            </summary>
            <param name="op1">The predecessor plan operator.</param>
            <param name="op2">The successor plan operator.</param>
        </member>
        <member name="M:TLPlan.Plan.PrintOperators(System.IO.TextWriter)">
            <summary>
            Prints the plan's operators on the given stream.
            </summary>
            <param name="stream">The output stream.</param>
        </member>
        <member name="M:TLPlan.Plan.PrintOrder(System.IO.TextWriter)">
            <summary>
            Print the plan's operator order on the given stream.
            </summary>
            <param name="stream">The output stream.</param>
        </member>
        <member name="M:TLPlan.Plan.PrintPlan(System.IO.TextWriter)">
            <summary>
            Prints the plan on the given stream.
            Each step has the following format: "time : operator [duration]"
            </summary>
            <param name="stream">The output stream.</param>
        </member>
        <member name="M:TLPlan.Plan.PrintMetric(System.IO.TextWriter)">
            <summary>
            Prints the metric on the given stream.
            </summary>
            <param name="stream">The output stream.</param>
        </member>
        <member name="P:TLPlan.Plan.Operators">
            <summary>
            Gets the list of all operators in the plan.
            </summary>
        </member>
        <member name="P:TLPlan.Plan.Order">
            <summary>
            Gets the sorted set of pairs of operators (representing the predecessor-successor relationship)
            </summary>
        </member>
        <member name="P:TLPlan.Plan.PlanCost">
            <summary>
            Gets the cost of the plan.
            </summary>
        </member>
        <member name="T:TLPlan.Plan.PlanOperator">
            <summary>
            Represents an operator that can be ordered in a plan.
            </summary>
        </member>
        <member name="F:TLPlan.Plan.PlanOperator.m_op">
            <summary>
            The operator.
            </summary>
        </member>
        <member name="F:TLPlan.Plan.PlanOperator.m_elapsedTime">
            <summary>
            The time elapsed since the beginning of the plan at which time the operator was used.
            </summary>
        </member>
        <member name="F:TLPlan.Plan.PlanOperator.m_duration">
            <summary>
            The duration of the operator.
            </summary>
        </member>
        <member name="F:TLPlan.Plan.PlanOperator.m_sequenceNr">
            <summary>
            The sequence number of the operator.
            </summary>
        </member>
        <member name="M:TLPlan.Plan.PlanOperator.#ctor(TLPlan.IOperator,System.Int32,System.Double)">
            <summary>
            Creates a plan operator with no duration.
            </summary>
            <param name="op">The operator.</param>
            <param name="sequenceNr">The operator's sequence number.</param>
            <param name="elapsedTime">The elapsed time since the beginning of planning.</param>
        </member>
        <member name="M:TLPlan.Plan.PlanOperator.#ctor(TLPlan.IOperator,System.Int32,System.Double,System.Double)">
            <summary>
            Creates a plan operator.
            </summary>
            <param name="op">The operator.</param>
            <param name="sequenceNr">The operator's sequence number.</param>
            <param name="elapsedTime">The elapsed time since the beginning of planning.</param>
            <param name="duration">The duration of the operator.</param>
        </member>
        <member name="M:TLPlan.Plan.PlanOperator.CompareTo(TLPlan.Plan.PlanOperator)">
            <summary>
            Compares this plan operator with another plan operator.
            </summary>
            <param name="po">The other plan operator to compare this plan operator to.</param>
            <returns>An integer representing the total order relation between the two plan operators.</returns>
        </member>
        <member name="M:TLPlan.Plan.PlanOperator.Equals(System.Object)">
            <summary>
            Returns true if this plan operator is equal to a specified object.
            </summary>
            <param name="obj">Object to test for equality.</param>
            <returns>True if this plan operator is equal to the specified objet.</returns>
        </member>
        <member name="M:TLPlan.Plan.PlanOperator.GetHashCode">
            <summary>
            Returns the hash code of this plan operator.
            </summary>
            <returns>The hash code of this plan operator.</returns>
        </member>
        <member name="M:TLPlan.Plan.PlanOperator.ToString">
            <summary>
            Returns a string representation of this plan operator.
            </summary>
            <returns>A string representation of this plan operator.</returns>
        </member>
        <member name="M:TLPlan.Plan.PlanOperator.ToPlanString">
            <summary>
            Returns a string representation of this plan operator, specially formatted for plan output.
            </summary>
            <returns>A string representation of this plan operator, specially formatted for plan output.</returns>
        </member>
        <member name="P:TLPlan.Plan.PlanOperator.Operator">
            <summary>
            Gets the operator.
            </summary>
        </member>
        <member name="P:TLPlan.Plan.PlanOperator.ElapsedTime">
            <summary>
            Gets the elapsed time since the beginning of planning.
            </summary>
        </member>
        <member name="P:TLPlan.Plan.PlanOperator.IsElided">
            <summary>
            Gets whether the operator should be elided from the plan.
            </summary>
        </member>
        <member name="P:TLPlan.Plan.PlanOperator.SequenceNr">
            <summary>
            Gets the operator's sequence number.
            </summary>
        </member>
        <member name="T:TLPlan.Operator">
            <summary>
            Represents a STRIPS-like, non-durative operator.
            </summary>
        </member>
        <member name="F:TLPlan.Operator.m_precondition">
            <summary>
            This operator's precondition.
            </summary>
        </member>
        <member name="F:TLPlan.Operator.m_effect">
            <summary>
            This operator's effect.
            </summary>
        </member>
        <member name="F:TLPlan.Operator.m_duration">
            <summary>
            This operator's duration.
            </summary>
        </member>
        <member name="M:TLPlan.Operator.#ctor(System.String,PDDLParser.Exp.ILogicalExp,PDDLParser.Exp.IEffect,System.Boolean,System.Boolean)">
            <summary>
            Create a new STRIPS-like operator.
            </summary>
            <param name="name">The name of the operator.</param>
            <param name="precondition">The precondition of the operator.</param>
            <param name="effect">The effect of the operator.</param>
            <param name="isConcurrent">Whether this operator is used in concurrent planning.</param>
            <param name="isElided">Whether this operator should be elided from plans.</param>
        </member>
        <member name="M:TLPlan.Operator.GetDuration(TLPlan.World.TLPlanReadOnlyDurativeClosedWorld)">
            <summary>
            Returns the duration of this operator. This is always 0.0 when planning is concurrent, and 1.0 otherwise.
            </summary>
            <param name="world">The world in which the duration must be calculated (this is unused).</param>
            <returns>The duration of this operator.</returns>
        </member>
        <member name="M:TLPlan.Operator.IsApplicable(TLPlan.World.TLPlanReadOnlyDurativeClosedWorld)">
            <summary>
            Returns whether this operator is applicable to the given world, i.e. if it's preconditions are met.
            </summary>
            <param name="world">The world in which the verification occurs.</param>
            <returns>True if the operator's preconditions are met in the given world.</returns>
        </member>
        <member name="M:TLPlan.Operator.ApplyInternal(TLPlan.World.TLPlanReadOnlyDurativeClosedWorld)">
            <summary>
            Applies the effects of this operator on a copy of the given world.
            </summary>
            <param name="world">The world on which effects must be applied.</param>
            <returns>A copy of the given world on which the effects of this operator have been applied.</returns>
        </member>
    </members>
</doc>
